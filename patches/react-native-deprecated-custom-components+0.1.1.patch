diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/LICENSE b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/LICENSE
deleted file mode 100644
index c6a207c..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/LICENSE
+++ /dev/null
@@ -1,30 +0,0 @@
-BSD License
-
-For Immutable JS software
-
-Copyright (c) 2014-2015, Facebook, Inc. All rights reserved.
-
-Redistribution and use in source and binary forms, with or without modification,
-are permitted provided that the following conditions are met:
-
- * Redistributions of source code must retain the above copyright notice, this
-   list of conditions and the following disclaimer.
-
- * Redistributions in binary form must reproduce the above copyright notice,
-   this list of conditions and the following disclaimer in the documentation
-   and/or other materials provided with the distribution.
-
- * Neither the name Facebook nor the names of its contributors may be used to
-   endorse or promote products derived from this software without specific
-   prior written permission.
-
-THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
-ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
-ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/PATENTS b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/PATENTS
deleted file mode 100644
index b145145..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/PATENTS
+++ /dev/null
@@ -1,11 +0,0 @@
-Additional Grant of Patent Rights Version 2
-
-"Software" means the Immutable JS software distributed by Facebook, Inc.
-
-Facebook, Inc. (“Facebook”) hereby grants to each recipient of the Software (“you”) a perpetual, worldwide, royalty-free, non-exclusive, irrevocable (subject to the termination provision below) license under any Necessary Claims, to make, have made, use, sell, offer to sell, import, and otherwise transfer the Software. For avoidance of doubt, no license is granted under Facebook’s rights in any patent claims that are infringed by (i) modifications to the Software made by you or any third party or (ii) the Software in combination with any software or other technology.
-
-The license granted hereunder will terminate, automatically and without notice, if you (or any of your subsidiaries, corporate affiliates or agents) initiate directly or indirectly, or take a direct financial interest in, any Patent Assertion: (i) against Facebook or any of its subsidiaries or corporate affiliates, (ii) against any party if such Patent Assertion arises in whole or in part from any software, technology, product or service of Facebook or any of its subsidiaries or corporate affiliates, or (iii) against any party relating to the Software. Notwithstanding the foregoing, if Facebook or any of its subsidiaries or corporate affiliates files a lawsuit alleging patent infringement against you in the first instance, and you respond by filing a patent infringement counterclaim in that lawsuit against that party that is unrelated to the Software, the license granted hereunder will not terminate under section (i) of this paragraph due to such counterclaim.
-
-A “Necessary Claim” is a claim of a patent owned by Facebook that is necessarily infringed by the Software standing alone.
-
-A “Patent Assertion” is any lawsuit or other action alleging direct, indirect, or contributory infringement or inducement to infringe any patent, including a cross-claim or counterclaim.
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/README.md b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/README.md
deleted file mode 100644
index c1edf11..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/README.md
+++ /dev/null
@@ -1,464 +0,0 @@
-Immutable collections for JavaScript
-====================================
-
-[![Build Status](https://travis-ci.org/facebook/immutable-js.svg)](https://travis-ci.org/facebook/immutable-js)
-
-[Immutable][] data cannot be changed once created, leading to much simpler
-application development, no defensive copying, and enabling advanced memoization
-and change detection techniques with simple logic. [Persistent][] data presents
-a mutative API which does not update the data in-place, but instead always
-yields new updated data.
-
-`Immutable` provides Persistent Immutable `List`, `Stack`, `Map`, `OrderedMap`,
-`Set`, `OrderedSet` and `Record`. They are highly efficient on modern JavaScript
-VMs by using structural sharing via [hash maps tries][] and
-[vector tries][] as popularized by Clojure and Scala,
-minimizing the need to copy or cache data.
-
-`Immutable` also provides a lazy `Seq`, allowing efficient
-chaining of collection methods like `map` and `filter` without creating
-intermediate representations. Create some `Seq` with `Range` and `Repeat`.
-
-[Persistent]: http://en.wikipedia.org/wiki/Persistent_data_structure
-[Immutable]: http://en.wikipedia.org/wiki/Immutable_object
-[hash maps tries]: http://en.wikipedia.org/wiki/Hash_array_mapped_trie
-[vector tries]: http://hypirion.com/musings/understanding-persistent-vector-pt-1
-
-
-Getting started
----------------
-
-Install `immutable` using npm.
-
-```shell
-npm install immutable
-```
-
-Then require it into any module.
-
-```javascript
-var Immutable = require('immutable');
-var map1 = Immutable.Map({a:1, b:2, c:3});
-var map2 = map1.set('b', 50);
-map1.get('b'); // 2
-map2.get('b'); // 50
-```
-
-### Browser
-
-To use `immutable` from a browser, download [dist/immutable.min.js](./dist/immutable.min.js)
-or use a CDN such as [CDNJS](https://cdnjs.com/libraries/immutable)
-or [jsDelivr](http://www.jsdelivr.com/#!immutable.js).
-
-Then, add it as a script tag to your page:
-
-```html
-<script src="immutable.min.js"></script>
-<script>
-    var map1 = Immutable.Map({a:1, b:2, c:3});
-    var map2 = map1.set('b', 50);
-    map1.get('b'); // 2
-    map2.get('b'); // 50
-</script>
-```
-
-Or use an AMD loader (such as [RequireJS](http://requirejs.org/)):
-
-```javascript
-require(['./immutable.min.js'], function (Immutable) {
-    var map1 = Immutable.Map({a:1, b:2, c:3});
-    var map2 = map1.set('b', 50);
-    map1.get('b'); // 2
-    map2.get('b'); // 50
-});
-```
-
-If you're using [browserify](http://browserify.org/), the `immutable` npm module
-also works from the browser.
-
-### TypeScript
-
-Use these Immutable collections and sequences as you would use native
-collections in your [TypeScript](http://typescriptlang.org) programs while still taking
-advantage of type generics, error detection, and auto-complete in your IDE.
-
-Just add a reference with a relative path to the type declarations at the top
-of your file.
-
-```javascript
-///<reference path='./node_modules/immutable/dist/immutable.d.ts'/>
-import Immutable = require('immutable');
-var map1: Immutable.Map<string, number>;
-map1 = Immutable.Map({a:1, b:2, c:3});
-var map2 = map1.set('b', 50);
-map1.get('b'); // 2
-map2.get('b'); // 50
-```
-
-
-The case for Immutability
--------------------------
-
-Much of what makes application development difficult is tracking mutation and
-maintaining state. Developing with immutable data encourages you to think
-differently about how data flows through your application.
-
-Subscribing to data events throughout your application, by using
-`Object.observe`, or any other mechanism, creates a huge overhead of
-book-keeping which can hurt performance, sometimes dramatically, and creates
-opportunities for areas of your application to get out of sync with each other
-due to easy to make programmer error. Since immutable data never changes,
-subscribing to changes throughout the model is a dead-end and new data can only
-ever be passed from above.
-
-This model of data flow aligns well with the architecture of [React][]
-and especially well with an application designed using the ideas of [Flux][].
-
-When data is passed from above rather than being subscribed to, and you're only
-interested in doing work when something has changed, you can use equality.
-
-Immutable collections should be treated as *values* rather than *objects*. While
-objects represents some thing which could change over time, a value represents
-the state of that thing at a particular instance of time. This principle is most
-important to understanding the appropriate use of immutable data. In order to
-treat Immutable.js collections as values, it's important to use the
-`Immutable.is()` function or `.equals()` method to determine value equality
-instead of the `===` operator which determines object reference identity.
-
-```javascript
-var map1 = Immutable.Map({a:1, b:2, c:3});
-var map2 = map1.set('b', 2);
-assert(map1.equals(map2) === true);
-var map3 = map1.set('b', 50);
-assert(map1.equals(map3) === false);
-```
-
-Note: As a performance optimization `Immutable` attempts to return the existing
-collection when an operation would result in an identical collection, allowing
-for using `===` reference equality to determine if something definitely has not
-changed. This can be extremely useful when used within memoization function
-which would prefer to re-run the function if a deeper equality check could
-potentially be more costly. The `===` equality check is also used internally by
-`Immutable.is` and `.equals()` as a performance optimization.
-
-If an object is immutable, it can be "copied" simply by making another reference
-to it instead of copying the entire object. Because a reference is much smaller
-than the object itself, this results in memory savings and a potential boost in
-execution speed for programs which rely on copies (such as an undo-stack).
-
-```javascript
-var map1 = Immutable.Map({a:1, b:2, c:3});
-var clone = map1;
-```
-
-[React]: http://facebook.github.io/react/
-[Flux]: http://facebook.github.io/flux/docs/overview.html
-
-
-JavaScript-first API
---------------------
-
-While `immutable` is inspired by Clojure, Scala, Haskell and other functional
-programming environments, it's designed to bring these powerful concepts to
-JavaScript, and therefore has an Object-Oriented API that closely mirrors that
-of [ES6][] [Array][], [Map][], and [Set][].
-
-[ES6]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla
-[Array]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array
-[Map]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map
-[Set]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
-
-The difference for the immutable collections is that methods which would mutate
-the collection, like `push`, `set`, `unshift` or `splice` instead return a new
-immutable collection. Methods which return new arrays like `slice` or `concat`
-instead return new immutable collections.
-
-```javascript
-var list1 = Immutable.List.of(1, 2);
-var list2 = list1.push(3, 4, 5);
-var list3 = list2.unshift(0);
-var list4 = list1.concat(list2, list3);
-assert(list1.size === 2);
-assert(list2.size === 5);
-assert(list3.size === 6);
-assert(list4.size === 13);
-assert(list4.get(0) === 1);
-```
-
-Almost all of the methods on [Array][] will be found in similar form on
-`Immutable.List`, those of [Map][] found on `Immutable.Map`, and those of [Set][]
-found on `Immutable.Set`, including collection operations like `forEach()`
-and `map()`.
-
-```javascript
-var alpha = Immutable.Map({a:1, b:2, c:3, d:4});
-alpha.map((v, k) => k.toUpperCase()).join();
-// 'A,B,C,D'
-```
-
-### Accepts raw JavaScript objects.
-
-Designed to inter-operate with your existing JavaScript, `immutable`
-accepts plain JavaScript Arrays and Objects anywhere a method expects an
-`Iterable` with no performance penalty.
-
-```javascript
-var map1 = Immutable.Map({a:1, b:2, c:3, d:4});
-var map2 = Immutable.Map({c:10, a:20, t:30});
-var obj = {d:100, o:200, g:300};
-var map3 = map1.merge(map2, obj);
-// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }
-```
-
-This is possible because `immutable` can treat any JavaScript Array or Object
-as an Iterable. You can take advantage of this in order to get sophisticated
-collection methods on JavaScript Objects, which otherwise have a very sparse
-native API. Because Seq evaluates lazily and does not cache intermediate
-results, these operations can be extremely efficient.
-
-```javascript
-var myObject = {a:1,b:2,c:3};
-Immutable.Seq(myObject).map(x => x * x).toObject();
-// { a: 1, b: 4, c: 9 }
-```
-
-Keep in mind, when using JS objects to construct Immutable Maps, that
-JavaScript Object properties are always strings, even if written in a quote-less
-shorthand, while Immutable Maps accept keys of any type.
-
-```js
-var obj = { 1: "one" };
-Object.keys(obj); // [ "1" ]
-obj["1"]; // "one"
-obj[1];   // "one"
-
-var map = Immutable.fromJS(obj);
-map.get("1"); // "one"
-map.get(1);   // undefined
-```
-
-Property access for JavaScript Objects first converts the key to a string, but
-since Immutable Map keys can be of any type the argument to `get()` is
-not altered.
-
-
-### Converts back to raw JavaScript objects.
-
-All `immutable` Iterables can be converted to plain JavaScript Arrays and
-Objects shallowly with `toArray()` and `toObject()` or deeply with `toJS()`.
-All Immutable Iterables also implement `toJSON()` allowing them to be passed to
-`JSON.stringify` directly.
-
-```javascript
-var deep = Immutable.Map({ a: 1, b: 2, c: Immutable.List.of(3, 4, 5) });
-deep.toObject() // { a: 1, b: 2, c: List [ 3, 4, 5 ] }
-deep.toArray() // [ 1, 2, List [ 3, 4, 5 ] ]
-deep.toJS() // { a: 1, b: 2, c: [ 3, 4, 5 ] }
-JSON.stringify(deep) // '{"a":1,"b":2,"c":[3,4,5]}'
-```
-
-### Embraces ES6
-
-`Immutable` takes advantage of features added to JavaScript in [ES6][],
-the latest standard version of ECMAScript (JavaScript), including [Iterators][],
-[Arrow Functions][], [Classes][], and [Modules][]. It's also inspired by the
-[Map][] and [Set][] collections added to ES6. The library is "transpiled" to ES3
-in order to support all modern browsers.
-
-All examples are presented in ES6. To run in all browsers, they need to be
-translated to ES3.
-
-```js
-// ES6
-foo.map(x => x * x);
-// ES3
-foo.map(function (x) { return x * x; });
-```
-
-[Iterators]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/The_Iterator_protocol
-[Arrow Functions]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
-[Classes]: http://wiki.ecmascript.org/doku.php?id=strawman:maximally_minimal_classes
-[Modules]: http://www.2ality.com/2014/09/es6-modules-final.html
-
-
-Nested Structures
------------------
-
-The collections in `immutable` are intended to be nested, allowing for deep
-trees of data, similar to JSON.
-
-```javascript
-var nested = Immutable.fromJS({a:{b:{c:[3,4,5]}}});
-// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }
-```
-
-A few power-tools allow for reading and operating on nested data. The
-most useful are `mergeDeep`, `getIn`, `setIn`, and `updateIn`, found on `List`,
-`Map` and `OrderedMap`.
-
-```javascript
-var nested2 = nested.mergeDeep({a:{b:{d:6}}});
-// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }
-```
-
-```javascript
-nested2.getIn(['a', 'b', 'd']); // 6
-
-var nested3 = nested2.updateIn(['a', 'b', 'd'], value => value + 1);
-// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }
-
-var nested4 = nested3.updateIn(['a', 'b', 'c'], list => list.push(6));
-// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }
-```
-
-
-Lazy Seq
---------
-
-`Seq` describes a lazy operation, allowing them to efficiently chain
-use of all the Iterable methods (such as `map` and `filter`).
-
-**Seq is immutable** — Once a Seq is created, it cannot be
-changed, appended to, rearranged or otherwise modified. Instead, any mutative
-method called on a Seq will return a new Seq.
-
-**Seq is lazy** — Seq does as little work as necessary to respond to any
-method call.
-
-For example, the following does not perform any work, because the resulting
-Seq is never used:
-
-    var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
-      .filter(x => x % 2).map(x => x * x);
-
-Once the Seq is used, it performs only the work necessary. In this
-example, no intermediate arrays are ever created, filter is called three times,
-and map is only called twice:
-
-    console.log(oddSquares.get(1)); // 9
-
-Any collection can be converted to a lazy Seq with `.toSeq()`.
-
-    var seq = Immutable.Map({a:1, b:1, c:1}).toSeq();
-
-Seq allow for the efficient chaining of sequence operations, especially when
-converting to a different concrete type (such as to a JS object):
-
-    seq.flip().map(key => key.toUpperCase()).flip().toObject();
-    // Map { A: 1, B: 1, C: 1 }
-
-As well as expressing logic that would otherwise seem memory-limited:
-
-    Immutable.Range(1, Infinity)
-      .skip(1000)
-      .map(n => -n)
-      .filter(n => n % 2 === 0)
-      .take(2)
-      .reduce((r, n) => r * n, 1);
-    // 1006008
-
-Note: An iterable is always iterated in the same order, however that order may
-not always be well defined, as is the case for the `Map`.
-
-
-Equality treats Collections as Data
------------------------------------
-
-`Immutable` provides equality which treats immutable data structures as pure
-data, performing a deep equality check if necessary.
-
-```javascript
-var map1 = Immutable.Map({a:1, b:1, c:1});
-var map2 = Immutable.Map({a:1, b:1, c:1});
-assert(map1 !== map2); // two different instances
-assert(Immutable.is(map1, map2)); // have equivalent values
-assert(map1.equals(map2)); // alternatively use the equals method
-```
-
-`Immutable.is()` uses the same measure of equality as [Object.is][]
-including if both are immutable and all keys and values are equal
-using the same measure of equality.
-
-[Object.is]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
-
-
-Batching Mutations
-------------------
-
-> If a tree falls in the woods, does it make a sound?
->
-> If a pure function mutates some local data in order to produce an immutable
-> return value, is that ok?
->
-> — Rich Hickey, Clojure
-
-Applying a mutation to create a new immutable object results in some overhead,
-which can add up to a minor performance penalty. If you need to apply a series
-of mutations locally before returning, `Immutable` gives you the ability to
-create a temporary mutable (transient) copy of a collection and apply a batch of
-mutations in a performant manner by using `withMutations`. In fact, this is
-exactly how  `Immutable` applies complex mutations itself.
-
-As an example, building `list2` results in the creation of 1, not 3, new
-immutable Lists.
-
-```javascript
-var list1 = Immutable.List.of(1,2,3);
-var list2 = list1.withMutations(function (list) {
-  list.push(4).push(5).push(6);
-});
-assert(list1.size === 3);
-assert(list2.size === 6);
-```
-
-Note: `immutable` also provides `asMutable` and `asImmutable`, but only
-encourages their use when `withMutations` will not suffice. Use caution to not
-return a mutable copy, which could result in undesired behavior.
-
-*Important!*: Only a select few methods can be used in `withMutations` including
-`set`, `push` and `pop`. These methods can be applied directly against a
-persistent data-structure where other methods like `map`, `filter`, `sort`,
-and `splice` will always return new immutable data-structures and never mutate
-a mutable collection.
-
-
-Documentation
--------------
-
-[Read the docs](http://facebook.github.io/immutable-js/docs/) and eat your vegetables.
-
-Docs are automatically generated from [Immutable.d.ts](https://github.com/facebook/immutable-js/blob/master/type-definitions/Immutable.d.ts).
-Please contribute!
-
-Also, don't miss the [Wiki](https://github.com/facebook/immutable-js/wiki) which
-contains articles on specific topics. Can't find something? Open an [issue](https://github.com/facebook/immutable-js/issues).
-
-
-Contribution
-------------
-
-Use [Github issues](https://github.com/facebook/immutable-js/issues) for requests.
-
-We actively welcome pull requests, learn how to [contribute](./CONTRIBUTING.md).
-
-
-Changelog
----------
-
-Changes are tracked as [Github releases](https://github.com/facebook/immutable-js/releases).
-
-
-Thanks
-------
-
-[Phil Bagwell](https://www.youtube.com/watch?v=K2NYwP90bNs), for his inspiration
-and research in persistent data structures.
-
-[Hugh Jackson](https://github.com/hughfdjackson/), for providing the npm package
-name. If you're looking for his unsupported package, see [v1.4.1](https://www.npmjs.org/package/immutable/1.4.1).
-
-
-License
--------
-
-`Immutable` is [BSD-licensed](./LICENSE). We also provide an additional [patent grant](./PATENTS).
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/README.md b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/README.md
deleted file mode 100644
index 3021432..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/README.md
+++ /dev/null
@@ -1,33 +0,0 @@
-Cursors
--------
-
-Cursors allow you to hold a reference to a path in a nested immutable data
-structure, allowing you to pass smaller sections of a larger nested
-collection to portions of your application while maintaining a central point
-aware of changes to the entire data structure: an `onChange` function which is
-called whenever a cursor or sub-cursor calls `update`.
-
-This is particularly useful when used in conjuction with component-based UI
-libraries like [React](http://facebook.github.io/react/) or to simulate
-"state" throughout an application while maintaining a single flow of logic.
-
-
-```javascript
-var Immutable = require('immutable');
-var Cursor = require('immutable/contrib/cursor');
-
-var data = Immutable.fromJS({ a: { b: { c: 1 } } });
-var cursor = Cursor.from(data, ['a', 'b'], newData => {
-  data = newData;
-});
-
-// ... elsewhere ...
-
-cursor.get('c'); // 1
-cursor = cursor.update('c', x => x + 1);
-cursor.get('c'); // 2
-
-// ... back to data ...
-
-data.getIn(['a', 'b', 'c']); // 2
-```
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/__tests__/Cursor.ts b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/__tests__/Cursor.ts
deleted file mode 100644
index 9456cb5..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/__tests__/Cursor.ts
+++ /dev/null
@@ -1,391 +0,0 @@
-///<reference path='../../../resources/jest.d.ts'/>
-///<reference path='../../../dist/immutable.d.ts'/>
-///<reference path='../index.d.ts'/>
-
-jest.autoMockOff();
-
-import Immutable = require('immutable');
-import Cursor = require('immutable/contrib/cursor');
-
-jasmine.getEnv().addEqualityTester((a, b) =>
-  a instanceof Immutable.Iterable && b instanceof Immutable.Iterable ?
-    Immutable.is(a, b) :
-    jasmine.undefined
-);
-
-describe('Cursor', () => {
-
-  var json = { a: { b: { c: 1 } } };
-
-  it('gets from its path', () => {
-    var data = Immutable.fromJS(json);
-    var cursor = Cursor.from(data);
-
-    expect(cursor.deref()).toBe(data);
-
-    var deepCursor = cursor.cursor(['a', 'b']);
-    expect(deepCursor.deref().toJS()).toEqual(json.a.b);
-    expect(deepCursor.deref()).toBe(data.getIn(['a', 'b']));
-    expect(deepCursor.get('c')).toBe(1);
-
-    var leafCursor = deepCursor.cursor('c');
-    expect(leafCursor.deref()).toBe(1);
-
-    var missCursor = leafCursor.cursor('d');
-    expect(missCursor.deref()).toBe(undefined);
-  });
-
-  it('gets return new cursors', () => {
-    var data = Immutable.fromJS(json);
-    var cursor = Cursor.from(data);
-    var deepCursor = cursor.getIn(['a', 'b']);
-    expect(deepCursor.deref()).toBe(data.getIn(['a', 'b']));
-  });
-
-  it('gets return new cursors using List', () => {
-    var data = Immutable.fromJS(json);
-    var cursor = Cursor.from(data);
-    var deepCursor = cursor.getIn(Immutable.fromJS(['a', 'b']));
-    expect(deepCursor.deref()).toBe(data.getIn(Immutable.fromJS(['a', 'b'])));
-  });
-
-  it('cursor return new cursors of correct type', () => {
-    var data = Immutable.fromJS({ a: [1, 2, 3] });
-    var cursor = Cursor.from(data);
-    var deepCursor = <any>cursor.cursor('a');
-    expect(deepCursor.findIndex).toBeDefined();
-  });
-
-  it('can be treated as a value', () => {
-    var data = Immutable.fromJS(json);
-    var cursor = Cursor.from(data, ['a', 'b']);
-    expect(cursor.toJS()).toEqual(json.a.b);
-    expect(cursor).toEqual(data.getIn(['a', 'b']));
-    expect(cursor.size).toBe(1);
-    expect(cursor.get('c')).toBe(1);
-  });
-
-  it('can be value compared to a primitive', () => {
-    var data = Immutable.Map({ a: 'A' });
-    var aCursor = Cursor.from(data, 'a');
-    expect(aCursor.size).toBe(undefined);
-    expect(aCursor.deref()).toBe('A');
-    expect(Immutable.is(aCursor, 'A')).toBe(true);
-  });
-
-  it('updates at its path', () => {
-    var onChange = jest.genMockFunction();
-
-    var data = Immutable.fromJS(json);
-    var aCursor = Cursor.from(data, 'a', onChange);
-
-    var deepCursor = aCursor.cursor(['b', 'c']);
-    expect(deepCursor.deref()).toBe(1);
-
-    // cursor edits return new cursors:
-    var newDeepCursor = deepCursor.update(x => x + 1);
-    expect(newDeepCursor.deref()).toBe(2);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:{b:{c:2}}}),
-      data,
-      ['a', 'b', 'c']
-    );
-
-    var newestDeepCursor = newDeepCursor.update(x => x + 1);
-    expect(newestDeepCursor.deref()).toBe(3);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:{b:{c:3}}}),
-      Immutable.fromJS({a:{b:{c:2}}}),
-      ['a', 'b', 'c']
-    );
-
-    // meanwhile, data is still immutable:
-    expect(data.toJS()).toEqual(json);
-
-    // as is the original cursor.
-    expect(deepCursor.deref()).toBe(1);
-    var otherNewDeepCursor = deepCursor.update(x => x + 10);
-    expect(otherNewDeepCursor.deref()).toBe(11);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:{b:{c:11}}}),
-      data,
-      ['a', 'b', 'c']
-    );
-
-    // and update has been called exactly thrice.
-    expect(onChange.mock.calls.length).toBe(3);
-  });
-
-  it('updates with the return value of onChange', () => {
-    var onChange = jest.genMockFunction();
-
-    var data = Immutable.fromJS(json);
-    var deepCursor = Cursor.from(data, ['a', 'b', 'c'], onChange);
-
-    onChange.mockReturnValueOnce(undefined);
-    // onChange returning undefined has no effect
-    var newCursor = deepCursor.update(x => x + 1);
-    expect(newCursor.deref()).toBe(2);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:{b:{c:2}}}),
-      data,
-      ['a', 'b', 'c']
-    );
-
-    onChange.mockReturnValueOnce(Immutable.fromJS({a:{b:{c:11}}}));
-    // onChange returning something else has an effect
-    newCursor = newCursor.update(x => 999);
-    expect(newCursor.deref()).toBe(11);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:{b:{c:999}}}),
-      Immutable.fromJS({a:{b:{c:2}}}),
-      ['a', 'b', 'c']
-    );
-
-    // and update has been called exactly twice
-    expect(onChange.mock.calls.length).toBe(2);
-  });
-
-  it('has map API for update shorthand', () => {
-    var onChange = jest.genMockFunction();
-
-    var data = Immutable.fromJS(json);
-    var aCursor = Cursor.from(data, 'a', onChange);
-    var bCursor = aCursor.cursor('b');
-    var cCursor = bCursor.cursor('c');
-
-    expect(bCursor.set('c', 10).deref()).toEqual(
-      Immutable.fromJS({ c: 10 })
-    );
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({ a: { b: { c: 10 } } }),
-      data,
-      ['a', 'b', 'c']
-    );
-  });
-
-  it('creates maps as necessary', () => {
-    var data = Immutable.Map();
-    var cursor = Cursor.from(data, ['a', 'b', 'c']);
-    expect(cursor.deref()).toBe(undefined);
-    cursor = cursor.set('d', 3);
-    expect(cursor.deref()).toEqual(Immutable.Map({d: 3}));
-  });
-
-  it('can set undefined', () => {
-    var data = Immutable.Map();
-    var cursor = Cursor.from(data, ['a', 'b', 'c']);
-    expect(cursor.deref()).toBe(undefined);
-    cursor = cursor.set('d', undefined);
-    expect(cursor.toJS()).toEqual({d: undefined});
-  });
-
-  it('has the sequence API', () => {
-    var data = Immutable.Map({a: 1, b: 2, c: 3});
-    var cursor = Cursor.from(data);
-    expect(cursor.map((x: number) => x * x)).toEqual(Immutable.Map({a: 1, b: 4, c: 9}));
-  });
-
-  it('can push values on a List', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({a: {b: [0, 1, 2]}});
-    var cursor = Cursor.from(data, ['a', 'b'], onChange);
-
-    expect(cursor.push(3,4)).toEqual(Immutable.List([0, 1, 2, 3, 4]));
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a: {b: [0, 1, 2, 3, 4]}}),
-      data,
-      ['a', 'b']
-    );
-  });
-
-  it('can pop values of a List', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({a: {b: [0, 1, 2]}});
-    var cursor = Cursor.from(data, ['a', 'b'], onChange);
-
-    expect(cursor.pop()).toEqual(Immutable.List([0, 1]));
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a: {b: [0, 1]}}),
-      data,
-      ['a', 'b']
-    );
-  });
-
-  it('can unshift values on a List', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({a: {b: [0, 1, 2]}});
-    var cursor = Cursor.from(data, ['a', 'b'], onChange);
-
-    expect(cursor.unshift(-2, -1)).toEqual(Immutable.List([-2, -1, 0, 1, 2]));
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a: {b: [-2, -1, 0, 1, 2]}}),
-      data,
-      ['a', 'b']
-    );
-  });
-
-  it('can shift values of a List', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({a: {b: [0, 1, 2]}});
-    var cursor = Cursor.from(data, ['a', 'b'], onChange);
-
-    expect(cursor.shift()).toEqual(Immutable.List([1, 2]));
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a: {b: [1, 2]}}),
-      data,
-      ['a', 'b']
-    );
-  });
-
-
-  it('returns wrapped values for sequence API', () => {
-    var data = Immutable.fromJS({a: {v: 1}, b: {v: 2}, c: {v: 3}});
-    var onChange = jest.genMockFunction();
-    var cursor = Cursor.from(data, onChange);
-
-    var found = cursor.find(map => map.get('v') === 2);
-    expect(typeof found.deref).toBe('function'); // is a cursor!
-    found = found.set('v', 20);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a: {v: 1}, b: {v: 20}, c: {v: 3}}),
-      data,
-      ['b', 'v']
-    );
-  });
-
-  it('returns wrapped values for iteration API', () => {
-    var jsData = [{val: 0}, {val: 1}, {val: 2}];
-    var data = Immutable.fromJS(jsData);
-    var cursor = Cursor.from(data);
-    cursor.forEach(function (c, i) {
-      expect(typeof c.deref).toBe('function'); // is a cursor!
-      expect(c.get('val')).toBe(i);
-    });
-  });
-
-  it('can map over values to get subcursors', () => {
-    var data = Immutable.fromJS({a: {v: 1}, b: {v: 2}, c: {v: 3}});
-    var cursor = Cursor.from(data);
-
-    var mapped = cursor.map(val => {
-      expect(typeof val.deref).toBe('function'); // mapped values are cursors.
-      return val;
-    }).toMap();
-    // Mapped is not a cursor, but it is a sequence of cursors.
-    expect(typeof (<any>mapped).deref).not.toBe('function');
-    expect(typeof (<any>mapped.get('a')).deref).toBe('function');
-
-    // Same for indexed cursors
-    var data2 = Immutable.fromJS({x: [{v: 1}, {v: 2}, {v: 3}]});
-    var cursor2 = Cursor.from(data2);
-
-    var mapped2 = cursor2.get('x').map(val => {
-      expect(typeof val.deref).toBe('function'); // mapped values are cursors.
-      return val;
-    }).toList();
-    // Mapped is not a cursor, but it is a sequence of cursors.
-    expect(typeof mapped2.deref).not.toBe('function');
-    expect(typeof mapped2.get(0).deref).toBe('function');
-  });
-
-  it('can have mutations apply with a single callback', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({'a': 1});
-
-    var c1 = Cursor.from(data, onChange);
-    var c2 = c1.withMutations(m => m.set('b', 2).set('c', 3).set('d', 4));
-
-    expect(c1.deref().toObject()).toEqual({'a': 1});
-    expect(c2.deref().toObject()).toEqual({'a': 1, 'b': 2, 'c': 3, 'd': 4});
-    expect(onChange.mock.calls.length).toBe(1);
-  });
-
-  it('can use withMutations on an unfulfilled cursor', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({});
-
-    var c1 = Cursor.from(data, ['a', 'b', 'c'], onChange);
-    var c2 = c1.withMutations(m => m.set('x', 1).set('y', 2).set('z', 3));
-
-    expect(c1.deref()).toEqual(undefined);
-    expect(c2.deref()).toEqual(Immutable.fromJS(
-      { x: 1, y: 2, z: 3 }
-    ));
-    expect(onChange.mock.calls.length).toBe(1);
-  });
-
-  it('maintains indexed sequences', () => {
-    var data = Immutable.fromJS([]);
-    var c = Cursor.from(data);
-    expect(c.toJS()).toEqual([]);
-  });
-
-  it('properly acts as an iterable', () => {
-    var data = Immutable.fromJS({key: {val: 1}});
-    var c = Cursor.from(data).values();
-    var c1 = c.next().value.get('val');
-    expect(c1).toBe(1);
-  });
-
-  it('can update deeply', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({a:{b:{c:1}}});
-    var c = Cursor.from(data, ['a'], onChange);
-    var c1 = c.updateIn(['b', 'c'], x => x * 10);
-    expect(c1.getIn(['b', 'c'])).toBe(10);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:{b:{c:10}}}),
-      data,
-      ['a', 'b', 'c']
-    );
-  });
-
-  it('can set deeply', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({a:{b:{c:1}}});
-    var c = Cursor.from(data, ['a'], onChange);
-    var c1 = c.setIn(['b', 'c'], 10);
-    expect(c1.getIn(['b', 'c'])).toBe(10);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:{b:{c:10}}}),
-      data,
-      ['a', 'b', 'c']
-    );
-  });
-
-  it('can get Record value as a property', () => {
-    var User = Immutable.Record({ name: 'John' });
-    var users = Immutable.List.of(new User());
-    var data = Immutable.Map({'users': users});
-    var cursor = Cursor.from(data, ['users']);
-    expect(cursor.first().name).toBe('John');
-  });
-
-  it('can set value of a cursor directly', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({a:1});
-    var c = Cursor.from(data, ['a'], onChange);
-    var c1 = c.set(2);
-    expect(c1.deref()).toBe(2);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:2}),
-      data,
-      ['a']
-    );
-  });
-
-  it('can set value of a cursor to undefined directly', () => {
-    var onChange = jest.genMockFunction();
-    var data = Immutable.fromJS({a:1});
-    var c = Cursor.from(data, ['a'], onChange);
-    var c1 = c.set(undefined);
-    expect(c1.deref()).toBe(undefined);
-    expect(onChange).lastCalledWith(
-      Immutable.fromJS({a:undefined}),
-      data,
-      ['a']
-    );
-  });
-
-});
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/index.d.ts b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/index.d.ts
deleted file mode 100644
index d950f98..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/index.d.ts
+++ /dev/null
@@ -1,291 +0,0 @@
-/**
- *  Copyright (c) 2014-2015, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- */
-
-
-/**
- * Cursors
- * -------
- *
- * Cursors allow you to hold a reference to a path in a nested immutable data
- * structure, allowing you to pass smaller sections of a larger nested
- * collection to portions of your application while maintaining a central point
- * aware of changes to the entire data structure.
- *
- * This is particularly useful when used in conjuction with component-based UI
- * libraries like [React](http://facebook.github.io/react/) or to simulate
- * "state" throughout an application while maintaining a single flow of logic.
- *
- * Cursors provide a simple API for getting the value at that path
- * (the equivalent of `this.getIn(keyPath)`), updating the value at that path
- * (the equivalent of `this.updateIn(keyPath)`), and getting a sub-cursor
- * starting from that path.
- *
- * When updated, a new root collection is created and provided to the `onChange`
- * function provided to the first call to `Cursor(map, onChange)`.
- *
- * When this cursor's (or any of its sub-cursors') `update` method is called,
- * the resulting new data structure will be provided to the `onChange`
- * function. Use this callback to keep track of the most current value or
- * update the rest of your application.
- */
-
-declare module 'immutable/contrib/cursor' {
-
-  ///<reference path='../../dist/immutable.d.ts'/>
-  import Immutable = require('immutable');
-
-
-  export function from(
-    collection: Immutable.Collection<any, any>,
-    onChange?: (newValue: any, oldValue?: any, keyPath?: Array<any>) => any
-  ): Cursor;
-  export function from(
-    collection: Immutable.Collection<any, any>,
-    keyPath: Array<any>,
-    onChange?: (newValue: any, oldValue?: any, keyPath?: Array<any>) => any
-  ): Cursor;
-  export function from(
-    collection: Immutable.Collection<any, any>,
-    key: any,
-    onChange?: (newValue: any, oldValue?: any, keyPath?: Array<any>) => any
-  ): Cursor;
-
-
-  export interface Cursor extends Immutable.Seq<any, any> {
-
-    /**
-     * Returns a sub-cursor following the key-path starting from this cursor.
-     */
-    cursor(subKeyPath: Array<any>): Cursor;
-    cursor(subKey: any): Cursor;
-
-    /**
-     * Returns the value at the cursor, if the cursor path does not yet exist,
-     * returns `notSetValue`.
-     */
-    deref(notSetValue?: any): any;
-
-    /**
-     * Returns the value at the `key` in the cursor, or `notSetValue` if it
-     * does not exist.
-     *
-     * If the key would return a collection, a new Cursor is returned.
-     */
-    get(key: any, notSetValue?: any): any;
-
-    /**
-     * Returns the value at the `keyPath` in the cursor, or `notSetValue` if it
-     * does not exist.
-     *
-     * If the keyPath would return a collection, a new Cursor is returned.
-     */
-    getIn(keyPath: Array<any>, notSetValue?: any): any;
-    getIn(keyPath: Immutable.Iterable<any, any>, notSetValue?: any): any;
-
-    /**
-     * Sets `value` at `key` in the cursor, returning a new cursor to the same
-     * point in the new data.
-     *
-     * If only one parameter is provided, it is set directly as the cursor's value.
-     */
-    set(key: any, value: any): Cursor;
-    set(value: any): Cursor;
-
-    /**
-     * Deletes `key` from the cursor, returning a new cursor to the same
-     * point in the new data.
-     *
-     * Note: `delete` cannot be safely used in IE8
-     * @alias remove
-     */
-    delete(key: any): Cursor;
-    remove(key: any): Cursor;
-
-    /**
-     * Clears the value at this cursor, returning a new cursor to the same
-     * point in the new data.
-     */
-    clear(): Cursor;
-
-    /**
-     * Updates the value in the data this cursor points to, triggering the
-     * callback for the root cursor and returning a new cursor pointing to the
-     * new data.
-     */
-    update(updater: (value: any) => any): Cursor;
-    update(key: any, updater: (value: any) => any): Cursor;
-    update(key: any, notSetValue: any, updater: (value: any) => any): Cursor;
-
-    /**
-     * @see `Map#merge`
-     */
-    merge(...iterables: Immutable.Iterable<any, any>[]): Cursor;
-    merge(...iterables: {[key: string]: any}[]): Cursor;
-
-    /**
-     * @see `Map#mergeWith`
-     */
-    mergeWith(
-      merger: (previous?: any, next?: any) => any,
-      ...iterables: Immutable.Iterable<any, any>[]
-    ): Cursor;
-    mergeWith(
-      merger: (previous?: any, next?: any) => any,
-      ...iterables: {[key: string]: any}[]
-    ): Cursor;
-
-    /**
-     * @see `Map#mergeDeep`
-     */
-    mergeDeep(...iterables: Immutable.Iterable<any, any>[]): Cursor;
-    mergeDeep(...iterables: {[key: string]: any}[]): Cursor;
-
-    /**
-     * @see `Map#mergeDeepWith`
-     */
-    mergeDeepWith(
-      merger: (previous?: any, next?: any) => any,
-      ...iterables: Immutable.Iterable<any, any>[]
-    ): Cursor;
-    mergeDeepWith(
-      merger: (previous?: any, next?: any) => any,
-      ...iterables: {[key: string]: any}[]
-    ): Cursor;
-
-    // Deep persistent changes
-
-    /**
-     * Returns a new Cursor having set `value` at this `keyPath`. If any keys in
-     * `keyPath` do not exist, a new immutable Map will be created at that key.
-     */
-    setIn(keyPath: Array<any>, value: any): Cursor;
-    setIn(keyPath: Immutable.Iterable<any, any>, value: any): Cursor;
-
-    /**
-     * Returns a new Cursor with provided `values` appended
-     */
-    push(...values: Array<any>): Cursor;
-
-    /**
-     * Returns a new Cursor with a size ones less than this Cursor,
-     * excluding the last index in this Cursor.
-     */
-    pop(): Cursor;
-
-    /**
-     * Returns a new Cursor with the provided `values` prepended,
-     * shifting other values ahead to higher indices.
-     */
-    unshift(...values: Array<any>): Cursor;
-
-    /**
-     * Returns a new Cursor with a size ones less than this Cursor, excluding
-     * the first index in this Cursor, shifting all other values to a lower index.
-     */
-    shift(): Cursor;
-
-    /**
-     * Returns a new Cursor having removed the value at this `keyPath`.
-     *
-     * @alias removeIn
-     */
-    deleteIn(keyPath: Array<any>): Cursor;
-    deleteIn(keyPath: Immutable.Iterable<any, any>): Cursor;
-    removeIn(keyPath: Array<any>): Cursor;
-    removeIn(keyPath: Immutable.Iterable<any, any>): Cursor;
-
-    /**
-     * Returns a new Cursor having applied the `updater` to the value found at
-     * the keyPath.
-     *
-     * If any keys in `keyPath` do not exist, new Immutable `Map`s will
-     * be created at those keys. If the `keyPath` does not already contain a
-     * value, the `updater` function will be called with `notSetValue`, if
-     * provided, otherwise `undefined`.
-     *
-     * If the `updater` function returns the same value it was called with, then
-     * no change will occur. This is still true if `notSetValue` is provided.
-     */
-    updateIn(
-      keyPath: Array<any>,
-      updater: (value: any) => any
-    ): Cursor;
-    updateIn(
-      keyPath: Array<any>,
-      notSetValue: any,
-      updater: (value: any) => any
-    ): Cursor;
-    updateIn(
-      keyPath: Immutable.Iterable<any, any>,
-      updater: (value: any) => any
-    ): Cursor;
-    updateIn(
-      keyPath: Immutable.Iterable<any, any>,
-      notSetValue: any,
-      updater: (value: any) => any
-    ): Cursor;
-
-    /**
-     * A combination of `updateIn` and `merge`, returning a new Cursor, but
-     * performing the merge at a point arrived at by following the keyPath.
-     * In other words, these two lines are equivalent:
-     *
-     *     x.updateIn(['a', 'b', 'c'], abc => abc.merge(y));
-     *     x.mergeIn(['a', 'b', 'c'], y);
-     *
-     */
-    mergeIn(
-      keyPath: Immutable.Iterable<any, any>,
-      ...iterables: Immutable.Iterable<any, any>[]
-    ): Cursor;
-    mergeIn(
-      keyPath: Array<any>,
-      ...iterables: Immutable.Iterable<any, any>[]
-    ): Cursor;
-    mergeIn(
-      keyPath: Array<any>,
-      ...iterables: {[key: string]: any}[]
-    ): Cursor;
-
-    /**
-     * A combination of `updateIn` and `mergeDeep`, returning a new Cursor, but
-     * performing the deep merge at a point arrived at by following the keyPath.
-     * In other words, these two lines are equivalent:
-     *
-     *     x.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y));
-     *     x.mergeDeepIn(['a', 'b', 'c'], y);
-     *
-     */
-    mergeDeepIn(
-      keyPath: Immutable.Iterable<any, any>,
-      ...iterables: Immutable.Iterable<any, any>[]
-    ): Cursor;
-    mergeDeepIn(
-      keyPath: Array<any>,
-      ...iterables: Immutable.Iterable<any, any>[]
-    ): Cursor;
-    mergeDeepIn(
-      keyPath: Array<any>,
-      ...iterables: {[key: string]: any}[]
-    ): Cursor;
-
-    // Transient changes
-
-    /**
-     * Every time you call one of the above functions, a new immutable value is
-     * created and the callback is triggered. If you need to apply a series of
-     * mutations to a Cursor without triggering the callback repeatedly,
-     * `withMutations()` creates a temporary mutable copy of the value which
-     * can apply mutations in a highly performant manner. Afterwards the
-     * callback is triggered with the final value.
-     */
-    withMutations(mutator: (mutable: any) => any): Cursor;
-  }
-
-}
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/index.js b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/index.js
deleted file mode 100644
index dd1bcc6..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/contrib/cursor/index.js
+++ /dev/null
@@ -1,343 +0,0 @@
-/**
- *  Copyright (c) 2014-2015, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- */
-
-/**
- * Cursor is expected to be required in a node or other CommonJS context:
- *
- *     var Cursor = require('immutable/contrib/cursor');
- *
- * If you wish to use it in the browser, please check out Browserify or WebPack!
- */
-
-var Immutable = require('immutable');
-var Iterable = Immutable.Iterable;
-var Iterator = Iterable.Iterator;
-var Seq = Immutable.Seq;
-var Map = Immutable.Map;
-var Record = Immutable.Record;
-
-
-function cursorFrom(rootData, keyPath, onChange) {
-  if (arguments.length === 1) {
-    keyPath = [];
-  } else if (typeof keyPath === 'function') {
-    onChange = keyPath;
-    keyPath = [];
-  } else {
-    keyPath = valToKeyPath(keyPath);
-  }
-  return makeCursor(rootData, keyPath, onChange);
-}
-
-
-var KeyedCursorPrototype = Object.create(Seq.Keyed.prototype);
-var IndexedCursorPrototype = Object.create(Seq.Indexed.prototype);
-
-function KeyedCursor(rootData, keyPath, onChange, size) {
-  this.size = size;
-  this._rootData = rootData;
-  this._keyPath = keyPath;
-  this._onChange = onChange;
-}
-KeyedCursorPrototype.constructor = KeyedCursor;
-
-function IndexedCursor(rootData, keyPath, onChange, size) {
-  this.size = size;
-  this._rootData = rootData;
-  this._keyPath = keyPath;
-  this._onChange = onChange;
-}
-IndexedCursorPrototype.constructor = IndexedCursor;
-
-KeyedCursorPrototype.toString = function() {
-  return this.__toString('Cursor {', '}');
-}
-IndexedCursorPrototype.toString = function() {
-  return this.__toString('Cursor [', ']');
-}
-
-KeyedCursorPrototype.deref =
-KeyedCursorPrototype.valueOf =
-IndexedCursorPrototype.deref =
-IndexedCursorPrototype.valueOf = function(notSetValue) {
-  return this._rootData.getIn(this._keyPath, notSetValue);
-}
-
-KeyedCursorPrototype.get =
-IndexedCursorPrototype.get = function(key, notSetValue) {
-  return this.getIn([key], notSetValue);
-}
-
-KeyedCursorPrototype.getIn =
-IndexedCursorPrototype.getIn = function(keyPath, notSetValue) {
-  keyPath = listToKeyPath(keyPath);
-  if (keyPath.length === 0) {
-    return this;
-  }
-  var value = this._rootData.getIn(newKeyPath(this._keyPath, keyPath), NOT_SET);
-  return value === NOT_SET ? notSetValue : wrappedValue(this, keyPath, value);
-}
-
-IndexedCursorPrototype.set =
-KeyedCursorPrototype.set = function(key, value) {
-  if(arguments.length === 1) {
-    return updateCursor(this, function() { return key; }, []);
-  } else {
-    return updateCursor(this, function (m) { return m.set(key, value); }, [key]);
-  }
-}
-
-IndexedCursorPrototype.push = function(/* values */) {
-  var args = arguments;
-  return updateCursor(this, function (m) {
-    return m.push.apply(m, args);
-  });
-}
-
-IndexedCursorPrototype.pop = function() {
-  return updateCursor(this, function (m) {
-    return m.pop();
-  });
-}
-
-IndexedCursorPrototype.unshift = function(/* values */) {
-  var args = arguments;
-  return updateCursor(this, function (m) {
-    return m.unshift.apply(m, args);
-  });
-}
-
-IndexedCursorPrototype.shift = function() {
-  return updateCursor(this, function (m) {
-    return m.shift();
-  });
-}
-
-IndexedCursorPrototype.setIn =
-KeyedCursorPrototype.setIn = Map.prototype.setIn;
-
-KeyedCursorPrototype.remove =
-KeyedCursorPrototype['delete'] =
-IndexedCursorPrototype.remove =
-IndexedCursorPrototype['delete'] = function(key) {
-  return updateCursor(this, function (m) { return m.remove(key); }, [key]);
-}
-
-IndexedCursorPrototype.removeIn =
-IndexedCursorPrototype.deleteIn =
-KeyedCursorPrototype.removeIn =
-KeyedCursorPrototype.deleteIn = Map.prototype.deleteIn;
-
-KeyedCursorPrototype.clear =
-IndexedCursorPrototype.clear = function() {
-  return updateCursor(this, function (m) { return m.clear(); });
-}
-
-IndexedCursorPrototype.update =
-KeyedCursorPrototype.update = function(keyOrFn, notSetValue, updater) {
-  return arguments.length === 1 ?
-    updateCursor(this, keyOrFn) :
-    this.updateIn([keyOrFn], notSetValue, updater);
-}
-
-IndexedCursorPrototype.updateIn =
-KeyedCursorPrototype.updateIn = function(keyPath, notSetValue, updater) {
-  return updateCursor(this, function (m) {
-    return m.updateIn(keyPath, notSetValue, updater);
-  }, keyPath);
-}
-
-IndexedCursorPrototype.merge =
-KeyedCursorPrototype.merge = function(/*...iters*/) {
-  var args = arguments;
-  return updateCursor(this, function (m) {
-    return m.merge.apply(m, args);
-  });
-}
-
-IndexedCursorPrototype.mergeWith =
-KeyedCursorPrototype.mergeWith = function(merger/*, ...iters*/) {
-  var args = arguments;
-  return updateCursor(this, function (m) {
-    return m.mergeWith.apply(m, args);
-  });
-}
-
-IndexedCursorPrototype.mergeIn =
-KeyedCursorPrototype.mergeIn = Map.prototype.mergeIn;
-
-IndexedCursorPrototype.mergeDeep =
-KeyedCursorPrototype.mergeDeep = function(/*...iters*/) {
-  var args = arguments;
-  return updateCursor(this, function (m) {
-    return m.mergeDeep.apply(m, args);
-  });
-}
-
-IndexedCursorPrototype.mergeDeepWith =
-KeyedCursorPrototype.mergeDeepWith = function(merger/*, ...iters*/) {
-  var args = arguments;
-  return updateCursor(this, function (m) {
-    return m.mergeDeepWith.apply(m, args);
-  });
-}
-
-IndexedCursorPrototype.mergeDeepIn =
-KeyedCursorPrototype.mergeDeepIn = Map.prototype.mergeDeepIn;
-
-KeyedCursorPrototype.withMutations =
-IndexedCursorPrototype.withMutations = function(fn) {
-  return updateCursor(this, function (m) {
-    return (m || Map()).withMutations(fn);
-  });
-}
-
-KeyedCursorPrototype.cursor =
-IndexedCursorPrototype.cursor = function(subKeyPath) {
-  subKeyPath = valToKeyPath(subKeyPath);
-  return subKeyPath.length === 0 ? this : subCursor(this, subKeyPath);
-}
-
-/**
- * All iterables need to implement __iterate
- */
-KeyedCursorPrototype.__iterate =
-IndexedCursorPrototype.__iterate = function(fn, reverse) {
-  var cursor = this;
-  var deref = cursor.deref();
-  return deref && deref.__iterate ? deref.__iterate(
-    function (v, k) { return fn(wrappedValue(cursor, [k], v), k, cursor); },
-    reverse
-  ) : 0;
-}
-
-/**
- * All iterables need to implement __iterator
- */
-KeyedCursorPrototype.__iterator =
-IndexedCursorPrototype.__iterator = function(type, reverse) {
-  var deref = this.deref();
-  var cursor = this;
-  var iterator = deref && deref.__iterator &&
-    deref.__iterator(Iterator.ENTRIES, reverse);
-  return new Iterator(function () {
-    if (!iterator) {
-      return { value: undefined, done: true };
-    }
-    var step = iterator.next();
-    if (step.done) {
-      return step;
-    }
-    var entry = step.value;
-    var k = entry[0];
-    var v = wrappedValue(cursor, [k], entry[1]);
-    return {
-      value: type === Iterator.KEYS ? k : type === Iterator.VALUES ? v : [k, v],
-      done: false
-    };
-  });
-}
-
-KeyedCursor.prototype = KeyedCursorPrototype;
-IndexedCursor.prototype = IndexedCursorPrototype;
-
-
-var NOT_SET = {}; // Sentinel value
-
-function makeCursor(rootData, keyPath, onChange, value) {
-  if (arguments.length < 4) {
-    value = rootData.getIn(keyPath);
-  }
-  var size = value && value.size;
-  var CursorClass = Iterable.isIndexed(value) ? IndexedCursor : KeyedCursor;
-  var cursor = new CursorClass(rootData, keyPath, onChange, size);
-
-  if (value instanceof Record) {
-    defineRecordProperties(cursor, value);
-  }
-
-  return cursor;
-}
-
-function defineRecordProperties(cursor, value) {
-  try {
-    value._keys.forEach(setProp.bind(undefined, cursor));
-  } catch (error) {
-    // Object.defineProperty failed. Probably IE8.
-  }
-}
-
-function setProp(prototype, name) {
-  Object.defineProperty(prototype, name, {
-    get: function() {
-      return this.get(name);
-    },
-    set: function(value) {
-      if (!this.__ownerID) {
-        throw new Error('Cannot set on an immutable record.');
-      }
-    }
-  });
-}
-
-function wrappedValue(cursor, keyPath, value) {
-  return Iterable.isIterable(value) ? subCursor(cursor, keyPath, value) : value;
-}
-
-function subCursor(cursor, keyPath, value) {
-  if (arguments.length < 3) {
-    return makeCursor( // call without value
-      cursor._rootData,
-      newKeyPath(cursor._keyPath, keyPath),
-      cursor._onChange
-    );
-  }
-  return makeCursor(
-    cursor._rootData,
-    newKeyPath(cursor._keyPath, keyPath),
-    cursor._onChange,
-    value
-  );
-}
-
-function updateCursor(cursor, changeFn, changeKeyPath) {
-  var deepChange = arguments.length > 2;
-  var newRootData = cursor._rootData.updateIn(
-    cursor._keyPath,
-    deepChange ? Map() : undefined,
-    changeFn
-  );
-  var keyPath = cursor._keyPath || [];
-  var result = cursor._onChange && cursor._onChange.call(
-    undefined,
-    newRootData,
-    cursor._rootData,
-    deepChange ? newKeyPath(keyPath, changeKeyPath) : keyPath
-  );
-  if (result !== undefined) {
-    newRootData = result;
-  }
-  return makeCursor(newRootData, cursor._keyPath, cursor._onChange);
-}
-
-function newKeyPath(head, tail) {
-  return head.concat(listToKeyPath(tail));
-}
-
-function listToKeyPath(list) {
-  return Array.isArray(list) ? list : Immutable.Iterable(list).toArray();
-}
-
-function valToKeyPath(val) {
-  return Array.isArray(val) ? val :
-    Iterable.isIterable(val) ? val.toArray() :
-    [val];
-}
-
-exports.from = cursorFrom;
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.d.ts b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.d.ts
deleted file mode 100644
index f8eb1c6..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.d.ts
+++ /dev/null
@@ -1,2531 +0,0 @@
-/**
- *  Copyright (c) 2014-2015, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- */
-
-/**
- * Immutable data encourages pure functions (data-in, data-out) and lends itself
- * to much simpler application development and enabling techniques from
- * functional programming such as lazy evaluation.
- *
- * While designed to bring these powerful functional concepts to JavaScript, it
- * presents an Object-Oriented API familiar to Javascript engineers and closely
- * mirroring that of Array, Map, and Set. It is easy and efficient to convert to
- * and from plain Javascript types.
-
- * Note: all examples are presented in [ES6][]. To run in all browsers, they
- * need to be translated to ES3. For example:
- *
- *     // ES6
- *     foo.map(x => x * x);
- *     // ES3
- *     foo.map(function (x) { return x * x; });
- *
- * [ES6]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla
- */
-
-declare module Immutable {
-
-  /**
-   * Deeply converts plain JS objects and arrays to Immutable Maps and Lists.
-   *
-   * If a `reviver` is optionally provided, it will be called with every
-   * collection as a Seq (beginning with the most nested collections
-   * and proceeding to the top-level collection itself), along with the key
-   * refering to each collection and the parent JS object provided as `this`.
-   * For the top level, object, the key will be `""`. This `reviver` is expected
-   * to return a new Immutable Iterable, allowing for custom conversions from
-   * deep JS objects.
-   *
-   * This example converts JSON to List and OrderedMap:
-   *
-   *     Immutable.fromJS({a: {b: [10, 20, 30]}, c: 40}, function (key, value) {
-   *       var isIndexed = Immutable.Iterable.isIndexed(value);
-   *       return isIndexed ? value.toList() : value.toOrderedMap();
-   *     });
-   *
-   *     // true, "b", {b: [10, 20, 30]}
-   *     // false, "a", {a: {b: [10, 20, 30]}, c: 40}
-   *     // false, "", {"": {a: {b: [10, 20, 30]}, c: 40}}
-   *
-   * If `reviver` is not provided, the default behavior will convert Arrays into
-   * Lists and Objects into Maps.
-   *
-   * `reviver` acts similarly to the [same parameter in `JSON.parse`][1].
-   *
-   * `Immutable.fromJS` is conservative in it's conversion. It will only convert
-   * arrays which pass `Array.isArray` to Lists, and only raw objects (no custom
-   * prototype) to Map.
-   *
-   * Keep in mind, when using JS objects to construct Immutable Maps, that
-   * JavaScript Object properties are always strings, even if written in a
-   * quote-less shorthand, while Immutable Maps accept keys of any type.
-   *
-   * ```js
-   * var obj = { 1: "one" };
-   * Object.keys(obj); // [ "1" ]
-   * obj["1"]; // "one"
-   * obj[1];   // "one"
-   *
-   * var map = Map(obj);
-   * map.get("1"); // "one"
-   * map.get(1);   // undefined
-   * ```
-   *
-   * Property access for JavaScript Objects first converts the key to a string,
-   * but since Immutable Map keys can be of any type the argument to `get()` is
-   * not altered.
-   *
-   * [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/parse#Example.3A_Using_the_reviver_parameter
-   *      "Using the reviver parameter"
-   */
-  export function fromJS(
-    json: any,
-    reviver?: (k: any, v: Iterable<any, any>) => any
-  ): any;
-
-
-  /**
-   * Value equality check with semantics similar to `Object.is`, but treats
-   * Immutable `Iterable`s as values, equal if the second `Iterable` includes
-   * equivalent values.
-   *
-   * It's used throughout Immutable when checking for equality, including `Map`
-   * key equality and `Set` membership.
-   *
-   *     var map1 = Immutable.Map({a:1, b:1, c:1});
-   *     var map2 = Immutable.Map({a:1, b:1, c:1});
-   *     assert(map1 !== map2);
-   *     assert(Object.is(map1, map2) === false);
-   *     assert(Immutable.is(map1, map2) === true);
-   *
-   * Note: Unlike `Object.is`, `Immutable.is` assumes `0` and `-0` are the same
-   * value, matching the behavior of ES6 Map key equality.
-   */
-  export function is(first: any, second: any): boolean;
-
-
-  /**
-   * Lists are ordered indexed dense collections, much like a JavaScript
-   * Array.
-   *
-   * Lists are immutable and fully persistent with O(log32 N) gets and sets,
-   * and O(1) push and pop.
-   *
-   * Lists implement Deque, with efficient addition and removal from both the
-   * end (`push`, `pop`) and beginning (`unshift`, `shift`).
-   *
-   * Unlike a JavaScript Array, there is no distinction between an
-   * "unset" index and an index set to `undefined`. `List#forEach` visits all
-   * indices from 0 to size, regardless of if they were explicitly defined.
-   */
-  export module List {
-
-    /**
-     * True if the provided value is a List
-     */
-    function isList(maybeList: any): boolean;
-
-    /**
-     * Creates a new List containing `values`.
-     */
-    function of<T>(...values: T[]): List<T>;
-  }
-
-  /**
-   * Create a new immutable List containing the values of the provided
-   * iterable-like.
-   */
-  export function List<T>(): List<T>;
-  export function List<T>(iter: Iterable.Indexed<T>): List<T>;
-  export function List<T>(iter: Iterable.Set<T>): List<T>;
-  export function List<K, V>(iter: Iterable.Keyed<K, V>): List</*[K,V]*/any>;
-  export function List<T>(array: Array<T>): List<T>;
-  export function List<T>(iterator: Iterator<T>): List<T>;
-  export function List<T>(iterable: /*Iterable<T>*/Object): List<T>;
-
-
-  export interface List<T> extends Collection.Indexed<T> {
-
-    // Persistent changes
-
-    /**
-     * Returns a new List which includes `value` at `index`. If `index` already
-     * exists in this List, it will be replaced.
-     *
-     * `index` may be a negative number, which indexes back from the end of the
-     * List. `v.set(-1, "value")` sets the last item in the List.
-     *
-     * If `index` larger than `size`, the returned List's `size` will be large
-     * enough to include the `index`.
-     */
-    set(index: number, value: T): List<T>;
-
-    /**
-     * Returns a new List which excludes this `index` and with a size 1 less
-     * than this List. Values at indices above `index` are shifted down by 1 to
-     * fill the position.
-     *
-     * This is synonymous with `list.splice(index, 1)`.
-     *
-     * `index` may be a negative number, which indexes back from the end of the
-     * List. `v.delete(-1)` deletes the last item in the List.
-     *
-     * Note: `delete` cannot be safely used in IE8
-     * @alias remove
-     */
-    delete(index: number): List<T>;
-    remove(index: number): List<T>;
-
-    /**
-     * Returns a new List with `value` at `index` with a size 1 more than this
-     * List. Values at indices above `index` are shifted over by 1.
-     *
-     * This is synonymous with `list.splice(index, 0, value)
-     */
-    insert(index: number, value: T): List<T>;
-
-    /**
-     * Returns a new List with 0 size and no values.
-     */
-    clear(): List<T>;
-
-    /**
-     * Returns a new List with the provided `values` appended, starting at this
-     * List's `size`.
-     */
-    push(...values: T[]): List<T>;
-
-    /**
-     * Returns a new List with a size ones less than this List, excluding
-     * the last index in this List.
-     *
-     * Note: this differs from `Array#pop` because it returns a new
-     * List rather than the removed value. Use `last()` to get the last value
-     * in this List.
-     */
-    pop(): List<T>;
-
-    /**
-     * Returns a new List with the provided `values` prepended, shifting other
-     * values ahead to higher indices.
-     */
-    unshift(...values: T[]): List<T>;
-
-    /**
-     * Returns a new List with a size ones less than this List, excluding
-     * the first index in this List, shifting all other values to a lower index.
-     *
-     * Note: this differs from `Array#shift` because it returns a new
-     * List rather than the removed value. Use `first()` to get the first
-     * value in this List.
-     */
-    shift(): List<T>;
-
-    /**
-     * Returns a new List with an updated value at `index` with the return
-     * value of calling `updater` with the existing value, or `notSetValue` if
-     * `index` was not set. If called with a single argument, `updater` is
-     * called with the List itself.
-     *
-     * `index` may be a negative number, which indexes back from the end of the
-     * List. `v.update(-1)` updates the last item in the List.
-     *
-     * @see `Map#update`
-     */
-    update(updater: (value: List<T>) => List<T>): List<T>;
-    update(index: number, updater: (value: T) => T): List<T>;
-    update(index: number, notSetValue: T, updater: (value: T) => T): List<T>;
-
-    /**
-     * @see `Map#merge`
-     */
-    merge(...iterables: Iterable.Indexed<T>[]): List<T>;
-    merge(...iterables: Array<T>[]): List<T>;
-
-    /**
-     * @see `Map#mergeWith`
-     */
-    mergeWith(
-      merger: (previous?: T, next?: T, key?: number) => T,
-      ...iterables: Iterable.Indexed<T>[]
-    ): List<T>;
-    mergeWith(
-      merger: (previous?: T, next?: T, key?: number) => T,
-      ...iterables: Array<T>[]
-    ): List<T>;
-
-    /**
-     * @see `Map#mergeDeep`
-     */
-    mergeDeep(...iterables: Iterable.Indexed<T>[]): List<T>;
-    mergeDeep(...iterables: Array<T>[]): List<T>;
-
-    /**
-     * @see `Map#mergeDeepWith`
-     */
-    mergeDeepWith(
-      merger: (previous?: T, next?: T, key?: number) => T,
-      ...iterables: Iterable.Indexed<T>[]
-    ): List<T>;
-    mergeDeepWith(
-      merger: (previous?: T, next?: T, key?: number) => T,
-      ...iterables: Array<T>[]
-    ): List<T>;
-
-    /**
-     * Returns a new List with size `size`. If `size` is less than this
-     * List's size, the new List will exclude values at the higher indices.
-     * If `size` is greater than this List's size, the new List will have
-     * undefined values for the newly available indices.
-     *
-     * When building a new List and the final size is known up front, `setSize`
-     * used in conjunction with `withMutations` may result in the more
-     * performant construction.
-     */
-    setSize(size: number): List<T>;
-
-
-    // Deep persistent changes
-
-    /**
-     * Returns a new List having set `value` at this `keyPath`. If any keys in
-     * `keyPath` do not exist, a new immutable Map will be created at that key.
-     *
-     * Index numbers are used as keys to determine the path to follow in
-     * the List.
-     */
-    setIn(keyPath: Array<any>, value: any): List<T>;
-    setIn(keyPath: Iterable<any, any>, value: any): List<T>;
-
-    /**
-     * Returns a new List having removed the value at this `keyPath`. If any
-     * keys in `keyPath` do not exist, no change will occur.
-     *
-     * @alias removeIn
-     */
-    deleteIn(keyPath: Array<any>): List<T>;
-    deleteIn(keyPath: Iterable<any, any>): List<T>;
-    removeIn(keyPath: Array<any>): List<T>;
-    removeIn(keyPath: Iterable<any, any>): List<T>;
-
-    /**
-     * @see `Map#updateIn`
-     */
-    updateIn(
-      keyPath: Array<any>,
-      updater: (value: any) => any
-    ): List<T>;
-    updateIn(
-      keyPath: Array<any>,
-      notSetValue: any,
-      updater: (value: any) => any
-    ): List<T>;
-    updateIn(
-      keyPath: Iterable<any, any>,
-      updater: (value: any) => any
-    ): List<T>;
-    updateIn(
-      keyPath: Iterable<any, any>,
-      notSetValue: any,
-      updater: (value: any) => any
-    ): List<T>;
-
-    /**
-     * @see `Map#mergeIn`
-     */
-    mergeIn(
-      keyPath: Iterable<any, any>,
-      ...iterables: Iterable.Indexed<T>[]
-    ): List<T>;
-    mergeIn(
-      keyPath: Array<any>,
-      ...iterables: Iterable.Indexed<T>[]
-    ): List<T>;
-    mergeIn(
-      keyPath: Array<any>,
-      ...iterables: Array<T>[]
-    ): List<T>;
-
-    /**
-     * @see `Map#mergeDeepIn`
-     */
-    mergeDeepIn(
-      keyPath: Iterable<any, any>,
-      ...iterables: Iterable.Indexed<T>[]
-    ): List<T>;
-    mergeDeepIn(
-      keyPath: Array<any>,
-      ...iterables: Iterable.Indexed<T>[]
-    ): List<T>;
-    mergeDeepIn(
-      keyPath: Array<any>,
-      ...iterables: Array<T>[]
-    ): List<T>;
-
-
-    // Transient changes
-
-    /**
-     * Note: Not all methods can be used on a mutable collection or within
-     * `withMutations`! Only `set`, `push`, `pop`, `shift`, `unshift` and
-     * `merge` may be used mutatively.
-     *
-     * @see `Map#withMutations`
-     */
-    withMutations(mutator: (mutable: List<T>) => any): List<T>;
-
-    /**
-     * @see `Map#asMutable`
-     */
-    asMutable(): List<T>;
-
-    /**
-     * @see `Map#asImmutable`
-     */
-    asImmutable(): List<T>;
-  }
-
-
-  /**
-   * Immutable Map is an unordered Iterable.Keyed of (key, value) pairs with
-   * `O(log32 N)` gets and `O(log32 N)` persistent sets.
-   *
-   * Iteration order of a Map is undefined, however is stable. Multiple
-   * iterations of the same Map will iterate in the same order.
-   *
-   * Map's keys can be of any type, and use `Immutable.is` to determine key
-   * equality. This allows the use of any value (including NaN) as a key.
-   *
-   * Because `Immutable.is` returns equality based on value semantics, and
-   * Immutable collections are treated as values, any Immutable collection may
-   * be used as a key.
-   *
-   *     Map().set(List.of(1), 'listofone').get(List.of(1));
-   *     // 'listofone'
-   *
-   * Any JavaScript object may be used as a key, however strict identity is used
-   * to evaluate key equality. Two similar looking objects will represent two
-   * different keys.
-   *
-   * Implemented by a hash-array mapped trie.
-   */
-  export module Map {
-
-    /**
-     * True if the provided value is a Map
-     */
-    function isMap(maybeMap: any): boolean;
-  }
-
-  /**
-   * Creates a new Immutable Map.
-   *
-   * Created with the same key value pairs as the provided Iterable.Keyed or
-   * JavaScript Object or expects an Iterable of [K, V] tuple entries.
-   *
-   *     var newMap = Map({key: "value"});
-   *     var newMap = Map([["key", "value"]]);
-   *
-   * Keep in mind, when using JS objects to construct Immutable Maps, that
-   * JavaScript Object properties are always strings, even if written in a
-   * quote-less shorthand, while Immutable Maps accept keys of any type.
-   *
-   * ```js
-   * var obj = { 1: "one" };
-   * Object.keys(obj); // [ "1" ]
-   * obj["1"]; // "one"
-   * obj[1];   // "one"
-   *
-   * var map = Map(obj);
-   * map.get("1"); // "one"
-   * map.get(1);   // undefined
-   * ```
-   *
-   * Property access for JavaScript Objects first converts the key to a string,
-   * but since Immutable Map keys can be of any type the argument to `get()` is
-   * not altered.
-   */
-  export function Map<K, V>(): Map<K, V>;
-  export function Map<K, V>(iter: Iterable.Keyed<K, V>): Map<K, V>;
-  export function Map<K, V>(iter: Iterable<any, /*[K,V]*/Array<any>>): Map<K, V>;
-  export function Map<K, V>(array: Array</*[K,V]*/Array<any>>): Map<K, V>;
-  export function Map<V>(obj: {[key: string]: V}): Map<string, V>;
-  export function Map<K, V>(iterator: Iterator</*[K,V]*/Array<any>>): Map<K, V>;
-  export function Map<K, V>(iterable: /*Iterable<[K,V]>*/Object): Map<K, V>;
-
-  export interface Map<K, V> extends Collection.Keyed<K, V> {
-
-    // Persistent changes
-
-    /**
-     * Returns a new Map also containing the new key, value pair. If an equivalent
-     * key already exists in this Map, it will be replaced.
-     */
-    set(key: K, value: V): Map<K, V>;
-
-    /**
-     * Returns a new Map which excludes this `key`.
-     *
-     * Note: `delete` cannot be safely used in IE8, but is provided to mirror
-     * the ES6 collection API.
-     * @alias remove
-     */
-    delete(key: K): Map<K, V>;
-    remove(key: K): Map<K, V>;
-
-    /**
-     * Returns a new Map containing no keys or values.
-     */
-    clear(): Map<K, V>;
-
-    /**
-     * Returns a new Map having updated the value at this `key` with the return
-     * value of calling `updater` with the existing value, or `notSetValue` if
-     * the key was not set. If called with only a single argument, `updater` is
-     * called with the Map itself.
-     *
-     * Equivalent to: `map.set(key, updater(map.get(key, notSetValue)))`.
-     */
-    update(updater: (value: Map<K, V>) => Map<K, V>): Map<K, V>;
-    update(key: K, updater: (value: V) => V): Map<K, V>;
-    update(key: K, notSetValue: V, updater: (value: V) => V): Map<K, V>;
-
-    /**
-     * Returns a new Map resulting from merging the provided Iterables
-     * (or JS objects) into this Map. In other words, this takes each entry of
-     * each iterable and sets it on this Map.
-     *
-     * If any of the values provided to `merge` are not Iterable (would return
-     * false for `Immutable.Iterable.isIterable`) then they are deeply converted
-     * via `Immutable.fromJS` before being merged. However, if the value is an
-     * Iterable but includes non-iterable JS objects or arrays, those nested
-     * values will be preserved.
-     *
-     *     var x = Immutable.Map({a: 10, b: 20, c: 30});
-     *     var y = Immutable.Map({b: 40, a: 50, d: 60});
-     *     x.merge(y) // { a: 50, b: 40, c: 30, d: 60 }
-     *     y.merge(x) // { b: 20, a: 10, d: 60, c: 30 }
-     *
-     */
-    merge(...iterables: Iterable<K, V>[]): Map<K, V>;
-    merge(...iterables: {[key: string]: V}[]): Map<string, V>;
-
-    /**
-     * Like `merge()`, `mergeWith()` returns a new Map resulting from merging
-     * the provided Iterables (or JS objects) into this Map, but uses the
-     * `merger` function for dealing with conflicts.
-     *
-     *     var x = Immutable.Map({a: 10, b: 20, c: 30});
-     *     var y = Immutable.Map({b: 40, a: 50, d: 60});
-     *     x.mergeWith((prev, next) => prev / next, y) // { a: 0.2, b: 0.5, c: 30, d: 60 }
-     *     y.mergeWith((prev, next) => prev / next, x) // { b: 2, a: 5, d: 60, c: 30 }
-     *
-     */
-    mergeWith(
-      merger: (previous?: V, next?: V, key?: K) => V,
-      ...iterables: Iterable<K, V>[]
-    ): Map<K, V>;
-    mergeWith(
-      merger: (previous?: V, next?: V, key?: K) => V,
-      ...iterables: {[key: string]: V}[]
-    ): Map<string, V>;
-
-    /**
-     * Like `merge()`, but when two Iterables conflict, it merges them as well,
-     * recursing deeply through the nested data.
-     *
-     *     var x = Immutable.fromJS({a: { x: 10, y: 10 }, b: { x: 20, y: 50 } });
-     *     var y = Immutable.fromJS({a: { x: 2 }, b: { y: 5 }, c: { z: 3 } });
-     *     x.mergeDeep(y) // {a: { x: 2, y: 10 }, b: { x: 20, y: 5 }, c: { z: 3 } }
-     *
-     */
-    mergeDeep(...iterables: Iterable<K, V>[]): Map<K, V>;
-    mergeDeep(...iterables: {[key: string]: V}[]): Map<string, V>;
-
-    /**
-     * Like `mergeDeep()`, but when two non-Iterables conflict, it uses the
-     * `merger` function to determine the resulting value.
-     *
-     *     var x = Immutable.fromJS({a: { x: 10, y: 10 }, b: { x: 20, y: 50 } });
-     *     var y = Immutable.fromJS({a: { x: 2 }, b: { y: 5 }, c: { z: 3 } });
-     *     x.mergeDeepWith((prev, next) => prev / next, y)
-     *     // {a: { x: 5, y: 10 }, b: { x: 20, y: 10 }, c: { z: 3 } }
-     *
-     */
-    mergeDeepWith(
-      merger: (previous?: V, next?: V, key?: K) => V,
-      ...iterables: Iterable<K, V>[]
-    ): Map<K, V>;
-    mergeDeepWith(
-      merger: (previous?: V, next?: V, key?: K) => V,
-      ...iterables: {[key: string]: V}[]
-    ): Map<string, V>;
-
-
-    // Deep persistent changes
-
-    /**
-     * Returns a new Map having set `value` at this `keyPath`. If any keys in
-     * `keyPath` do not exist, a new immutable Map will be created at that key.
-     */
-    setIn(keyPath: Array<any>, value: any): Map<K, V>;
-    setIn(KeyPath: Iterable<any, any>, value: any): Map<K, V>;
-
-    /**
-     * Returns a new Map having removed the value at this `keyPath`. If any keys
-     * in `keyPath` do not exist, no change will occur.
-     *
-     * @alias removeIn
-     */
-    deleteIn(keyPath: Array<any>): Map<K, V>;
-    deleteIn(keyPath: Iterable<any, any>): Map<K, V>;
-    removeIn(keyPath: Array<any>): Map<K, V>;
-    removeIn(keyPath: Iterable<any, any>): Map<K, V>;
-
-    /**
-     * Returns a new Map having applied the `updater` to the entry found at the
-     * keyPath.
-     *
-     * If any keys in `keyPath` do not exist, new Immutable `Map`s will
-     * be created at those keys. If the `keyPath` does not already contain a
-     * value, the `updater` function will be called with `notSetValue`, if
-     * provided, otherwise `undefined`.
-     *
-     *     var data = Immutable.fromJS({ a: { b: { c: 10 } } });
-     *     data = data.updateIn(['a', 'b', 'c'], val => val * 2);
-     *     // { a: { b: { c: 20 } } }
-     *
-     * If the `updater` function returns the same value it was called with, then
-     * no change will occur. This is still true if `notSetValue` is provided.
-     *
-     *     var data1 = Immutable.fromJS({ a: { b: { c: 10 } } });
-     *     data2 = data1.updateIn(['x', 'y', 'z'], 100, val => val);
-     *     assert(data2 === data1);
-     *
-     */
-    updateIn(
-      keyPath: Array<any>,
-      updater: (value: any) => any
-    ): Map<K, V>;
-    updateIn(
-      keyPath: Array<any>,
-      notSetValue: any,
-      updater: (value: any) => any
-    ): Map<K, V>;
-    updateIn(
-      keyPath: Iterable<any, any>,
-      updater: (value: any) => any
-    ): Map<K, V>;
-    updateIn(
-      keyPath: Iterable<any, any>,
-      notSetValue: any,
-      updater: (value: any) => any
-    ): Map<K, V>;
-
-    /**
-     * A combination of `updateIn` and `merge`, returning a new Map, but
-     * performing the merge at a point arrived at by following the keyPath.
-     * In other words, these two lines are equivalent:
-     *
-     *     x.updateIn(['a', 'b', 'c'], abc => abc.merge(y));
-     *     x.mergeIn(['a', 'b', 'c'], y);
-     *
-     */
-    mergeIn(
-      keyPath: Iterable<any, any>,
-      ...iterables: Iterable<K, V>[]
-    ): Map<K, V>;
-    mergeIn(
-      keyPath: Array<any>,
-      ...iterables: Iterable<K, V>[]
-    ): Map<K, V>;
-    mergeIn(
-      keyPath: Array<any>,
-      ...iterables: {[key: string]: V}[]
-    ): Map<string, V>;
-
-    /**
-     * A combination of `updateIn` and `mergeDeep`, returning a new Map, but
-     * performing the deep merge at a point arrived at by following the keyPath.
-     * In other words, these two lines are equivalent:
-     *
-     *     x.updateIn(['a', 'b', 'c'], abc => abc.mergeDeep(y));
-     *     x.mergeDeepIn(['a', 'b', 'c'], y);
-     *
-     */
-    mergeDeepIn(
-      keyPath: Iterable<any, any>,
-      ...iterables: Iterable<K, V>[]
-    ): Map<K, V>;
-    mergeDeepIn(
-      keyPath: Array<any>,
-      ...iterables: Iterable<K, V>[]
-    ): Map<K, V>;
-    mergeDeepIn(
-      keyPath: Array<any>,
-      ...iterables: {[key: string]: V}[]
-    ): Map<string, V>;
-
-
-    // Transient changes
-
-    /**
-     * Every time you call one of the above functions, a new immutable Map is
-     * created. If a pure function calls a number of these to produce a final
-     * return value, then a penalty on performance and memory has been paid by
-     * creating all of the intermediate immutable Maps.
-     *
-     * If you need to apply a series of mutations to produce a new immutable
-     * Map, `withMutations()` creates a temporary mutable copy of the Map which
-     * can apply mutations in a highly performant manner. In fact, this is
-     * exactly how complex mutations like `merge` are done.
-     *
-     * As an example, this results in the creation of 2, not 4, new Maps:
-     *
-     *     var map1 = Immutable.Map();
-     *     var map2 = map1.withMutations(map => {
-     *       map.set('a', 1).set('b', 2).set('c', 3);
-     *     });
-     *     assert(map1.size === 0);
-     *     assert(map2.size === 3);
-     *
-     * Note: Not all methods can be used on a mutable collection or within
-     * `withMutations`! Only `set` and `merge` may be used mutatively.
-     *
-     */
-    withMutations(mutator: (mutable: Map<K, V>) => any): Map<K, V>;
-
-    /**
-     * Another way to avoid creation of intermediate Immutable maps is to create
-     * a mutable copy of this collection. Mutable copies *always* return `this`,
-     * and thus shouldn't be used for equality. Your function should never return
-     * a mutable copy of a collection, only use it internally to create a new
-     * collection. If possible, use `withMutations` as it provides an easier to
-     * use API.
-     *
-     * Note: if the collection is already mutable, `asMutable` returns itself.
-     *
-     * Note: Not all methods can be used on a mutable collection or within
-     * `withMutations`! Only `set` and `merge` may be used mutatively.
-     */
-    asMutable(): Map<K, V>;
-
-    /**
-     * The yin to `asMutable`'s yang. Because it applies to mutable collections,
-     * this operation is *mutable* and returns itself. Once performed, the mutable
-     * copy has become immutable and can be safely returned from a function.
-     */
-    asImmutable(): Map<K, V>;
-  }
-
-
-  /**
-   * A type of Map that has the additional guarantee that the iteration order of
-   * entries will be the order in which they were set().
-   *
-   * The iteration behavior of OrderedMap is the same as native ES6 Map and
-   * JavaScript Object.
-   *
-   * Note that `OrderedMap` are more expensive than non-ordered `Map` and may
-   * consume more memory. `OrderedMap#set` is amortized O(log32 N), but not
-   * stable.
-   */
-
-  export module OrderedMap {
-
-    /**
-     * True if the provided value is an OrderedMap.
-     */
-    function isOrderedMap(maybeOrderedMap: any): boolean;
-  }
-
-  /**
-   * Creates a new Immutable OrderedMap.
-   *
-   * Created with the same key value pairs as the provided Iterable.Keyed or
-   * JavaScript Object or expects an Iterable of [K, V] tuple entries.
-   *
-   * The iteration order of key-value pairs provided to this constructor will
-   * be preserved in the OrderedMap.
-   *
-   *     var newOrderedMap = OrderedMap({key: "value"});
-   *     var newOrderedMap = OrderedMap([["key", "value"]]);
-   *
-   */
-  export function OrderedMap<K, V>(): OrderedMap<K, V>;
-  export function OrderedMap<K, V>(iter: Iterable.Keyed<K, V>): OrderedMap<K, V>;
-  export function OrderedMap<K, V>(iter: Iterable<any, /*[K,V]*/Array<any>>): OrderedMap<K, V>;
-  export function OrderedMap<K, V>(array: Array</*[K,V]*/Array<any>>): OrderedMap<K, V>;
-  export function OrderedMap<V>(obj: {[key: string]: V}): OrderedMap<string, V>;
-  export function OrderedMap<K, V>(iterator: Iterator</*[K,V]*/Array<any>>): OrderedMap<K, V>;
-  export function OrderedMap<K, V>(iterable: /*Iterable<[K,V]>*/Object): OrderedMap<K, V>;
-
-  export interface OrderedMap<K, V> extends Map<K, V> {}
-
-
-  /**
-   * A Collection of unique values with `O(log32 N)` adds and has.
-   *
-   * When iterating a Set, the entries will be (value, value) pairs. Iteration
-   * order of a Set is undefined, however is stable. Multiple iterations of the
-   * same Set will iterate in the same order.
-   *
-   * Set values, like Map keys, may be of any type. Equality is determined using
-   * `Immutable.is`, enabling Sets to uniquely include other Immutable
-   * collections, custom value types, and NaN.
-   */
-  export module Set {
-
-    /**
-     * True if the provided value is a Set
-     */
-    function isSet(maybeSet: any): boolean;
-
-    /**
-     * Creates a new Set containing `values`.
-     */
-    function of<T>(...values: T[]): Set<T>;
-
-    /**
-     * `Set.fromKeys()` creates a new immutable Set containing the keys from
-     * this Iterable or JavaScript Object.
-     */
-    function fromKeys<T>(iter: Iterable<T, any>): Set<T>;
-    function fromKeys(obj: {[key: string]: any}): Set<string>;
-  }
-
-  /**
-   * Create a new immutable Set containing the values of the provided
-   * iterable-like.
-   */
-  export function Set<T>(): Set<T>;
-  export function Set<T>(iter: Iterable.Set<T>): Set<T>;
-  export function Set<T>(iter: Iterable.Indexed<T>): Set<T>;
-  export function Set<K, V>(iter: Iterable.Keyed<K, V>): Set</*[K,V]*/any>;
-  export function Set<T>(array: Array<T>): Set<T>;
-  export function Set<T>(iterator: Iterator<T>): Set<T>;
-  export function Set<T>(iterable: /*Iterable<T>*/Object): Set<T>;
-
-  export interface Set<T> extends Collection.Set<T> {
-
-    // Persistent changes
-
-    /**
-     * Returns a new Set which also includes this value.
-     */
-    add(value: T): Set<T>;
-
-    /**
-     * Returns a new Set which excludes this value.
-     *
-     * Note: `delete` cannot be safely used in IE8
-     * @alias remove
-     */
-    delete(value: T): Set<T>;
-    remove(value: T): Set<T>;
-
-    /**
-     * Returns a new Set containing no values.
-     */
-    clear(): Set<T>;
-
-    /**
-     * Returns a Set including any value from `iterables` that does not already
-     * exist in this Set.
-     * @alias merge
-     */
-    union(...iterables: Iterable<any, T>[]): Set<T>;
-    union(...iterables: Array<T>[]): Set<T>;
-    merge(...iterables: Iterable<any, T>[]): Set<T>;
-    merge(...iterables: Array<T>[]): Set<T>;
-
-
-    /**
-     * Returns a Set which has removed any values not also contained
-     * within `iterables`.
-     */
-    intersect(...iterables: Iterable<any, T>[]): Set<T>;
-    intersect(...iterables: Array<T>[]): Set<T>;
-
-    /**
-     * Returns a Set excluding any values contained within `iterables`.
-     */
-    subtract(...iterables: Iterable<any, T>[]): Set<T>;
-    subtract(...iterables: Array<T>[]): Set<T>;
-
-
-    // Transient changes
-
-    /**
-     * Note: Not all methods can be used on a mutable collection or within
-     * `withMutations`! Only `add` may be used mutatively.
-     *
-     * @see `Map#withMutations`
-     */
-    withMutations(mutator: (mutable: Set<T>) => any): Set<T>;
-
-    /**
-     * @see `Map#asMutable`
-     */
-    asMutable(): Set<T>;
-
-    /**
-     * @see `Map#asImmutable`
-     */
-    asImmutable(): Set<T>;
-  }
-
-
-  /**
-   * A type of Set that has the additional guarantee that the iteration order of
-   * values will be the order in which they were `add`ed.
-   *
-   * The iteration behavior of OrderedSet is the same as native ES6 Set.
-   *
-   * Note that `OrderedSet` are more expensive than non-ordered `Set` and may
-   * consume more memory. `OrderedSet#add` is amortized O(log32 N), but not
-   * stable.
-   */
-  export module OrderedSet {
-
-    /**
-     * True if the provided value is an OrderedSet.
-     */
-    function isOrderedSet(maybeOrderedSet: any): boolean;
-
-    /**
-     * Creates a new OrderedSet containing `values`.
-     */
-    function of<T>(...values: T[]): OrderedSet<T>;
-
-    /**
-     * `OrderedSet.fromKeys()` creates a new immutable OrderedSet containing
-     * the keys from this Iterable or JavaScript Object.
-     */
-    function fromKeys<T>(iter: Iterable<T, any>): OrderedSet<T>;
-    function fromKeys(obj: {[key: string]: any}): OrderedSet<string>;
-  }
-
-  /**
-   * Create a new immutable OrderedSet containing the values of the provided
-   * iterable-like.
-   */
-  export function OrderedSet<T>(): OrderedSet<T>;
-  export function OrderedSet<T>(iter: Iterable.Set<T>): OrderedSet<T>;
-  export function OrderedSet<T>(iter: Iterable.Indexed<T>): OrderedSet<T>;
-  export function OrderedSet<K, V>(iter: Iterable.Keyed<K, V>): OrderedSet</*[K,V]*/any>;
-  export function OrderedSet<T>(array: Array<T>): OrderedSet<T>;
-  export function OrderedSet<T>(iterator: Iterator<T>): OrderedSet<T>;
-  export function OrderedSet<T>(iterable: /*Iterable<T>*/Object): OrderedSet<T>;
-
-  export interface OrderedSet<T> extends Set<T> {}
-
-
-  /**
-   * Stacks are indexed collections which support very efficient O(1) addition
-   * and removal from the front using `unshift(v)` and `shift()`.
-   *
-   * For familiarity, Stack also provides `push(v)`, `pop()`, and `peek()`, but
-   * be aware that they also operate on the front of the list, unlike List or
-   * a JavaScript Array.
-   *
-   * Note: `reverse()` or any inherent reverse traversal (`reduceRight`,
-   * `lastIndexOf`, etc.) is not efficient with a Stack.
-   *
-   * Stack is implemented with a Single-Linked List.
-   */
-  export module Stack {
-
-    /**
-     * True if the provided value is a Stack
-     */
-    function isStack(maybeStack: any): boolean;
-
-    /**
-     * Creates a new Stack containing `values`.
-     */
-    function of<T>(...values: T[]): Stack<T>;
-  }
-
-  /**
-   * Create a new immutable Stack containing the values of the provided
-   * iterable-like.
-   *
-   * The iteration order of the provided iterable is preserved in the
-   * resulting `Stack`.
-   */
-  export function Stack<T>(): Stack<T>;
-  export function Stack<T>(iter: Iterable.Indexed<T>): Stack<T>;
-  export function Stack<T>(iter: Iterable.Set<T>): Stack<T>;
-  export function Stack<K, V>(iter: Iterable.Keyed<K, V>): Stack</*[K,V]*/any>;
-  export function Stack<T>(array: Array<T>): Stack<T>;
-  export function Stack<T>(iterator: Iterator<T>): Stack<T>;
-  export function Stack<T>(iterable: /*Iterable<T>*/Object): Stack<T>;
-
-  export interface Stack<T> extends Collection.Indexed<T> {
-
-    // Reading values
-
-    /**
-     * Alias for `Stack.first()`.
-     */
-    peek(): T;
-
-
-    // Persistent changes
-
-    /**
-     * Returns a new Stack with 0 size and no values.
-     */
-    clear(): Stack<T>;
-
-    /**
-     * Returns a new Stack with the provided `values` prepended, shifting other
-     * values ahead to higher indices.
-     *
-     * This is very efficient for Stack.
-     */
-    unshift(...values: T[]): Stack<T>;
-
-    /**
-     * Like `Stack#unshift`, but accepts a iterable rather than varargs.
-     */
-    unshiftAll(iter: Iterable<any, T>): Stack<T>;
-    unshiftAll(iter: Array<T>): Stack<T>;
-
-    /**
-     * Returns a new Stack with a size ones less than this Stack, excluding
-     * the first item in this Stack, shifting all other values to a lower index.
-     *
-     * Note: this differs from `Array#shift` because it returns a new
-     * Stack rather than the removed value. Use `first()` or `peek()` to get the
-     * first value in this Stack.
-     */
-    shift(): Stack<T>;
-
-    /**
-     * Alias for `Stack#unshift` and is not equivalent to `List#push`.
-     */
-    push(...values: T[]): Stack<T>;
-
-    /**
-     * Alias for `Stack#unshiftAll`.
-     */
-    pushAll(iter: Iterable<any, T>): Stack<T>;
-    pushAll(iter: Array<T>): Stack<T>;
-
-    /**
-     * Alias for `Stack#shift` and is not equivalent to `List#pop`.
-     */
-    pop(): Stack<T>;
-
-
-    // Transient changes
-
-    /**
-     * Note: Not all methods can be used on a mutable collection or within
-     * `withMutations`! Only `set`, `push`, and `pop` may be used mutatively.
-     *
-     * @see `Map#withMutations`
-     */
-    withMutations(mutator: (mutable: Stack<T>) => any): Stack<T>;
-
-    /**
-     * @see `Map#asMutable`
-     */
-    asMutable(): Stack<T>;
-
-    /**
-     * @see `Map#asImmutable`
-     */
-    asImmutable(): Stack<T>;
-  }
-
-
-  /**
-   * Returns a Seq.Indexed of numbers from `start` (inclusive) to `end`
-   * (exclusive), by `step`, where `start` defaults to 0, `step` to 1, and `end` to
-   * infinity. When `start` is equal to `end`, returns empty range.
-   *
-   *     Range() // [0,1,2,3,...]
-   *     Range(10) // [10,11,12,13,...]
-   *     Range(10,15) // [10,11,12,13,14]
-   *     Range(10,30,5) // [10,15,20,25]
-   *     Range(30,10,5) // [30,25,20,15]
-   *     Range(30,30,5) // []
-   *
-   */
-  export function Range(start?: number, end?: number, step?: number): Seq.Indexed<number>;
-
-
-  /**
-   * Returns a Seq.Indexed of `value` repeated `times` times. When `times` is
-   * not defined, returns an infinite `Seq` of `value`.
-   *
-   *     Repeat('foo') // ['foo','foo','foo',...]
-   *     Repeat('bar',4) // ['bar','bar','bar','bar']
-   *
-   */
-  export function Repeat<T>(value: T, times?: number): Seq.Indexed<T>;
-
-
-  /**
-   * Creates a new Class which produces Record instances. A record is similar to
-   * a JS object, but enforce a specific set of allowed string keys, and have
-   * default values.
-   *
-   *     var ABRecord = Record({a:1, b:2})
-   *     var myRecord = new ABRecord({b:3})
-   *
-   * Records always have a value for the keys they define. `remove`ing a key
-   * from a record simply resets it to the default value for that key.
-   *
-   *     myRecord.size // 2
-   *     myRecord.get('a') // 1
-   *     myRecord.get('b') // 3
-   *     myRecordWithoutB = myRecord.remove('b')
-   *     myRecordWithoutB.get('b') // 2
-   *     myRecordWithoutB.size // 2
-   *
-   * Values provided to the constructor not found in the Record type will
-   * be ignored. For example, in this case, ABRecord is provided a key "x" even
-   * though only "a" and "b" have been defined. The value for "x" will be
-   * ignored for this record.
-   *
-   *     var myRecord = new ABRecord({b:3, x:10})
-   *     myRecord.get('x') // undefined
-   *
-   * Because Records have a known set of string keys, property get access works
-   * as expected, however property sets will throw an Error.
-   *
-   * Note: IE8 does not support property access. Only use `get()` when
-   * supporting IE8.
-   *
-   *     myRecord.b // 3
-   *     myRecord.b = 5 // throws Error
-   *
-   * Record Classes can be extended as well, allowing for custom methods on your
-   * Record. This is not a common pattern in functional environments, but is in
-   * many JS programs.
-   *
-   * Note: TypeScript does not support this type of subclassing.
-   *
-   *     class ABRecord extends Record({a:1,b:2}) {
-   *       getAB() {
-   *         return this.a + this.b;
-   *       }
-   *     }
-   *
-   *     var myRecord = new ABRecord({b: 3})
-   *     myRecord.getAB() // 4
-   *
-   */
-  export module Record {
-    interface Class {
-      new (): Map<string, any>;
-      new (values: {[key: string]: any}): Map<string, any>;
-      new (values: Iterable<string, any>): Map<string, any>; // deprecated
-
-      (): Map<string, any>;
-      (values: {[key: string]: any}): Map<string, any>;
-      (values: Iterable<string, any>): Map<string, any>; // deprecated
-    }
-  }
-
-  export function Record(
-    defaultValues: {[key: string]: any}, name?: string
-  ): Record.Class;
-
-
-  /**
-   * Represents a sequence of values, but may not be backed by a concrete data
-   * structure.
-   *
-   * **Seq is immutable** — Once a Seq is created, it cannot be
-   * changed, appended to, rearranged or otherwise modified. Instead, any
-   * mutative method called on a `Seq` will return a new `Seq`.
-   *
-   * **Seq is lazy** — Seq does as little work as necessary to respond to any
-   * method call. Values are often created during iteration, including implicit
-   * iteration when reducing or converting to a concrete data structure such as
-   * a `List` or JavaScript `Array`.
-   *
-   * For example, the following performs no work, because the resulting
-   * Seq's values are never iterated:
-   *
-   *     var oddSquares = Immutable.Seq.of(1,2,3,4,5,6,7,8)
-   *       .filter(x => x % 2).map(x => x * x);
-   *
-   * Once the Seq is used, it performs only the work necessary. In this
-   * example, no intermediate data structures are ever created, filter is only
-   * called three times, and map is only called once:
-   *
-   *     console.log(evenSquares.get(1)); // 9
-   *
-   * Seq allows for the efficient chaining of operations,
-   * allowing for the expression of logic that can otherwise be very tedious:
-   *
-   *     Immutable.Seq({a:1, b:1, c:1})
-   *       .flip().map(key => key.toUpperCase()).flip().toObject();
-   *     // Map { A: 1, B: 1, C: 1 }
-   *
-   * As well as expressing logic that would otherwise be memory or time limited:
-   *
-   *     Immutable.Range(1, Infinity)
-   *       .skip(1000)
-   *       .map(n => -n)
-   *       .filter(n => n % 2 === 0)
-   *       .take(2)
-   *       .reduce((r, n) => r * n, 1);
-   *     // 1006008
-   *
-   * Seq is often used to provide a rich collection API to JavaScript Object.
-   *
-   *     Immutable.Seq({ x: 0, y: 1, z: 2 }).map(v => v * 2).toObject();
-   *     // { x: 0, y: 2, z: 4 }
-   */
-
-  export module Seq {
-    /**
-     * True if `maybeSeq` is a Seq, it is not backed by a concrete
-     * structure such as Map, List, or Set.
-     */
-    function isSeq(maybeSeq: any): boolean;
-
-    /**
-     * Returns a Seq of the values provided. Alias for `Seq.Indexed.of()`.
-     */
-    function of<T>(...values: T[]): Seq.Indexed<T>;
-
-
-    /**
-     * `Seq` which represents key-value pairs.
-     */
-    export module Keyed {}
-
-    /**
-     * Always returns a Seq.Keyed, if input is not keyed, expects an
-     * iterable of [K, V] tuples.
-     */
-    export function Keyed<K, V>(): Seq.Keyed<K, V>;
-    export function Keyed<K, V>(seq: Iterable.Keyed<K, V>): Seq.Keyed<K, V>;
-    export function Keyed<K, V>(seq: Iterable<any, /*[K,V]*/any>): Seq.Keyed<K, V>;
-    export function Keyed<K, V>(array: Array</*[K,V]*/any>): Seq.Keyed<K, V>;
-    export function Keyed<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>;
-    export function Keyed<K, V>(iterator: Iterator</*[K,V]*/any>): Seq.Keyed<K, V>;
-    export function Keyed<K, V>(iterable: /*Iterable<[K,V]>*/Object): Seq.Keyed<K, V>;
-
-    export interface Keyed<K, V> extends Seq<K, V>, Iterable.Keyed<K, V> {
-
-      /**
-       * Returns itself
-       */
-      toSeq(): /*this*/Seq.Keyed<K, V>
-    }
-
-
-    /**
-     * `Seq` which represents an ordered indexed list of values.
-     */
-    module Indexed {
-
-      /**
-       * Provides an Seq.Indexed of the values provided.
-       */
-      function of<T>(...values: T[]): Seq.Indexed<T>;
-    }
-
-    /**
-     * Always returns Seq.Indexed, discarding associated keys and
-     * supplying incrementing indices.
-     */
-    export function Indexed<T>(): Seq.Indexed<T>;
-    export function Indexed<T>(seq: Iterable.Indexed<T>): Seq.Indexed<T>;
-    export function Indexed<T>(seq: Iterable.Set<T>): Seq.Indexed<T>;
-    export function Indexed<K, V>(seq: Iterable.Keyed<K, V>): Seq.Indexed</*[K,V]*/any>;
-    export function Indexed<T>(array: Array<T>): Seq.Indexed<T>;
-    export function Indexed<T>(iterator: Iterator<T>): Seq.Indexed<T>;
-    export function Indexed<T>(iterable: /*Iterable<T>*/Object): Seq.Indexed<T>;
-
-    export interface Indexed<T> extends Seq<number, T>, Iterable.Indexed<T> {
-
-      /**
-       * Returns itself
-       */
-      toSeq(): /*this*/Seq.Indexed<T>
-    }
-
-
-    /**
-     * `Seq` which represents a set of values.
-     *
-     * Because `Seq` are often lazy, `Seq.Set` does not provide the same guarantee
-     * of value uniqueness as the concrete `Set`.
-     */
-    export module Set {
-
-      /**
-       * Returns a Seq.Set of the provided values
-       */
-      function of<T>(...values: T[]): Seq.Set<T>;
-    }
-
-    /**
-     * Always returns a Seq.Set, discarding associated indices or keys.
-     */
-    export function Set<T>(): Seq.Set<T>;
-    export function Set<T>(seq: Iterable.Set<T>): Seq.Set<T>;
-    export function Set<T>(seq: Iterable.Indexed<T>): Seq.Set<T>;
-    export function Set<K, V>(seq: Iterable.Keyed<K, V>): Seq.Set</*[K,V]*/any>;
-    export function Set<T>(array: Array<T>): Seq.Set<T>;
-    export function Set<T>(iterator: Iterator<T>): Seq.Set<T>;
-    export function Set<T>(iterable: /*Iterable<T>*/Object): Seq.Set<T>;
-
-    export interface Set<T> extends Seq<T, T>, Iterable.Set<T> {
-
-      /**
-       * Returns itself
-       */
-      toSeq(): /*this*/Seq.Set<T>
-    }
-
-  }
-
-  /**
-   * Creates a Seq.
-   *
-   * Returns a particular kind of `Seq` based on the input.
-   *
-   *   * If a `Seq`, that same `Seq`.
-   *   * If an `Iterable`, a `Seq` of the same kind (Keyed, Indexed, or Set).
-   *   * If an Array-like, an `Seq.Indexed`.
-   *   * If an Object with an Iterator, an `Seq.Indexed`.
-   *   * If an Iterator, an `Seq.Indexed`.
-   *   * If an Object, a `Seq.Keyed`.
-   *
-   */
-  export function Seq<K, V>(): Seq<K, V>;
-  export function Seq<K, V>(seq: Seq<K, V>): Seq<K, V>;
-  export function Seq<K, V>(iterable: Iterable<K, V>): Seq<K, V>;
-  export function Seq<T>(array: Array<T>): Seq.Indexed<T>;
-  export function Seq<V>(obj: {[key: string]: V}): Seq.Keyed<string, V>;
-  export function Seq<T>(iterator: Iterator<T>): Seq.Indexed<T>;
-  export function Seq<T>(iterable: /*ES6Iterable<T>*/Object): Seq.Indexed<T>;
-
-  export interface Seq<K, V> extends Iterable<K, V> {
-
-    /**
-     * Some Seqs can describe their size lazily. When this is the case,
-     * size will be an integer. Otherwise it will be undefined.
-     *
-     * For example, Seqs returned from `map()` or `reverse()`
-     * preserve the size of the original `Seq` while `filter()` does not.
-     *
-     * Note: `Range`, `Repeat` and `Seq`s made from `Array`s and `Object`s will
-     * always have a size.
-     */
-    size: number/*?*/;
-
-
-    // Force evaluation
-
-    /**
-     * Because Sequences are lazy and designed to be chained together, they do
-     * not cache their results. For example, this map function is called a total
-     * of 6 times, as each `join` iterates the Seq of three values.
-     *
-     *     var squares = Seq.of(1,2,3).map(x => x * x);
-     *     squares.join() + squares.join();
-     *
-     * If you know a `Seq` will be used multiple times, it may be more
-     * efficient to first cache it in memory. Here, the map function is called
-     * only 3 times.
-     *
-     *     var squares = Seq.of(1,2,3).map(x => x * x).cacheResult();
-     *     squares.join() + squares.join();
-     *
-     * Use this method judiciously, as it must fully evaluate a Seq which can be
-     * a burden on memory and possibly performance.
-     *
-     * Note: after calling `cacheResult`, a Seq will always have a `size`.
-     */
-    cacheResult(): /*this*/Seq<K, V>;
-  }
-
-  /**
-   * The `Iterable` is a set of (key, value) entries which can be iterated, and
-   * is the base class for all collections in `immutable`, allowing them to
-   * make use of all the Iterable methods (such as `map` and `filter`).
-   *
-   * Note: An iterable is always iterated in the same order, however that order
-   * may not always be well defined, as is the case for the `Map` and `Set`.
-   */
-  export module Iterable {
-    /**
-     * True if `maybeIterable` is an Iterable, or any of its subclasses.
-     */
-    function isIterable(maybeIterable: any): boolean;
-
-    /**
-     * True if `maybeKeyed` is an Iterable.Keyed, or any of its subclasses.
-     */
-    function isKeyed(maybeKeyed: any): boolean;
-
-    /**
-     * True if `maybeIndexed` is a Iterable.Indexed, or any of its subclasses.
-     */
-    function isIndexed(maybeIndexed: any): boolean;
-
-    /**
-     * True if `maybeAssociative` is either a keyed or indexed Iterable.
-     */
-    function isAssociative(maybeAssociative: any): boolean;
-
-    /**
-     * True if `maybeOrdered` is an Iterable where iteration order is well
-     * defined. True for Iterable.Indexed as well as OrderedMap and OrderedSet.
-     */
-    function isOrdered(maybeOrdered: any): boolean;
-
-
-    /**
-     * Keyed Iterables have discrete keys tied to each value.
-     *
-     * When iterating `Iterable.Keyed`, each iteration will yield a `[K, V]`
-     * tuple, in other words, `Iterable#entries` is the default iterator for
-     * Keyed Iterables.
-     */
-    export module Keyed {}
-
-    /**
-     * Creates an Iterable.Keyed
-     *
-     * Similar to `Iterable()`, however it expects iterable-likes of [K, V]
-     * tuples if not constructed from a Iterable.Keyed or JS Object.
-     */
-    export function Keyed<K, V>(iter: Iterable.Keyed<K, V>): Iterable.Keyed<K, V>;
-    export function Keyed<K, V>(iter: Iterable<any, /*[K,V]*/any>): Iterable.Keyed<K, V>;
-    export function Keyed<K, V>(array: Array</*[K,V]*/any>): Iterable.Keyed<K, V>;
-    export function Keyed<V>(obj: {[key: string]: V}): Iterable.Keyed<string, V>;
-    export function Keyed<K, V>(iterator: Iterator</*[K,V]*/any>): Iterable.Keyed<K, V>;
-    export function Keyed<K, V>(iterable: /*Iterable<[K,V]>*/Object): Iterable.Keyed<K, V>;
-
-    export interface Keyed<K, V> extends Iterable<K, V> {
-
-      /**
-       * Returns Seq.Keyed.
-       * @override
-       */
-      toSeq(): Seq.Keyed<K, V>;
-
-
-      // Sequence functions
-
-      /**
-       * Returns a new Iterable.Keyed of the same type where the keys and values
-       * have been flipped.
-       *
-       *     Seq({ a: 'z', b: 'y' }).flip() // { z: 'a', y: 'b' }
-       *
-       */
-      flip(): /*this*/Iterable.Keyed<V, K>;
-
-      /**
-       * Returns a new Iterable.Keyed of the same type with keys passed through
-       * a `mapper` function.
-       *
-       *     Seq({ a: 1, b: 2 })
-       *       .mapKeys(x => x.toUpperCase())
-       *     // Seq { A: 1, B: 2 }
-       *
-       */
-      mapKeys<M>(
-        mapper: (key?: K, value?: V, iter?: /*this*/Iterable.Keyed<K, V>) => M,
-        context?: any
-      ): /*this*/Iterable.Keyed<M, V>;
-
-      /**
-       * Returns a new Iterable.Keyed of the same type with entries
-       * ([key, value] tuples) passed through a `mapper` function.
-       *
-       *     Seq({ a: 1, b: 2 })
-       *       .mapEntries(([k, v]) => [k.toUpperCase(), v * 2])
-       *     // Seq { A: 2, B: 4 }
-       *
-       */
-      mapEntries<KM, VM>(
-        mapper: (
-          entry?: /*(K, V)*/Array<any>,
-          index?: number,
-          iter?: /*this*/Iterable.Keyed<K, V>
-        ) => /*[KM, VM]*/Array<any>,
-        context?: any
-      ): /*this*/Iterable.Keyed<KM, VM>;
-
-
-      // Search for value
-
-      /**
-       * Returns the key associated with the search value, or undefined.
-       */
-      keyOf(searchValue: V): K;
-
-      /**
-       * Returns the last key associated with the search value, or undefined.
-       */
-      lastKeyOf(searchValue: V): K;
-
-      /**
-       * Returns the key for which the `predicate` returns true.
-       */
-      findKey(
-        predicate: (value?: V, key?: K, iter?: /*this*/Iterable.Keyed<K, V>) => boolean,
-        context?: any
-      ): K;
-
-      /**
-       * Returns the last key for which the `predicate` returns true.
-       *
-       * Note: `predicate` will be called for each entry in reverse.
-       */
-      findLastKey(
-        predicate: (value?: V, key?: K, iter?: /*this*/Iterable.Keyed<K, V>) => boolean,
-        context?: any
-      ): K;
-    }
-
-
-    /**
-     * Indexed Iterables have incrementing numeric keys. They exhibit
-     * slightly different behavior than `Iterable.Keyed` for some methods in order
-     * to better mirror the behavior of JavaScript's `Array`, and add methods
-     * which do not make sense on non-indexed Iterables such as `indexOf`.
-     *
-     * Unlike JavaScript arrays, `Iterable.Indexed`s are always dense. "Unset"
-     * indices and `undefined` indices are indistinguishable, and all indices from
-     * 0 to `size` are visited when iterated.
-     *
-     * All Iterable.Indexed methods return re-indexed Iterables. In other words,
-     * indices always start at 0 and increment until size. If you wish to
-     * preserve indices, using them as keys, convert to a Iterable.Keyed by
-     * calling `toKeyedSeq`.
-     */
-    export module Indexed {}
-
-    /**
-     * Creates a new Iterable.Indexed.
-     */
-    export function Indexed<T>(iter: Iterable.Indexed<T>): Iterable.Indexed<T>;
-    export function Indexed<T>(iter: Iterable.Set<T>): Iterable.Indexed<T>;
-    export function Indexed<K, V>(iter: Iterable.Keyed<K, V>): Iterable.Indexed</*[K,V]*/any>;
-    export function Indexed<T>(array: Array<T>): Iterable.Indexed<T>;
-    export function Indexed<T>(iterator: Iterator<T>): Iterable.Indexed<T>;
-    export function Indexed<T>(iterable: /*Iterable<T>*/Object): Iterable.Indexed<T>;
-
-    export interface Indexed<T> extends Iterable<number, T> {
-
-      // Reading values
-
-      /**
-       * Returns the value associated with the provided index, or notSetValue if
-       * the index is beyond the bounds of the Iterable.
-       *
-       * `index` may be a negative number, which indexes back from the end of the
-       * Iterable. `s.get(-1)` gets the last item in the Iterable.
-       */
-      get(index: number, notSetValue?: T): T;
-
-
-      // Conversion to Seq
-
-      /**
-       * Returns Seq.Indexed.
-       * @override
-       */
-      toSeq(): Seq.Indexed<T>;
-
-      /**
-       * If this is an iterable of [key, value] entry tuples, it will return a
-       * Seq.Keyed of those entries.
-       */
-      fromEntrySeq(): Seq.Keyed<any, any>;
-
-
-      // Combination
-
-      /**
-       * Returns an Iterable of the same type with `separator` between each item
-       * in this Iterable.
-       */
-      interpose(separator: T): /*this*/Iterable.Indexed<T>;
-
-      /**
-       * Returns an Iterable of the same type with the provided `iterables`
-       * interleaved into this iterable.
-       *
-       * The resulting Iterable includes the first item from each, then the
-       * second from each, etc.
-       *
-       *     I.Seq.of(1,2,3).interleave(I.Seq.of('A','B','C'))
-       *     // Seq [ 1, 'A', 2, 'B', 3, 'C' ]
-       *
-       * The shortest Iterable stops interleave.
-       *
-       *     I.Seq.of(1,2,3).interleave(
-       *       I.Seq.of('A','B'),
-       *       I.Seq.of('X','Y','Z')
-       *     )
-       *     // Seq [ 1, 'A', 'X', 2, 'B', 'Y' ]
-       */
-      interleave(...iterables: Array<Iterable<any, T>>): /*this*/Iterable.Indexed<T>;
-
-      /**
-       * Splice returns a new indexed Iterable by replacing a region of this
-       * Iterable with new values. If values are not provided, it only skips the
-       * region to be removed.
-       *
-       * `index` may be a negative number, which indexes back from the end of the
-       * Iterable. `s.splice(-2)` splices after the second to last item.
-       *
-       *     Seq(['a','b','c','d']).splice(1, 2, 'q', 'r', 's')
-       *     // Seq ['a', 'q', 'r', 's', 'd']
-       *
-       */
-      splice(
-        index: number,
-        removeNum: number,
-        ...values: /*Array<Iterable.Indexed<T> | T>*/any[]
-      ): /*this*/Iterable.Indexed<T>;
-
-      /**
-       * Returns an Iterable of the same type "zipped" with the provided
-       * iterables.
-       *
-       * Like `zipWith`, but using the default `zipper`: creating an `Array`.
-       *
-       *     var a = Seq.of(1, 2, 3);
-       *     var b = Seq.of(4, 5, 6);
-       *     var c = a.zip(b); // Seq [ [ 1, 4 ], [ 2, 5 ], [ 3, 6 ] ]
-       *
-       */
-      zip(...iterables: Array<Iterable<any, any>>): /*this*/Iterable.Indexed<any>;
-
-      /**
-       * Returns an Iterable of the same type "zipped" with the provided
-       * iterables by using a custom `zipper` function.
-       *
-       *     var a = Seq.of(1, 2, 3);
-       *     var b = Seq.of(4, 5, 6);
-       *     var c = a.zipWith((a, b) => a + b, b); // Seq [ 5, 7, 9 ]
-       *
-       */
-      zipWith<U, Z>(
-        zipper: (value: T, otherValue: U) => Z,
-        otherIterable: Iterable<any, U>
-      ): Iterable.Indexed<Z>;
-      zipWith<U, V, Z>(
-        zipper: (value: T, otherValue: U, thirdValue: V) => Z,
-        otherIterable: Iterable<any, U>,
-        thirdIterable: Iterable<any, V>
-      ): Iterable.Indexed<Z>;
-      zipWith<Z>(
-        zipper: (...any: Array<any>) => Z,
-        ...iterables: Array<Iterable<any, any>>
-      ): Iterable.Indexed<Z>;
-
-
-      // Search for value
-
-      /**
-       * Returns the first index at which a given value can be found in the
-       * Iterable, or -1 if it is not present.
-       */
-      indexOf(searchValue: T): number;
-
-      /**
-       * Returns the last index at which a given value can be found in the
-       * Iterable, or -1 if it is not present.
-       */
-      lastIndexOf(searchValue: T): number;
-
-      /**
-       * Returns the first index in the Iterable where a value satisfies the
-       * provided predicate function. Otherwise -1 is returned.
-       */
-      findIndex(
-        predicate: (value?: T, index?: number, iter?: /*this*/Iterable.Indexed<T>) => boolean,
-        context?: any
-      ): number;
-
-      /**
-       * Returns the last index in the Iterable where a value satisfies the
-       * provided predicate function. Otherwise -1 is returned.
-       */
-      findLastIndex(
-        predicate: (value?: T, index?: number, iter?: /*this*/Iterable.Indexed<T>) => boolean,
-        context?: any
-      ): number;
-    }
-
-
-    /**
-     * Set Iterables only represent values. They have no associated keys or
-     * indices. Duplicate values are possible in Seq.Sets, however the
-     * concrete `Set` does not allow duplicate values.
-     *
-     * Iterable methods on Iterable.Set such as `map` and `forEach` will provide
-     * the value as both the first and second arguments to the provided function.
-     *
-     *     var seq = Seq.Set.of('A', 'B', 'C');
-     *     assert.equal(seq.every((v, k) => v === k), true);
-     *
-     */
-    export module Set {}
-
-    /**
-     * Similar to `Iterable()`, but always returns a Iterable.Set.
-     */
-    export function Set<T>(iter: Iterable.Set<T>): Iterable.Set<T>;
-    export function Set<T>(iter: Iterable.Indexed<T>): Iterable.Set<T>;
-    export function Set<K, V>(iter: Iterable.Keyed<K, V>): Iterable.Set</*[K,V]*/any>;
-    export function Set<T>(array: Array<T>): Iterable.Set<T>;
-    export function Set<T>(iterator: Iterator<T>): Iterable.Set<T>;
-    export function Set<T>(iterable: /*Iterable<T>*/Object): Iterable.Set<T>;
-
-    export interface Set<T> extends Iterable<T, T> {
-
-      /**
-       * Returns Seq.Set.
-       * @override
-       */
-      toSeq(): Seq.Set<T>;
-    }
-
-  }
-
-  /**
-   * Creates an Iterable.
-   *
-   * The type of Iterable created is based on the input.
-   *
-   *   * If an `Iterable`, that same `Iterable`.
-   *   * If an Array-like, an `Iterable.Indexed`.
-   *   * If an Object with an Iterator, an `Iterable.Indexed`.
-   *   * If an Iterator, an `Iterable.Indexed`.
-   *   * If an Object, an `Iterable.Keyed`.
-   *
-   * This methods forces the conversion of Objects and Strings to Iterables.
-   * If you want to ensure that a Iterable of one item is returned, use
-   * `Seq.of`.
-   */
-  export function Iterable<K, V>(iterable: Iterable<K, V>): Iterable<K, V>;
-  export function Iterable<T>(array: Array<T>): Iterable.Indexed<T>;
-  export function Iterable<V>(obj: {[key: string]: V}): Iterable.Keyed<string, V>;
-  export function Iterable<T>(iterator: Iterator<T>): Iterable.Indexed<T>;
-  export function Iterable<T>(iterable: /*ES6Iterable<T>*/Object): Iterable.Indexed<T>;
-  export function Iterable<V>(value: V): Iterable.Indexed<V>;
-
-  export interface Iterable<K, V> {
-
-    // Value equality
-
-    /**
-     * True if this and the other Iterable have value equality, as defined
-     * by `Immutable.is()`.
-     *
-     * Note: This is equivalent to `Immutable.is(this, other)`, but provided to
-     * allow for chained expressions.
-     */
-    equals(other: Iterable<K, V>): boolean;
-
-    /**
-     * Computes and returns the hashed identity for this Iterable.
-     *
-     * The `hashCode` of an Iterable is used to determine potential equality,
-     * and is used when adding this to a `Set` or as a key in a `Map`, enabling
-     * lookup via a different instance.
-     *
-     *     var a = List.of(1, 2, 3);
-     *     var b = List.of(1, 2, 3);
-     *     assert(a !== b); // different instances
-     *     var set = Set.of(a);
-     *     assert(set.has(b) === true);
-     *
-     * If two values have the same `hashCode`, they are [not guaranteed
-     * to be equal][Hash Collision]. If two values have different `hashCode`s,
-     * they must not be equal.
-     *
-     * [Hash Collision]: http://en.wikipedia.org/wiki/Collision_(computer_science)
-     */
-    hashCode(): number;
-
-
-    // Reading values
-
-    /**
-     * Returns the value associated with the provided key, or notSetValue if
-     * the Iterable does not contain this key.
-     *
-     * Note: it is possible a key may be associated with an `undefined` value,
-     * so if `notSetValue` is not provided and this method returns `undefined`,
-     * that does not guarantee the key was not found.
-     */
-    get(key: K, notSetValue?: V): V;
-
-    /**
-     * True if a key exists within this `Iterable`.
-     */
-    has(key: K): boolean;
-
-    /**
-     * True if a value exists within this `Iterable`.
-     * @alias contains
-     */
-    includes(value: V): boolean;
-    contains(value: V): boolean;
-
-    /**
-     * The first value in the Iterable.
-     */
-    first(): V;
-
-    /**
-     * The last value in the Iterable.
-     */
-    last(): V;
-
-
-    // Reading deep values
-
-    /**
-     * Returns the value found by following a path of keys or indices through
-     * nested Iterables.
-     */
-    getIn(searchKeyPath: Array<any>, notSetValue?: any): any;
-    getIn(searchKeyPath: Iterable<any, any>, notSetValue?: any): any;
-
-    /**
-     * True if the result of following a path of keys or indices through nested
-     * Iterables results in a set value.
-     */
-    hasIn(searchKeyPath: Array<any>): boolean;
-    hasIn(searchKeyPath: Iterable<any, any>): boolean;
-
-
-    // Conversion to JavaScript types
-
-    /**
-     * Deeply converts this Iterable to equivalent JS.
-     *
-     * `Iterable.Indexeds`, and `Iterable.Sets` become Arrays, while
-     * `Iterable.Keyeds` become Objects.
-     *
-     * @alias toJSON
-     */
-    toJS(): any;
-
-    /**
-     * Shallowly converts this iterable to an Array, discarding keys.
-     */
-    toArray(): Array<V>;
-
-    /**
-     * Shallowly converts this Iterable to an Object.
-     *
-     * Throws if keys are not strings.
-     */
-    toObject(): { [key: string]: V };
-
-
-    // Conversion to Collections
-
-    /**
-     * Converts this Iterable to a Map, Throws if keys are not hashable.
-     *
-     * Note: This is equivalent to `Map(this.toKeyedSeq())`, but provided
-     * for convenience and to allow for chained expressions.
-     */
-    toMap(): Map<K, V>;
-
-    /**
-     * Converts this Iterable to a Map, maintaining the order of iteration.
-     *
-     * Note: This is equivalent to `OrderedMap(this.toKeyedSeq())`, but
-     * provided for convenience and to allow for chained expressions.
-     */
-    toOrderedMap(): Map<K, V>;
-
-    /**
-     * Converts this Iterable to a Set, discarding keys. Throws if values
-     * are not hashable.
-     *
-     * Note: This is equivalent to `Set(this)`, but provided to allow for
-     * chained expressions.
-     */
-    toSet(): Set<V>;
-
-    /**
-     * Converts this Iterable to a Set, maintaining the order of iteration and
-     * discarding keys.
-     *
-     * Note: This is equivalent to `OrderedSet(this.valueSeq())`, but provided
-     * for convenience and to allow for chained expressions.
-     */
-    toOrderedSet(): Set<V>;
-
-    /**
-     * Converts this Iterable to a List, discarding keys.
-     *
-     * Note: This is equivalent to `List(this)`, but provided to allow
-     * for chained expressions.
-     */
-    toList(): List<V>;
-
-    /**
-     * Converts this Iterable to a Stack, discarding keys. Throws if values
-     * are not hashable.
-     *
-     * Note: This is equivalent to `Stack(this)`, but provided to allow for
-     * chained expressions.
-     */
-    toStack(): Stack<V>;
-
-
-    // Conversion to Seq
-
-    /**
-     * Converts this Iterable to a Seq of the same kind (indexed,
-     * keyed, or set).
-     */
-    toSeq(): Seq<K, V>;
-
-    /**
-     * Returns a Seq.Keyed from this Iterable where indices are treated as keys.
-     *
-     * This is useful if you want to operate on an
-     * Iterable.Indexed and preserve the [index, value] pairs.
-     *
-     * The returned Seq will have identical iteration order as
-     * this Iterable.
-     *
-     * Example:
-     *
-     *     var indexedSeq = Immutable.Seq.of('A', 'B', 'C');
-     *     indexedSeq.filter(v => v === 'B').toString() // Seq [ 'B' ]
-     *     var keyedSeq = indexedSeq.toKeyedSeq();
-     *     keyedSeq.filter(v => v === 'B').toString() // Seq { 1: 'B' }
-     *
-     */
-    toKeyedSeq(): Seq.Keyed<K, V>;
-
-    /**
-     * Returns an Seq.Indexed of the values of this Iterable, discarding keys.
-     */
-    toIndexedSeq(): Seq.Indexed<V>;
-
-    /**
-     * Returns a Seq.Set of the values of this Iterable, discarding keys.
-     */
-    toSetSeq(): Seq.Set<V>;
-
-
-    // Iterators
-
-    /**
-     * An iterator of this `Iterable`'s keys.
-     */
-    keys(): Iterator<K>;
-
-    /**
-     * An iterator of this `Iterable`'s values.
-     */
-    values(): Iterator<V>;
-
-    /**
-     * An iterator of this `Iterable`'s entries as `[key, value]` tuples.
-     */
-    entries(): Iterator</*[K, V]*/Array<any>>;
-
-
-    // Iterables (Seq)
-
-    /**
-     * Returns a new Seq.Indexed of the keys of this Iterable,
-     * discarding values.
-     */
-    keySeq(): Seq.Indexed<K>;
-
-    /**
-     * Returns an Seq.Indexed of the values of this Iterable, discarding keys.
-     */
-    valueSeq(): Seq.Indexed<V>;
-
-    /**
-     * Returns a new Seq.Indexed of [key, value] tuples.
-     */
-    entrySeq(): Seq.Indexed</*(K, V)*/Array<any>>;
-
-
-    // Sequence algorithms
-
-    /**
-     * Returns a new Iterable of the same type with values passed through a
-     * `mapper` function.
-     *
-     *     Seq({ a: 1, b: 2 }).map(x => 10 * x)
-     *     // Seq { a: 10, b: 20 }
-     *
-     */
-    map<M>(
-      mapper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => M,
-      context?: any
-    ): /*this*/Iterable<K, M>;
-
-    /**
-     * Returns a new Iterable of the same type with only the entries for which
-     * the `predicate` function returns true.
-     *
-     *     Seq({a:1,b:2,c:3,d:4}).filter(x => x % 2 === 0)
-     *     // Seq { b: 2, d: 4 }
-     *
-     */
-    filter(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type with only the entries for which
-     * the `predicate` function returns false.
-     *
-     *     Seq({a:1,b:2,c:3,d:4}).filterNot(x => x % 2 === 0)
-     *     // Seq { a: 1, c: 3 }
-     *
-     */
-    filterNot(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type in reverse order.
-     */
-    reverse(): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which includes the same entries,
-     * stably sorted by using a `comparator`.
-     *
-     * If a `comparator` is not provided, a default comparator uses `<` and `>`.
-     *
-     * `comparator(valueA, valueB)`:
-     *
-     *   * Returns `0` if the elements should not be swapped.
-     *   * Returns `-1` (or any negative number) if `valueA` comes before `valueB`
-     *   * Returns `1` (or any positive number) if `valueA` comes after `valueB`
-     *   * Is pure, i.e. it must always return the same value for the same pair
-     *     of values.
-     *
-     * When sorting collections which have no defined order, their ordered
-     * equivalents will be returned. e.g. `map.sort()` returns OrderedMap.
-     */
-    sort(comparator?: (valueA: V, valueB: V) => number): /*this*/Iterable<K, V>;
-
-    /**
-     * Like `sort`, but also accepts a `comparatorValueMapper` which allows for
-     * sorting by more sophisticated means:
-     *
-     *     hitters.sortBy(hitter => hitter.avgHits);
-     *
-     */
-    sortBy<C>(
-      comparatorValueMapper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => C,
-      comparator?: (valueA: C, valueB: C) => number
-    ): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a `Iterable.Keyed` of `Iterable.Keyeds`, grouped by the return
-     * value of the `grouper` function.
-     *
-     * Note: This is always an eager operation.
-     */
-    groupBy<G>(
-      grouper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => G,
-      context?: any
-    ): /*Map*/Seq.Keyed<G, /*this*/Iterable<K, V>>;
-
-
-    // Side effects
-
-    /**
-     * The `sideEffect` is executed for every entry in the Iterable.
-     *
-     * Unlike `Array#forEach`, if any call of `sideEffect` returns
-     * `false`, the iteration will stop. Returns the number of entries iterated
-     * (including the last iteration which returned false).
-     */
-    forEach(
-      sideEffect: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => any,
-      context?: any
-    ): number;
-
-
-    // Creating subsets
-
-    /**
-     * Returns a new Iterable of the same type representing a portion of this
-     * Iterable from start up to but not including end.
-     *
-     * If begin is negative, it is offset from the end of the Iterable. e.g.
-     * `slice(-2)` returns a Iterable of the last two entries. If it is not
-     * provided the new Iterable will begin at the beginning of this Iterable.
-     *
-     * If end is negative, it is offset from the end of the Iterable. e.g.
-     * `slice(0, -1)` returns an Iterable of everything but the last entry. If
-     * it is not provided, the new Iterable will continue through the end of
-     * this Iterable.
-     *
-     * If the requested slice is equivalent to the current Iterable, then it
-     * will return itself.
-     */
-    slice(begin?: number, end?: number): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type containing all entries except
-     * the first.
-     */
-    rest(): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type containing all entries except
-     * the last.
-     */
-    butLast(): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which excludes the first `amount`
-     * entries from this Iterable.
-     */
-    skip(amount: number): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which excludes the last `amount`
-     * entries from this Iterable.
-     */
-    skipLast(amount: number): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which includes entries starting
-     * from when `predicate` first returns false.
-     *
-     *     Seq.of('dog','frog','cat','hat','god')
-     *       .skipWhile(x => x.match(/g/))
-     *     // Seq [ 'cat', 'hat', 'god' ]
-     *
-     */
-    skipWhile(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which includes entries starting
-     * from when `predicate` first returns true.
-     *
-     *     Seq.of('dog','frog','cat','hat','god')
-     *       .skipUntil(x => x.match(/hat/))
-     *     // Seq [ 'hat', 'god' ]
-     *
-     */
-    skipUntil(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which includes the first `amount`
-     * entries from this Iterable.
-     */
-    take(amount: number): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which includes the last `amount`
-     * entries from this Iterable.
-     */
-    takeLast(amount: number): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which includes entries from this
-     * Iterable as long as the `predicate` returns true.
-     *
-     *     Seq.of('dog','frog','cat','hat','god')
-     *       .takeWhile(x => x.match(/o/))
-     *     // Seq [ 'dog', 'frog' ]
-     *
-     */
-    takeWhile(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): /*this*/Iterable<K, V>;
-
-    /**
-     * Returns a new Iterable of the same type which includes entries from this
-     * Iterable as long as the `predicate` returns false.
-     *
-     *     Seq.of('dog','frog','cat','hat','god').takeUntil(x => x.match(/at/))
-     *     // ['dog', 'frog']
-     *
-     */
-    takeUntil(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): /*this*/Iterable<K, V>;
-
-
-    // Combination
-
-    /**
-     * Returns a new Iterable of the same type with other values and
-     * iterable-like concatenated to this one.
-     *
-     * For Seqs, all entries will be present in
-     * the resulting iterable, even if they have the same key.
-     */
-    concat(...valuesOrIterables: /*Array<Iterable<K, V>|V*/any[]): /*this*/Iterable<K, V>;
-
-    /**
-     * Flattens nested Iterables.
-     *
-     * Will deeply flatten the Iterable by default, returning an Iterable of the
-     * same type, but a `depth` can be provided in the form of a number or
-     * boolean (where true means to shallowly flatten one level). A depth of 0
-     * (or shallow: false) will deeply flatten.
-     *
-     * Flattens only others Iterable, not Arrays or Objects.
-     *
-     * Note: `flatten(true)` operates on Iterable<any, Iterable<K, V>> and
-     * returns Iterable<K, V>
-     */
-    flatten(depth?: number): /*this*/Iterable<any, any>;
-    flatten(shallow?: boolean): /*this*/Iterable<any, any>;
-
-    /**
-     * Flat-maps the Iterable, returning an Iterable of the same type.
-     *
-     * Similar to `iter.map(...).flatten(true)`.
-     */
-    flatMap<MK, MV>(
-      mapper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => Iterable<MK, MV>,
-      context?: any
-    ): /*this*/Iterable<MK, MV>;
-    flatMap<MK, MV>(
-      mapper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => /*iterable-like*/any,
-      context?: any
-    ): /*this*/Iterable<MK, MV>;
-
-
-    // Reducing a value
-
-    /**
-     * Reduces the Iterable to a value by calling the `reducer` for every entry
-     * in the Iterable and passing along the reduced value.
-     *
-     * If `initialReduction` is not provided, or is null, the first item in the
-     * Iterable will be used.
-     *
-     * @see `Array#reduce`.
-     */
-    reduce<R>(
-      reducer: (reduction?: R, value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => R,
-      initialReduction?: R,
-      context?: any
-    ): R;
-
-    /**
-     * Reduces the Iterable in reverse (from the right side).
-     *
-     * Note: Similar to this.reverse().reduce(), and provided for parity
-     * with `Array#reduceRight`.
-     */
-    reduceRight<R>(
-      reducer: (reduction?: R, value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => R,
-      initialReduction?: R,
-      context?: any
-    ): R;
-
-    /**
-     * True if `predicate` returns true for all entries in the Iterable.
-     */
-    every(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): boolean;
-
-    /**
-     * True if `predicate` returns true for any entry in the Iterable.
-     */
-    some(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): boolean;
-
-    /**
-     * Joins values together as a string, inserting a separator between each.
-     * The default separator is `","`.
-     */
-    join(separator?: string): string;
-
-    /**
-     * Returns true if this Iterable includes no values.
-     *
-     * For some lazy `Seq`, `isEmpty` might need to iterate to determine
-     * emptiness. At most one iteration will occur.
-     */
-    isEmpty(): boolean;
-
-    /**
-     * Returns the size of this Iterable.
-     *
-     * Regardless of if this Iterable can describe its size lazily (some Seqs
-     * cannot), this method will always return the correct size. E.g. it
-     * evaluates a lazy `Seq` if necessary.
-     *
-     * If `predicate` is provided, then this returns the count of entries in the
-     * Iterable for which the `predicate` returns true.
-     */
-    count(): number;
-    count(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any
-    ): number;
-
-    /**
-     * Returns a `Seq.Keyed` of counts, grouped by the return value of
-     * the `grouper` function.
-     *
-     * Note: This is not a lazy operation.
-     */
-    countBy<G>(
-      grouper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => G,
-      context?: any
-    ): Map<G, number>;
-
-
-    // Search for value
-
-    /**
-     * Returns the value for which the `predicate` returns true.
-     */
-    find(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any,
-      notSetValue?: V
-    ): V;
-
-    /**
-     * Returns the last value for which the `predicate` returns true.
-     *
-     * Note: `predicate` will be called for each entry in reverse.
-     */
-    findLast(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any,
-      notSetValue?: V
-    ): V;
-
-    /**
-     * Returns the [key, value] entry for which the `predicate` returns true.
-     */
-    findEntry(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any,
-      notSetValue?: V
-    ): /*[K, V]*/Array<any>;
-
-    /**
-     * Returns the last [key, value] entry for which the `predicate`
-     * returns true.
-     *
-     * Note: `predicate` will be called for each entry in reverse.
-     */
-    findLastEntry(
-      predicate: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => boolean,
-      context?: any,
-      notSetValue?: V
-    ): /*[K, V]*/Array<any>;
-
-    /**
-     * Returns the maximum value in this collection. If any values are
-     * comparatively equivalent, the first one found will be returned.
-     *
-     * The `comparator` is used in the same way as `Iterable#sort`. If it is not
-     * provided, the default comparator is `>`.
-     *
-     * When two values are considered equivalent, the first encountered will be
-     * returned. Otherwise, `max` will operate independent of the order of input
-     * as long as the comparator is commutative. The default comparator `>` is
-     * commutative *only* when types do not differ.
-     *
-     * If `comparator` returns 0 and either value is NaN, undefined, or null,
-     * that value will be returned.
-     */
-    max(comparator?: (valueA: V, valueB: V) => number): V;
-
-    /**
-     * Like `max`, but also accepts a `comparatorValueMapper` which allows for
-     * comparing by more sophisticated means:
-     *
-     *     hitters.maxBy(hitter => hitter.avgHits);
-     *
-     */
-    maxBy<C>(
-      comparatorValueMapper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => C,
-      comparator?: (valueA: C, valueB: C) => number
-    ): V;
-
-    /**
-     * Returns the minimum value in this collection. If any values are
-     * comparatively equivalent, the first one found will be returned.
-     *
-     * The `comparator` is used in the same way as `Iterable#sort`. If it is not
-     * provided, the default comparator is `<`.
-     *
-     * When two values are considered equivalent, the first encountered will be
-     * returned. Otherwise, `min` will operate independent of the order of input
-     * as long as the comparator is commutative. The default comparator `<` is
-     * commutative *only* when types do not differ.
-     *
-     * If `comparator` returns 0 and either value is NaN, undefined, or null,
-     * that value will be returned.
-     */
-    min(comparator?: (valueA: V, valueB: V) => number): V;
-
-    /**
-     * Like `min`, but also accepts a `comparatorValueMapper` which allows for
-     * comparing by more sophisticated means:
-     *
-     *     hitters.minBy(hitter => hitter.avgHits);
-     *
-     */
-    minBy<C>(
-      comparatorValueMapper: (value?: V, key?: K, iter?: /*this*/Iterable<K, V>) => C,
-      comparator?: (valueA: C, valueB: C) => number
-    ): V;
-
-
-    // Comparison
-
-    /**
-     * True if `iter` includes every value in this Iterable.
-     */
-    isSubset(iter: Iterable<any, V>): boolean;
-    isSubset(iter: Array<V>): boolean;
-
-    /**
-     * True if this Iterable includes every value in `iter`.
-     */
-    isSuperset(iter: Iterable<any, V>): boolean;
-    isSuperset(iter: Array<V>): boolean;
-
-
-    /**
-     * Note: this is here as a convenience to work around an issue with
-     * TypeScript https://github.com/Microsoft/TypeScript/issues/285, but
-     * Iterable does not define `size`, instead `Seq` defines `size` as
-     * nullable number, and `Collection` defines `size` as always a number.
-     *
-     * @ignore
-     */
-    size: number;
-  }
-
-
-  /**
-   * Collection is the abstract base class for concrete data structures. It
-   * cannot be constructed directly.
-   *
-   * Implementations should extend one of the subclasses, `Collection.Keyed`,
-   * `Collection.Indexed`, or `Collection.Set`.
-   */
-  export module Collection {
-
-
-    /**
-     * `Collection` which represents key-value pairs.
-     */
-    export module Keyed {}
-
-    export interface Keyed<K, V> extends Collection<K, V>, Iterable.Keyed<K, V> {
-
-      /**
-       * Returns Seq.Keyed.
-       * @override
-       */
-      toSeq(): Seq.Keyed<K, V>;
-    }
-
-
-    /**
-     * `Collection` which represents ordered indexed values.
-     */
-    export module Indexed {}
-
-    export interface Indexed<T> extends Collection<number, T>, Iterable.Indexed<T> {
-
-      /**
-       * Returns Seq.Indexed.
-       * @override
-       */
-      toSeq(): Seq.Indexed<T>;
-    }
-
-
-    /**
-     * `Collection` which represents values, unassociated with keys or indices.
-     *
-     * `Collection.Set` implementations should guarantee value uniqueness.
-     */
-    export module Set {}
-
-    export interface Set<T> extends Collection<T, T>, Iterable.Set<T> {
-
-      /**
-       * Returns Seq.Set.
-       * @override
-       */
-      toSeq(): Seq.Set<T>;
-    }
-
-  }
-
-  export interface Collection<K, V> extends Iterable<K, V> {
-
-    /**
-     * All collections maintain their current `size` as an integer.
-     */
-    size: number;
-  }
-
-
-  /**
-   * ES6 Iterator.
-   *
-   * This is not part of the Immutable library, but a common interface used by
-   * many types in ES6 JavaScript.
-   *
-   * @ignore
-   */
-  export interface Iterator<T> {
-    next(): { value: T; done: boolean; }
-  }
-
-}
-
-declare module "immutable" {
-  export = Immutable
-}
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.js b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.js
deleted file mode 100644
index 25d95a6..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.js
+++ /dev/null
@@ -1,4982 +0,0 @@
-/**
- *  Copyright (c) 2014-2015, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- */
-
-(function (global, factory) {
-  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
-  typeof define === 'function' && define.amd ? define(factory) :
-  global.Immutable = factory();
-}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;
-
-  function createClass(ctor, superClass) {
-    if (superClass) {
-      ctor.prototype = Object.create(superClass.prototype);
-    }
-    ctor.prototype.constructor = ctor;
-  }
-
-  function Iterable(value) {
-      return isIterable(value) ? value : Seq(value);
-    }
-
-
-  createClass(KeyedIterable, Iterable);
-    function KeyedIterable(value) {
-      return isKeyed(value) ? value : KeyedSeq(value);
-    }
-
-
-  createClass(IndexedIterable, Iterable);
-    function IndexedIterable(value) {
-      return isIndexed(value) ? value : IndexedSeq(value);
-    }
-
-
-  createClass(SetIterable, Iterable);
-    function SetIterable(value) {
-      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
-    }
-
-
-
-  function isIterable(maybeIterable) {
-    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
-  }
-
-  function isKeyed(maybeKeyed) {
-    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
-  }
-
-  function isIndexed(maybeIndexed) {
-    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
-  }
-
-  function isAssociative(maybeAssociative) {
-    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
-  }
-
-  function isOrdered(maybeOrdered) {
-    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
-  }
-
-  Iterable.isIterable = isIterable;
-  Iterable.isKeyed = isKeyed;
-  Iterable.isIndexed = isIndexed;
-  Iterable.isAssociative = isAssociative;
-  Iterable.isOrdered = isOrdered;
-
-  Iterable.Keyed = KeyedIterable;
-  Iterable.Indexed = IndexedIterable;
-  Iterable.Set = SetIterable;
-
-
-  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
-  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
-  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
-  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
-
-  // Used for setting prototype methods that IE8 chokes on.
-  var DELETE = 'delete';
-
-  // Constants describing the size of trie nodes.
-  var SHIFT = 5; // Resulted in best performance after ______?
-  var SIZE = 1 << SHIFT;
-  var MASK = SIZE - 1;
-
-  // A consistent shared value representing "not set" which equals nothing other
-  // than itself, and nothing that could be provided externally.
-  var NOT_SET = {};
-
-  // Boolean references, Rough equivalent of `bool &`.
-  var CHANGE_LENGTH = { value: false };
-  var DID_ALTER = { value: false };
-
-  function MakeRef(ref) {
-    ref.value = false;
-    return ref;
-  }
-
-  function SetRef(ref) {
-    ref && (ref.value = true);
-  }
-
-  // A function which returns a value representing an "owner" for transient writes
-  // to tries. The return value will only ever equal itself, and will not equal
-  // the return of any subsequent call of this function.
-  function OwnerID() {}
-
-  // http://jsperf.com/copy-array-inline
-  function arrCopy(arr, offset) {
-    offset = offset || 0;
-    var len = Math.max(0, arr.length - offset);
-    var newArr = new Array(len);
-    for (var ii = 0; ii < len; ii++) {
-      newArr[ii] = arr[ii + offset];
-    }
-    return newArr;
-  }
-
-  function ensureSize(iter) {
-    if (iter.size === undefined) {
-      iter.size = iter.__iterate(returnTrue);
-    }
-    return iter.size;
-  }
-
-  function wrapIndex(iter, index) {
-    // This implements "is array index" which the ECMAString spec defines as:
-    //
-    //     A String property name P is an array index if and only if
-    //     ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal
-    //     to 2^32−1.
-    //
-    // http://www.ecma-international.org/ecma-262/6.0/#sec-array-exotic-objects
-    if (typeof index !== 'number') {
-      var uint32Index = index >>> 0; // N >>> 0 is shorthand for ToUint32
-      if ('' + uint32Index !== index || uint32Index === 4294967295) {
-        return NaN;
-      }
-      index = uint32Index;
-    }
-    return index < 0 ? ensureSize(iter) + index : index;
-  }
-
-  function returnTrue() {
-    return true;
-  }
-
-  function wholeSlice(begin, end, size) {
-    return (begin === 0 || (size !== undefined && begin <= -size)) &&
-      (end === undefined || (size !== undefined && end >= size));
-  }
-
-  function resolveBegin(begin, size) {
-    return resolveIndex(begin, size, 0);
-  }
-
-  function resolveEnd(end, size) {
-    return resolveIndex(end, size, size);
-  }
-
-  function resolveIndex(index, size, defaultIndex) {
-    return index === undefined ?
-      defaultIndex :
-      index < 0 ?
-        Math.max(0, size + index) :
-        size === undefined ?
-          index :
-          Math.min(size, index);
-  }
-
-  /* global Symbol */
-
-  var ITERATE_KEYS = 0;
-  var ITERATE_VALUES = 1;
-  var ITERATE_ENTRIES = 2;
-
-  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
-  var FAUX_ITERATOR_SYMBOL = '@@iterator';
-
-  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;
-
-
-  function Iterator(next) {
-      this.next = next;
-    }
-
-    Iterator.prototype.toString = function() {
-      return '[Iterator]';
-    };
-
-
-  Iterator.KEYS = ITERATE_KEYS;
-  Iterator.VALUES = ITERATE_VALUES;
-  Iterator.ENTRIES = ITERATE_ENTRIES;
-
-  Iterator.prototype.inspect =
-  Iterator.prototype.toSource = function () { return this.toString(); }
-  Iterator.prototype[ITERATOR_SYMBOL] = function () {
-    return this;
-  };
-
-
-  function iteratorValue(type, k, v, iteratorResult) {
-    var value = type === 0 ? k : type === 1 ? v : [k, v];
-    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
-      value: value, done: false
-    });
-    return iteratorResult;
-  }
-
-  function iteratorDone() {
-    return { value: undefined, done: true };
-  }
-
-  function hasIterator(maybeIterable) {
-    return !!getIteratorFn(maybeIterable);
-  }
-
-  function isIterator(maybeIterator) {
-    return maybeIterator && typeof maybeIterator.next === 'function';
-  }
-
-  function getIterator(iterable) {
-    var iteratorFn = getIteratorFn(iterable);
-    return iteratorFn && iteratorFn.call(iterable);
-  }
-
-  function getIteratorFn(iterable) {
-    var iteratorFn = iterable && (
-      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
-      iterable[FAUX_ITERATOR_SYMBOL]
-    );
-    if (typeof iteratorFn === 'function') {
-      return iteratorFn;
-    }
-  }
-
-  function isArrayLike(value) {
-    return value && typeof value.length === 'number';
-  }
-
-  createClass(Seq, Iterable);
-    function Seq(value) {
-      return value === null || value === undefined ? emptySequence() :
-        isIterable(value) ? value.toSeq() : seqFromValue(value);
-    }
-
-    Seq.of = function(/*...values*/) {
-      return Seq(arguments);
-    };
-
-    Seq.prototype.toSeq = function() {
-      return this;
-    };
-
-    Seq.prototype.toString = function() {
-      return this.__toString('Seq {', '}');
-    };
-
-    Seq.prototype.cacheResult = function() {
-      if (!this._cache && this.__iterateUncached) {
-        this._cache = this.entrySeq().toArray();
-        this.size = this._cache.length;
-      }
-      return this;
-    };
-
-    // abstract __iterateUncached(fn, reverse)
-
-    Seq.prototype.__iterate = function(fn, reverse) {
-      return seqIterate(this, fn, reverse, true);
-    };
-
-    // abstract __iteratorUncached(type, reverse)
-
-    Seq.prototype.__iterator = function(type, reverse) {
-      return seqIterator(this, type, reverse, true);
-    };
-
-
-
-  createClass(KeyedSeq, Seq);
-    function KeyedSeq(value) {
-      return value === null || value === undefined ?
-        emptySequence().toKeyedSeq() :
-        isIterable(value) ?
-          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
-          keyedSeqFromValue(value);
-    }
-
-    KeyedSeq.prototype.toKeyedSeq = function() {
-      return this;
-    };
-
-
-
-  createClass(IndexedSeq, Seq);
-    function IndexedSeq(value) {
-      return value === null || value === undefined ? emptySequence() :
-        !isIterable(value) ? indexedSeqFromValue(value) :
-        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
-    }
-
-    IndexedSeq.of = function(/*...values*/) {
-      return IndexedSeq(arguments);
-    };
-
-    IndexedSeq.prototype.toIndexedSeq = function() {
-      return this;
-    };
-
-    IndexedSeq.prototype.toString = function() {
-      return this.__toString('Seq [', ']');
-    };
-
-    IndexedSeq.prototype.__iterate = function(fn, reverse) {
-      return seqIterate(this, fn, reverse, false);
-    };
-
-    IndexedSeq.prototype.__iterator = function(type, reverse) {
-      return seqIterator(this, type, reverse, false);
-    };
-
-
-
-  createClass(SetSeq, Seq);
-    function SetSeq(value) {
-      return (
-        value === null || value === undefined ? emptySequence() :
-        !isIterable(value) ? indexedSeqFromValue(value) :
-        isKeyed(value) ? value.entrySeq() : value
-      ).toSetSeq();
-    }
-
-    SetSeq.of = function(/*...values*/) {
-      return SetSeq(arguments);
-    };
-
-    SetSeq.prototype.toSetSeq = function() {
-      return this;
-    };
-
-
-
-  Seq.isSeq = isSeq;
-  Seq.Keyed = KeyedSeq;
-  Seq.Set = SetSeq;
-  Seq.Indexed = IndexedSeq;
-
-  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';
-
-  Seq.prototype[IS_SEQ_SENTINEL] = true;
-
-
-
-  createClass(ArraySeq, IndexedSeq);
-    function ArraySeq(array) {
-      this._array = array;
-      this.size = array.length;
-    }
-
-    ArraySeq.prototype.get = function(index, notSetValue) {
-      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
-    };
-
-    ArraySeq.prototype.__iterate = function(fn, reverse) {
-      var array = this._array;
-      var maxIndex = array.length - 1;
-      for (var ii = 0; ii <= maxIndex; ii++) {
-        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
-          return ii + 1;
-        }
-      }
-      return ii;
-    };
-
-    ArraySeq.prototype.__iterator = function(type, reverse) {
-      var array = this._array;
-      var maxIndex = array.length - 1;
-      var ii = 0;
-      return new Iterator(function() 
-        {return ii > maxIndex ?
-          iteratorDone() :
-          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
-      );
-    };
-
-
-
-  createClass(ObjectSeq, KeyedSeq);
-    function ObjectSeq(object) {
-      var keys = Object.keys(object);
-      this._object = object;
-      this._keys = keys;
-      this.size = keys.length;
-    }
-
-    ObjectSeq.prototype.get = function(key, notSetValue) {
-      if (notSetValue !== undefined && !this.has(key)) {
-        return notSetValue;
-      }
-      return this._object[key];
-    };
-
-    ObjectSeq.prototype.has = function(key) {
-      return this._object.hasOwnProperty(key);
-    };
-
-    ObjectSeq.prototype.__iterate = function(fn, reverse) {
-      var object = this._object;
-      var keys = this._keys;
-      var maxIndex = keys.length - 1;
-      for (var ii = 0; ii <= maxIndex; ii++) {
-        var key = keys[reverse ? maxIndex - ii : ii];
-        if (fn(object[key], key, this) === false) {
-          return ii + 1;
-        }
-      }
-      return ii;
-    };
-
-    ObjectSeq.prototype.__iterator = function(type, reverse) {
-      var object = this._object;
-      var keys = this._keys;
-      var maxIndex = keys.length - 1;
-      var ii = 0;
-      return new Iterator(function()  {
-        var key = keys[reverse ? maxIndex - ii : ii];
-        return ii++ > maxIndex ?
-          iteratorDone() :
-          iteratorValue(type, key, object[key]);
-      });
-    };
-
-  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;
-
-
-  createClass(IterableSeq, IndexedSeq);
-    function IterableSeq(iterable) {
-      this._iterable = iterable;
-      this.size = iterable.length || iterable.size;
-    }
-
-    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
-      if (reverse) {
-        return this.cacheResult().__iterate(fn, reverse);
-      }
-      var iterable = this._iterable;
-      var iterator = getIterator(iterable);
-      var iterations = 0;
-      if (isIterator(iterator)) {
-        var step;
-        while (!(step = iterator.next()).done) {
-          if (fn(step.value, iterations++, this) === false) {
-            break;
-          }
-        }
-      }
-      return iterations;
-    };
-
-    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
-      if (reverse) {
-        return this.cacheResult().__iterator(type, reverse);
-      }
-      var iterable = this._iterable;
-      var iterator = getIterator(iterable);
-      if (!isIterator(iterator)) {
-        return new Iterator(iteratorDone);
-      }
-      var iterations = 0;
-      return new Iterator(function()  {
-        var step = iterator.next();
-        return step.done ? step : iteratorValue(type, iterations++, step.value);
-      });
-    };
-
-
-
-  createClass(IteratorSeq, IndexedSeq);
-    function IteratorSeq(iterator) {
-      this._iterator = iterator;
-      this._iteratorCache = [];
-    }
-
-    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
-      if (reverse) {
-        return this.cacheResult().__iterate(fn, reverse);
-      }
-      var iterator = this._iterator;
-      var cache = this._iteratorCache;
-      var iterations = 0;
-      while (iterations < cache.length) {
-        if (fn(cache[iterations], iterations++, this) === false) {
-          return iterations;
-        }
-      }
-      var step;
-      while (!(step = iterator.next()).done) {
-        var val = step.value;
-        cache[iterations] = val;
-        if (fn(val, iterations++, this) === false) {
-          break;
-        }
-      }
-      return iterations;
-    };
-
-    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
-      if (reverse) {
-        return this.cacheResult().__iterator(type, reverse);
-      }
-      var iterator = this._iterator;
-      var cache = this._iteratorCache;
-      var iterations = 0;
-      return new Iterator(function()  {
-        if (iterations >= cache.length) {
-          var step = iterator.next();
-          if (step.done) {
-            return step;
-          }
-          cache[iterations] = step.value;
-        }
-        return iteratorValue(type, iterations, cache[iterations++]);
-      });
-    };
-
-
-
-
-  // # pragma Helper functions
-
-  function isSeq(maybeSeq) {
-    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
-  }
-
-  var EMPTY_SEQ;
-
-  function emptySequence() {
-    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
-  }
-
-  function keyedSeqFromValue(value) {
-    var seq =
-      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
-      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
-      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
-      typeof value === 'object' ? new ObjectSeq(value) :
-      undefined;
-    if (!seq) {
-      throw new TypeError(
-        'Expected Array or iterable object of [k, v] entries, '+
-        'or keyed object: ' + value
-      );
-    }
-    return seq;
-  }
-
-  function indexedSeqFromValue(value) {
-    var seq = maybeIndexedSeqFromValue(value);
-    if (!seq) {
-      throw new TypeError(
-        'Expected Array or iterable object of values: ' + value
-      );
-    }
-    return seq;
-  }
-
-  function seqFromValue(value) {
-    var seq = maybeIndexedSeqFromValue(value) ||
-      (typeof value === 'object' && new ObjectSeq(value));
-    if (!seq) {
-      throw new TypeError(
-        'Expected Array or iterable object of values, or keyed object: ' + value
-      );
-    }
-    return seq;
-  }
-
-  function maybeIndexedSeqFromValue(value) {
-    return (
-      isArrayLike(value) ? new ArraySeq(value) :
-      isIterator(value) ? new IteratorSeq(value) :
-      hasIterator(value) ? new IterableSeq(value) :
-      undefined
-    );
-  }
-
-  function seqIterate(seq, fn, reverse, useKeys) {
-    var cache = seq._cache;
-    if (cache) {
-      var maxIndex = cache.length - 1;
-      for (var ii = 0; ii <= maxIndex; ii++) {
-        var entry = cache[reverse ? maxIndex - ii : ii];
-        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
-          return ii + 1;
-        }
-      }
-      return ii;
-    }
-    return seq.__iterateUncached(fn, reverse);
-  }
-
-  function seqIterator(seq, type, reverse, useKeys) {
-    var cache = seq._cache;
-    if (cache) {
-      var maxIndex = cache.length - 1;
-      var ii = 0;
-      return new Iterator(function()  {
-        var entry = cache[reverse ? maxIndex - ii : ii];
-        return ii++ > maxIndex ?
-          iteratorDone() :
-          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
-      });
-    }
-    return seq.__iteratorUncached(type, reverse);
-  }
-
-  function fromJS(json, converter) {
-    return converter ?
-      fromJSWith(converter, json, '', {'': json}) :
-      fromJSDefault(json);
-  }
-
-  function fromJSWith(converter, json, key, parentJSON) {
-    if (Array.isArray(json)) {
-      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
-    }
-    if (isPlainObj(json)) {
-      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
-    }
-    return json;
-  }
-
-  function fromJSDefault(json) {
-    if (Array.isArray(json)) {
-      return IndexedSeq(json).map(fromJSDefault).toList();
-    }
-    if (isPlainObj(json)) {
-      return KeyedSeq(json).map(fromJSDefault).toMap();
-    }
-    return json;
-  }
-
-  function isPlainObj(value) {
-    return value && (value.constructor === Object || value.constructor === undefined);
-  }
-
-  /**
-   * An extension of the "same-value" algorithm as [described for use by ES6 Map
-   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
-   *
-   * NaN is considered the same as NaN, however -0 and 0 are considered the same
-   * value, which is different from the algorithm described by
-   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
-   *
-   * This is extended further to allow Objects to describe the values they
-   * represent, by way of `valueOf` or `equals` (and `hashCode`).
-   *
-   * Note: because of this extension, the key equality of Immutable.Map and the
-   * value equality of Immutable.Set will differ from ES6 Map and Set.
-   *
-   * ### Defining custom values
-   *
-   * The easiest way to describe the value an object represents is by implementing
-   * `valueOf`. For example, `Date` represents a value by returning a unix
-   * timestamp for `valueOf`:
-   *
-   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
-   *     var date2 = new Date(1234567890000);
-   *     date1.valueOf(); // 1234567890000
-   *     assert( date1 !== date2 );
-   *     assert( Immutable.is( date1, date2 ) );
-   *
-   * Note: overriding `valueOf` may have other implications if you use this object
-   * where JavaScript expects a primitive, such as implicit string coercion.
-   *
-   * For more complex types, especially collections, implementing `valueOf` may
-   * not be performant. An alternative is to implement `equals` and `hashCode`.
-   *
-   * `equals` takes another object, presumably of similar type, and returns true
-   * if the it is equal. Equality is symmetrical, so the same result should be
-   * returned if this and the argument are flipped.
-   *
-   *     assert( a.equals(b) === b.equals(a) );
-   *
-   * `hashCode` returns a 32bit integer number representing the object which will
-   * be used to determine how to store the value object in a Map or Set. You must
-   * provide both or neither methods, one must not exist without the other.
-   *
-   * Also, an important relationship between these methods must be upheld: if two
-   * values are equal, they *must* return the same hashCode. If the values are not
-   * equal, they might have the same hashCode; this is called a hash collision,
-   * and while undesirable for performance reasons, it is acceptable.
-   *
-   *     if (a.equals(b)) {
-   *       assert( a.hashCode() === b.hashCode() );
-   *     }
-   *
-   * All Immutable collections implement `equals` and `hashCode`.
-   *
-   */
-  function is(valueA, valueB) {
-    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
-      return true;
-    }
-    if (!valueA || !valueB) {
-      return false;
-    }
-    if (typeof valueA.valueOf === 'function' &&
-        typeof valueB.valueOf === 'function') {
-      valueA = valueA.valueOf();
-      valueB = valueB.valueOf();
-      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
-        return true;
-      }
-      if (!valueA || !valueB) {
-        return false;
-      }
-    }
-    if (typeof valueA.equals === 'function' &&
-        typeof valueB.equals === 'function' &&
-        valueA.equals(valueB)) {
-      return true;
-    }
-    return false;
-  }
-
-  function deepEqual(a, b) {
-    if (a === b) {
-      return true;
-    }
-
-    if (
-      !isIterable(b) ||
-      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
-      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
-      isKeyed(a) !== isKeyed(b) ||
-      isIndexed(a) !== isIndexed(b) ||
-      isOrdered(a) !== isOrdered(b)
-    ) {
-      return false;
-    }
-
-    if (a.size === 0 && b.size === 0) {
-      return true;
-    }
-
-    var notAssociative = !isAssociative(a);
-
-    if (isOrdered(a)) {
-      var entries = a.entries();
-      return b.every(function(v, k)  {
-        var entry = entries.next().value;
-        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
-      }) && entries.next().done;
-    }
-
-    var flipped = false;
-
-    if (a.size === undefined) {
-      if (b.size === undefined) {
-        if (typeof a.cacheResult === 'function') {
-          a.cacheResult();
-        }
-      } else {
-        flipped = true;
-        var _ = a;
-        a = b;
-        b = _;
-      }
-    }
-
-    var allEqual = true;
-    var bSize = b.__iterate(function(v, k)  {
-      if (notAssociative ? !a.has(v) :
-          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
-        allEqual = false;
-        return false;
-      }
-    });
-
-    return allEqual && a.size === bSize;
-  }
-
-  createClass(Repeat, IndexedSeq);
-
-    function Repeat(value, times) {
-      if (!(this instanceof Repeat)) {
-        return new Repeat(value, times);
-      }
-      this._value = value;
-      this.size = times === undefined ? Infinity : Math.max(0, times);
-      if (this.size === 0) {
-        if (EMPTY_REPEAT) {
-          return EMPTY_REPEAT;
-        }
-        EMPTY_REPEAT = this;
-      }
-    }
-
-    Repeat.prototype.toString = function() {
-      if (this.size === 0) {
-        return 'Repeat []';
-      }
-      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
-    };
-
-    Repeat.prototype.get = function(index, notSetValue) {
-      return this.has(index) ? this._value : notSetValue;
-    };
-
-    Repeat.prototype.includes = function(searchValue) {
-      return is(this._value, searchValue);
-    };
-
-    Repeat.prototype.slice = function(begin, end) {
-      var size = this.size;
-      return wholeSlice(begin, end, size) ? this :
-        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
-    };
-
-    Repeat.prototype.reverse = function() {
-      return this;
-    };
-
-    Repeat.prototype.indexOf = function(searchValue) {
-      if (is(this._value, searchValue)) {
-        return 0;
-      }
-      return -1;
-    };
-
-    Repeat.prototype.lastIndexOf = function(searchValue) {
-      if (is(this._value, searchValue)) {
-        return this.size;
-      }
-      return -1;
-    };
-
-    Repeat.prototype.__iterate = function(fn, reverse) {
-      for (var ii = 0; ii < this.size; ii++) {
-        if (fn(this._value, ii, this) === false) {
-          return ii + 1;
-        }
-      }
-      return ii;
-    };
-
-    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
-      var ii = 0;
-      return new Iterator(function() 
-        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
-      );
-    };
-
-    Repeat.prototype.equals = function(other) {
-      return other instanceof Repeat ?
-        is(this._value, other._value) :
-        deepEqual(other);
-    };
-
-
-  var EMPTY_REPEAT;
-
-  function invariant(condition, error) {
-    if (!condition) throw new Error(error);
-  }
-
-  createClass(Range, IndexedSeq);
-
-    function Range(start, end, step) {
-      if (!(this instanceof Range)) {
-        return new Range(start, end, step);
-      }
-      invariant(step !== 0, 'Cannot step a Range by 0');
-      start = start || 0;
-      if (end === undefined) {
-        end = Infinity;
-      }
-      step = step === undefined ? 1 : Math.abs(step);
-      if (end < start) {
-        step = -step;
-      }
-      this._start = start;
-      this._end = end;
-      this._step = step;
-      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
-      if (this.size === 0) {
-        if (EMPTY_RANGE) {
-          return EMPTY_RANGE;
-        }
-        EMPTY_RANGE = this;
-      }
-    }
-
-    Range.prototype.toString = function() {
-      if (this.size === 0) {
-        return 'Range []';
-      }
-      return 'Range [ ' +
-        this._start + '...' + this._end +
-        (this._step > 1 ? ' by ' + this._step : '') +
-      ' ]';
-    };
-
-    Range.prototype.get = function(index, notSetValue) {
-      return this.has(index) ?
-        this._start + wrapIndex(this, index) * this._step :
-        notSetValue;
-    };
-
-    Range.prototype.includes = function(searchValue) {
-      var possibleIndex = (searchValue - this._start) / this._step;
-      return possibleIndex >= 0 &&
-        possibleIndex < this.size &&
-        possibleIndex === Math.floor(possibleIndex);
-    };
-
-    Range.prototype.slice = function(begin, end) {
-      if (wholeSlice(begin, end, this.size)) {
-        return this;
-      }
-      begin = resolveBegin(begin, this.size);
-      end = resolveEnd(end, this.size);
-      if (end <= begin) {
-        return new Range(0, 0);
-      }
-      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
-    };
-
-    Range.prototype.indexOf = function(searchValue) {
-      var offsetValue = searchValue - this._start;
-      if (offsetValue % this._step === 0) {
-        var index = offsetValue / this._step;
-        if (index >= 0 && index < this.size) {
-          return index
-        }
-      }
-      return -1;
-    };
-
-    Range.prototype.lastIndexOf = function(searchValue) {
-      return this.indexOf(searchValue);
-    };
-
-    Range.prototype.__iterate = function(fn, reverse) {
-      var maxIndex = this.size - 1;
-      var step = this._step;
-      var value = reverse ? this._start + maxIndex * step : this._start;
-      for (var ii = 0; ii <= maxIndex; ii++) {
-        if (fn(value, ii, this) === false) {
-          return ii + 1;
-        }
-        value += reverse ? -step : step;
-      }
-      return ii;
-    };
-
-    Range.prototype.__iterator = function(type, reverse) {
-      var maxIndex = this.size - 1;
-      var step = this._step;
-      var value = reverse ? this._start + maxIndex * step : this._start;
-      var ii = 0;
-      return new Iterator(function()  {
-        var v = value;
-        value += reverse ? -step : step;
-        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
-      });
-    };
-
-    Range.prototype.equals = function(other) {
-      return other instanceof Range ?
-        this._start === other._start &&
-        this._end === other._end &&
-        this._step === other._step :
-        deepEqual(this, other);
-    };
-
-
-  var EMPTY_RANGE;
-
-  createClass(Collection, Iterable);
-    function Collection() {
-      throw TypeError('Abstract');
-    }
-
-
-  createClass(KeyedCollection, Collection);function KeyedCollection() {}
-
-  createClass(IndexedCollection, Collection);function IndexedCollection() {}
-
-  createClass(SetCollection, Collection);function SetCollection() {}
-
-
-  Collection.Keyed = KeyedCollection;
-  Collection.Indexed = IndexedCollection;
-  Collection.Set = SetCollection;
-
-  var imul =
-    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
-    Math.imul :
-    function imul(a, b) {
-      a = a | 0; // int
-      b = b | 0; // int
-      var c = a & 0xffff;
-      var d = b & 0xffff;
-      // Shift by 0 fixes the sign on the high part.
-      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
-    };
-
-  // v8 has an optimization for storing 31-bit signed numbers.
-  // Values which have either 00 or 11 as the high order bits qualify.
-  // This function drops the highest order bit in a signed number, maintaining
-  // the sign bit.
-  function smi(i32) {
-    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
-  }
-
-  function hash(o) {
-    if (o === false || o === null || o === undefined) {
-      return 0;
-    }
-    if (typeof o.valueOf === 'function') {
-      o = o.valueOf();
-      if (o === false || o === null || o === undefined) {
-        return 0;
-      }
-    }
-    if (o === true) {
-      return 1;
-    }
-    var type = typeof o;
-    if (type === 'number') {
-      var h = o | 0;
-      if (h !== o) {
-        h ^= o * 0xFFFFFFFF;
-      }
-      while (o > 0xFFFFFFFF) {
-        o /= 0xFFFFFFFF;
-        h ^= o;
-      }
-      return smi(h);
-    }
-    if (type === 'string') {
-      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
-    }
-    if (typeof o.hashCode === 'function') {
-      return o.hashCode();
-    }
-    if (type === 'object') {
-      return hashJSObj(o);
-    }
-    if (typeof o.toString === 'function') {
-      return hashString(o.toString());
-    }
-    throw new Error('Value type ' + type + ' cannot be hashed.');
-  }
-
-  function cachedHashString(string) {
-    var hash = stringHashCache[string];
-    if (hash === undefined) {
-      hash = hashString(string);
-      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
-        STRING_HASH_CACHE_SIZE = 0;
-        stringHashCache = {};
-      }
-      STRING_HASH_CACHE_SIZE++;
-      stringHashCache[string] = hash;
-    }
-    return hash;
-  }
-
-  // http://jsperf.com/hashing-strings
-  function hashString(string) {
-    // This is the hash from JVM
-    // The hash code for a string is computed as
-    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
-    // where s[i] is the ith character of the string and n is the length of
-    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
-    // (exclusive) by dropping high bits.
-    var hash = 0;
-    for (var ii = 0; ii < string.length; ii++) {
-      hash = 31 * hash + string.charCodeAt(ii) | 0;
-    }
-    return smi(hash);
-  }
-
-  function hashJSObj(obj) {
-    var hash;
-    if (usingWeakMap) {
-      hash = weakMap.get(obj);
-      if (hash !== undefined) {
-        return hash;
-      }
-    }
-
-    hash = obj[UID_HASH_KEY];
-    if (hash !== undefined) {
-      return hash;
-    }
-
-    if (!canDefineProperty) {
-      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
-      if (hash !== undefined) {
-        return hash;
-      }
-
-      hash = getIENodeHash(obj);
-      if (hash !== undefined) {
-        return hash;
-      }
-    }
-
-    hash = ++objHashUID;
-    if (objHashUID & 0x40000000) {
-      objHashUID = 0;
-    }
-
-    if (usingWeakMap) {
-      weakMap.set(obj, hash);
-    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
-      throw new Error('Non-extensible objects are not allowed as keys.');
-    } else if (canDefineProperty) {
-      Object.defineProperty(obj, UID_HASH_KEY, {
-        'enumerable': false,
-        'configurable': false,
-        'writable': false,
-        'value': hash
-      });
-    } else if (obj.propertyIsEnumerable !== undefined &&
-               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
-      // Since we can't define a non-enumerable property on the object
-      // we'll hijack one of the less-used non-enumerable properties to
-      // save our hash on it. Since this is a function it will not show up in
-      // `JSON.stringify` which is what we want.
-      obj.propertyIsEnumerable = function() {
-        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
-      };
-      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
-    } else if (obj.nodeType !== undefined) {
-      // At this point we couldn't get the IE `uniqueID` to use as a hash
-      // and we couldn't use a non-enumerable property to exploit the
-      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
-      // itself.
-      obj[UID_HASH_KEY] = hash;
-    } else {
-      throw new Error('Unable to set a non-enumerable property on object.');
-    }
-
-    return hash;
-  }
-
-  // Get references to ES5 object methods.
-  var isExtensible = Object.isExtensible;
-
-  // True if Object.defineProperty works as expected. IE8 fails this test.
-  var canDefineProperty = (function() {
-    try {
-      Object.defineProperty({}, '@', {});
-      return true;
-    } catch (e) {
-      return false;
-    }
-  }());
-
-  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
-  // and avoid memory leaks from the IE cloneNode bug.
-  function getIENodeHash(node) {
-    if (node && node.nodeType > 0) {
-      switch (node.nodeType) {
-        case 1: // Element
-          return node.uniqueID;
-        case 9: // Document
-          return node.documentElement && node.documentElement.uniqueID;
-      }
-    }
-  }
-
-  // If possible, use a WeakMap.
-  var usingWeakMap = typeof WeakMap === 'function';
-  var weakMap;
-  if (usingWeakMap) {
-    weakMap = new WeakMap();
-  }
-
-  var objHashUID = 0;
-
-  var UID_HASH_KEY = '__immutablehash__';
-  if (typeof Symbol === 'function') {
-    UID_HASH_KEY = Symbol(UID_HASH_KEY);
-  }
-
-  var STRING_HASH_CACHE_MIN_STRLEN = 16;
-  var STRING_HASH_CACHE_MAX_SIZE = 255;
-  var STRING_HASH_CACHE_SIZE = 0;
-  var stringHashCache = {};
-
-  function assertNotInfinite(size) {
-    invariant(
-      size !== Infinity,
-      'Cannot perform this action with an infinite size.'
-    );
-  }
-
-  createClass(Map, KeyedCollection);
-
-    // @pragma Construction
-
-    function Map(value) {
-      return value === null || value === undefined ? emptyMap() :
-        isMap(value) && !isOrdered(value) ? value :
-        emptyMap().withMutations(function(map ) {
-          var iter = KeyedIterable(value);
-          assertNotInfinite(iter.size);
-          iter.forEach(function(v, k)  {return map.set(k, v)});
-        });
-    }
-
-    Map.prototype.toString = function() {
-      return this.__toString('Map {', '}');
-    };
-
-    // @pragma Access
-
-    Map.prototype.get = function(k, notSetValue) {
-      return this._root ?
-        this._root.get(0, undefined, k, notSetValue) :
-        notSetValue;
-    };
-
-    // @pragma Modification
-
-    Map.prototype.set = function(k, v) {
-      return updateMap(this, k, v);
-    };
-
-    Map.prototype.setIn = function(keyPath, v) {
-      return this.updateIn(keyPath, NOT_SET, function()  {return v});
-    };
-
-    Map.prototype.remove = function(k) {
-      return updateMap(this, k, NOT_SET);
-    };
-
-    Map.prototype.deleteIn = function(keyPath) {
-      return this.updateIn(keyPath, function()  {return NOT_SET});
-    };
-
-    Map.prototype.update = function(k, notSetValue, updater) {
-      return arguments.length === 1 ?
-        k(this) :
-        this.updateIn([k], notSetValue, updater);
-    };
-
-    Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
-      if (!updater) {
-        updater = notSetValue;
-        notSetValue = undefined;
-      }
-      var updatedValue = updateInDeepMap(
-        this,
-        forceIterator(keyPath),
-        notSetValue,
-        updater
-      );
-      return updatedValue === NOT_SET ? undefined : updatedValue;
-    };
-
-    Map.prototype.clear = function() {
-      if (this.size === 0) {
-        return this;
-      }
-      if (this.__ownerID) {
-        this.size = 0;
-        this._root = null;
-        this.__hash = undefined;
-        this.__altered = true;
-        return this;
-      }
-      return emptyMap();
-    };
-
-    // @pragma Composition
-
-    Map.prototype.merge = function(/*...iters*/) {
-      return mergeIntoMapWith(this, undefined, arguments);
-    };
-
-    Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
-      return mergeIntoMapWith(this, merger, iters);
-    };
-
-    Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
-      return this.updateIn(
-        keyPath,
-        emptyMap(),
-        function(m ) {return typeof m.merge === 'function' ?
-          m.merge.apply(m, iters) :
-          iters[iters.length - 1]}
-      );
-    };
-
-    Map.prototype.mergeDeep = function(/*...iters*/) {
-      return mergeIntoMapWith(this, deepMerger, arguments);
-    };
-
-    Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
-      return mergeIntoMapWith(this, deepMergerWith(merger), iters);
-    };
-
-    Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
-      return this.updateIn(
-        keyPath,
-        emptyMap(),
-        function(m ) {return typeof m.mergeDeep === 'function' ?
-          m.mergeDeep.apply(m, iters) :
-          iters[iters.length - 1]}
-      );
-    };
-
-    Map.prototype.sort = function(comparator) {
-      // Late binding
-      return OrderedMap(sortFactory(this, comparator));
-    };
-
-    Map.prototype.sortBy = function(mapper, comparator) {
-      // Late binding
-      return OrderedMap(sortFactory(this, comparator, mapper));
-    };
-
-    // @pragma Mutability
-
-    Map.prototype.withMutations = function(fn) {
-      var mutable = this.asMutable();
-      fn(mutable);
-      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
-    };
-
-    Map.prototype.asMutable = function() {
-      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
-    };
-
-    Map.prototype.asImmutable = function() {
-      return this.__ensureOwner();
-    };
-
-    Map.prototype.wasAltered = function() {
-      return this.__altered;
-    };
-
-    Map.prototype.__iterator = function(type, reverse) {
-      return new MapIterator(this, type, reverse);
-    };
-
-    Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
-      var iterations = 0;
-      this._root && this._root.iterate(function(entry ) {
-        iterations++;
-        return fn(entry[1], entry[0], this$0);
-      }, reverse);
-      return iterations;
-    };
-
-    Map.prototype.__ensureOwner = function(ownerID) {
-      if (ownerID === this.__ownerID) {
-        return this;
-      }
-      if (!ownerID) {
-        this.__ownerID = ownerID;
-        this.__altered = false;
-        return this;
-      }
-      return makeMap(this.size, this._root, ownerID, this.__hash);
-    };
-
-
-  function isMap(maybeMap) {
-    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
-  }
-
-  Map.isMap = isMap;
-
-  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';
-
-  var MapPrototype = Map.prototype;
-  MapPrototype[IS_MAP_SENTINEL] = true;
-  MapPrototype[DELETE] = MapPrototype.remove;
-  MapPrototype.removeIn = MapPrototype.deleteIn;
-
-
-  // #pragma Trie Nodes
-
-
-
-    function ArrayMapNode(ownerID, entries) {
-      this.ownerID = ownerID;
-      this.entries = entries;
-    }
-
-    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
-      var entries = this.entries;
-      for (var ii = 0, len = entries.length; ii < len; ii++) {
-        if (is(key, entries[ii][0])) {
-          return entries[ii][1];
-        }
-      }
-      return notSetValue;
-    };
-
-    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
-      var removed = value === NOT_SET;
-
-      var entries = this.entries;
-      var idx = 0;
-      for (var len = entries.length; idx < len; idx++) {
-        if (is(key, entries[idx][0])) {
-          break;
-        }
-      }
-      var exists = idx < len;
-
-      if (exists ? entries[idx][1] === value : removed) {
-        return this;
-      }
-
-      SetRef(didAlter);
-      (removed || !exists) && SetRef(didChangeSize);
-
-      if (removed && entries.length === 1) {
-        return; // undefined
-      }
-
-      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
-        return createNodes(ownerID, entries, key, value);
-      }
-
-      var isEditable = ownerID && ownerID === this.ownerID;
-      var newEntries = isEditable ? entries : arrCopy(entries);
-
-      if (exists) {
-        if (removed) {
-          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
-        } else {
-          newEntries[idx] = [key, value];
-        }
-      } else {
-        newEntries.push([key, value]);
-      }
-
-      if (isEditable) {
-        this.entries = newEntries;
-        return this;
-      }
-
-      return new ArrayMapNode(ownerID, newEntries);
-    };
-
-
-
-
-    function BitmapIndexedNode(ownerID, bitmap, nodes) {
-      this.ownerID = ownerID;
-      this.bitmap = bitmap;
-      this.nodes = nodes;
-    }
-
-    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
-      if (keyHash === undefined) {
-        keyHash = hash(key);
-      }
-      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
-      var bitmap = this.bitmap;
-      return (bitmap & bit) === 0 ? notSetValue :
-        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
-    };
-
-    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
-      if (keyHash === undefined) {
-        keyHash = hash(key);
-      }
-      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
-      var bit = 1 << keyHashFrag;
-      var bitmap = this.bitmap;
-      var exists = (bitmap & bit) !== 0;
-
-      if (!exists && value === NOT_SET) {
-        return this;
-      }
-
-      var idx = popCount(bitmap & (bit - 1));
-      var nodes = this.nodes;
-      var node = exists ? nodes[idx] : undefined;
-      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
-
-      if (newNode === node) {
-        return this;
-      }
-
-      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
-        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
-      }
-
-      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
-        return nodes[idx ^ 1];
-      }
-
-      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
-        return newNode;
-      }
-
-      var isEditable = ownerID && ownerID === this.ownerID;
-      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
-      var newNodes = exists ? newNode ?
-        setIn(nodes, idx, newNode, isEditable) :
-        spliceOut(nodes, idx, isEditable) :
-        spliceIn(nodes, idx, newNode, isEditable);
-
-      if (isEditable) {
-        this.bitmap = newBitmap;
-        this.nodes = newNodes;
-        return this;
-      }
-
-      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
-    };
-
-
-
-
-    function HashArrayMapNode(ownerID, count, nodes) {
-      this.ownerID = ownerID;
-      this.count = count;
-      this.nodes = nodes;
-    }
-
-    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
-      if (keyHash === undefined) {
-        keyHash = hash(key);
-      }
-      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
-      var node = this.nodes[idx];
-      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
-    };
-
-    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
-      if (keyHash === undefined) {
-        keyHash = hash(key);
-      }
-      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
-      var removed = value === NOT_SET;
-      var nodes = this.nodes;
-      var node = nodes[idx];
-
-      if (removed && !node) {
-        return this;
-      }
-
-      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
-      if (newNode === node) {
-        return this;
-      }
-
-      var newCount = this.count;
-      if (!node) {
-        newCount++;
-      } else if (!newNode) {
-        newCount--;
-        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
-          return packNodes(ownerID, nodes, newCount, idx);
-        }
-      }
-
-      var isEditable = ownerID && ownerID === this.ownerID;
-      var newNodes = setIn(nodes, idx, newNode, isEditable);
-
-      if (isEditable) {
-        this.count = newCount;
-        this.nodes = newNodes;
-        return this;
-      }
-
-      return new HashArrayMapNode(ownerID, newCount, newNodes);
-    };
-
-
-
-
-    function HashCollisionNode(ownerID, keyHash, entries) {
-      this.ownerID = ownerID;
-      this.keyHash = keyHash;
-      this.entries = entries;
-    }
-
-    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
-      var entries = this.entries;
-      for (var ii = 0, len = entries.length; ii < len; ii++) {
-        if (is(key, entries[ii][0])) {
-          return entries[ii][1];
-        }
-      }
-      return notSetValue;
-    };
-
-    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
-      if (keyHash === undefined) {
-        keyHash = hash(key);
-      }
-
-      var removed = value === NOT_SET;
-
-      if (keyHash !== this.keyHash) {
-        if (removed) {
-          return this;
-        }
-        SetRef(didAlter);
-        SetRef(didChangeSize);
-        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
-      }
-
-      var entries = this.entries;
-      var idx = 0;
-      for (var len = entries.length; idx < len; idx++) {
-        if (is(key, entries[idx][0])) {
-          break;
-        }
-      }
-      var exists = idx < len;
-
-      if (exists ? entries[idx][1] === value : removed) {
-        return this;
-      }
-
-      SetRef(didAlter);
-      (removed || !exists) && SetRef(didChangeSize);
-
-      if (removed && len === 2) {
-        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
-      }
-
-      var isEditable = ownerID && ownerID === this.ownerID;
-      var newEntries = isEditable ? entries : arrCopy(entries);
-
-      if (exists) {
-        if (removed) {
-          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
-        } else {
-          newEntries[idx] = [key, value];
-        }
-      } else {
-        newEntries.push([key, value]);
-      }
-
-      if (isEditable) {
-        this.entries = newEntries;
-        return this;
-      }
-
-      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
-    };
-
-
-
-
-    function ValueNode(ownerID, keyHash, entry) {
-      this.ownerID = ownerID;
-      this.keyHash = keyHash;
-      this.entry = entry;
-    }
-
-    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
-      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
-    };
-
-    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
-      var removed = value === NOT_SET;
-      var keyMatch = is(key, this.entry[0]);
-      if (keyMatch ? value === this.entry[1] : removed) {
-        return this;
-      }
-
-      SetRef(didAlter);
-
-      if (removed) {
-        SetRef(didChangeSize);
-        return; // undefined
-      }
-
-      if (keyMatch) {
-        if (ownerID && ownerID === this.ownerID) {
-          this.entry[1] = value;
-          return this;
-        }
-        return new ValueNode(ownerID, this.keyHash, [key, value]);
-      }
-
-      SetRef(didChangeSize);
-      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
-    };
-
-
-
-  // #pragma Iterators
-
-  ArrayMapNode.prototype.iterate =
-  HashCollisionNode.prototype.iterate = function (fn, reverse) {
-    var entries = this.entries;
-    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
-      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
-        return false;
-      }
-    }
-  }
-
-  BitmapIndexedNode.prototype.iterate =
-  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
-    var nodes = this.nodes;
-    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
-      var node = nodes[reverse ? maxIndex - ii : ii];
-      if (node && node.iterate(fn, reverse) === false) {
-        return false;
-      }
-    }
-  }
-
-  ValueNode.prototype.iterate = function (fn, reverse) {
-    return fn(this.entry);
-  }
-
-  createClass(MapIterator, Iterator);
-
-    function MapIterator(map, type, reverse) {
-      this._type = type;
-      this._reverse = reverse;
-      this._stack = map._root && mapIteratorFrame(map._root);
-    }
-
-    MapIterator.prototype.next = function() {
-      var type = this._type;
-      var stack = this._stack;
-      while (stack) {
-        var node = stack.node;
-        var index = stack.index++;
-        var maxIndex;
-        if (node.entry) {
-          if (index === 0) {
-            return mapIteratorValue(type, node.entry);
-          }
-        } else if (node.entries) {
-          maxIndex = node.entries.length - 1;
-          if (index <= maxIndex) {
-            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
-          }
-        } else {
-          maxIndex = node.nodes.length - 1;
-          if (index <= maxIndex) {
-            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
-            if (subNode) {
-              if (subNode.entry) {
-                return mapIteratorValue(type, subNode.entry);
-              }
-              stack = this._stack = mapIteratorFrame(subNode, stack);
-            }
-            continue;
-          }
-        }
-        stack = this._stack = this._stack.__prev;
-      }
-      return iteratorDone();
-    };
-
-
-  function mapIteratorValue(type, entry) {
-    return iteratorValue(type, entry[0], entry[1]);
-  }
-
-  function mapIteratorFrame(node, prev) {
-    return {
-      node: node,
-      index: 0,
-      __prev: prev
-    };
-  }
-
-  function makeMap(size, root, ownerID, hash) {
-    var map = Object.create(MapPrototype);
-    map.size = size;
-    map._root = root;
-    map.__ownerID = ownerID;
-    map.__hash = hash;
-    map.__altered = false;
-    return map;
-  }
-
-  var EMPTY_MAP;
-  function emptyMap() {
-    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
-  }
-
-  function updateMap(map, k, v) {
-    var newRoot;
-    var newSize;
-    if (!map._root) {
-      if (v === NOT_SET) {
-        return map;
-      }
-      newSize = 1;
-      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
-    } else {
-      var didChangeSize = MakeRef(CHANGE_LENGTH);
-      var didAlter = MakeRef(DID_ALTER);
-      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
-      if (!didAlter.value) {
-        return map;
-      }
-      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
-    }
-    if (map.__ownerID) {
-      map.size = newSize;
-      map._root = newRoot;
-      map.__hash = undefined;
-      map.__altered = true;
-      return map;
-    }
-    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
-  }
-
-  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
-    if (!node) {
-      if (value === NOT_SET) {
-        return node;
-      }
-      SetRef(didAlter);
-      SetRef(didChangeSize);
-      return new ValueNode(ownerID, keyHash, [key, value]);
-    }
-    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
-  }
-
-  function isLeafNode(node) {
-    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
-  }
-
-  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
-    if (node.keyHash === keyHash) {
-      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
-    }
-
-    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
-    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
-
-    var newNode;
-    var nodes = idx1 === idx2 ?
-      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
-      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);
-
-    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
-  }
-
-  function createNodes(ownerID, entries, key, value) {
-    if (!ownerID) {
-      ownerID = new OwnerID();
-    }
-    var node = new ValueNode(ownerID, hash(key), [key, value]);
-    for (var ii = 0; ii < entries.length; ii++) {
-      var entry = entries[ii];
-      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
-    }
-    return node;
-  }
-
-  function packNodes(ownerID, nodes, count, excluding) {
-    var bitmap = 0;
-    var packedII = 0;
-    var packedNodes = new Array(count);
-    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
-      var node = nodes[ii];
-      if (node !== undefined && ii !== excluding) {
-        bitmap |= bit;
-        packedNodes[packedII++] = node;
-      }
-    }
-    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
-  }
-
-  function expandNodes(ownerID, nodes, bitmap, including, node) {
-    var count = 0;
-    var expandedNodes = new Array(SIZE);
-    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
-      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
-    }
-    expandedNodes[including] = node;
-    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
-  }
-
-  function mergeIntoMapWith(map, merger, iterables) {
-    var iters = [];
-    for (var ii = 0; ii < iterables.length; ii++) {
-      var value = iterables[ii];
-      var iter = KeyedIterable(value);
-      if (!isIterable(value)) {
-        iter = iter.map(function(v ) {return fromJS(v)});
-      }
-      iters.push(iter);
-    }
-    return mergeIntoCollectionWith(map, merger, iters);
-  }
-
-  function deepMerger(existing, value, key) {
-    return existing && existing.mergeDeep && isIterable(value) ?
-      existing.mergeDeep(value) :
-      is(existing, value) ? existing : value;
-  }
-
-  function deepMergerWith(merger) {
-    return function(existing, value, key)  {
-      if (existing && existing.mergeDeepWith && isIterable(value)) {
-        return existing.mergeDeepWith(merger, value);
-      }
-      var nextValue = merger(existing, value, key);
-      return is(existing, nextValue) ? existing : nextValue;
-    };
-  }
-
-  function mergeIntoCollectionWith(collection, merger, iters) {
-    iters = iters.filter(function(x ) {return x.size !== 0});
-    if (iters.length === 0) {
-      return collection;
-    }
-    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
-      return collection.constructor(iters[0]);
-    }
-    return collection.withMutations(function(collection ) {
-      var mergeIntoMap = merger ?
-        function(value, key)  {
-          collection.update(key, NOT_SET, function(existing )
-            {return existing === NOT_SET ? value : merger(existing, value, key)}
-          );
-        } :
-        function(value, key)  {
-          collection.set(key, value);
-        }
-      for (var ii = 0; ii < iters.length; ii++) {
-        iters[ii].forEach(mergeIntoMap);
-      }
-    });
-  }
-
-  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
-    var isNotSet = existing === NOT_SET;
-    var step = keyPathIter.next();
-    if (step.done) {
-      var existingValue = isNotSet ? notSetValue : existing;
-      var newValue = updater(existingValue);
-      return newValue === existingValue ? existing : newValue;
-    }
-    invariant(
-      isNotSet || (existing && existing.set),
-      'invalid keyPath'
-    );
-    var key = step.value;
-    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
-    var nextUpdated = updateInDeepMap(
-      nextExisting,
-      keyPathIter,
-      notSetValue,
-      updater
-    );
-    return nextUpdated === nextExisting ? existing :
-      nextUpdated === NOT_SET ? existing.remove(key) :
-      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
-  }
-
-  function popCount(x) {
-    x = x - ((x >> 1) & 0x55555555);
-    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
-    x = (x + (x >> 4)) & 0x0f0f0f0f;
-    x = x + (x >> 8);
-    x = x + (x >> 16);
-    return x & 0x7f;
-  }
-
-  function setIn(array, idx, val, canEdit) {
-    var newArray = canEdit ? array : arrCopy(array);
-    newArray[idx] = val;
-    return newArray;
-  }
-
-  function spliceIn(array, idx, val, canEdit) {
-    var newLen = array.length + 1;
-    if (canEdit && idx + 1 === newLen) {
-      array[idx] = val;
-      return array;
-    }
-    var newArray = new Array(newLen);
-    var after = 0;
-    for (var ii = 0; ii < newLen; ii++) {
-      if (ii === idx) {
-        newArray[ii] = val;
-        after = -1;
-      } else {
-        newArray[ii] = array[ii + after];
-      }
-    }
-    return newArray;
-  }
-
-  function spliceOut(array, idx, canEdit) {
-    var newLen = array.length - 1;
-    if (canEdit && idx === newLen) {
-      array.pop();
-      return array;
-    }
-    var newArray = new Array(newLen);
-    var after = 0;
-    for (var ii = 0; ii < newLen; ii++) {
-      if (ii === idx) {
-        after = 1;
-      }
-      newArray[ii] = array[ii + after];
-    }
-    return newArray;
-  }
-
-  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
-  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
-  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;
-
-  createClass(List, IndexedCollection);
-
-    // @pragma Construction
-
-    function List(value) {
-      var empty = emptyList();
-      if (value === null || value === undefined) {
-        return empty;
-      }
-      if (isList(value)) {
-        return value;
-      }
-      var iter = IndexedIterable(value);
-      var size = iter.size;
-      if (size === 0) {
-        return empty;
-      }
-      assertNotInfinite(size);
-      if (size > 0 && size < SIZE) {
-        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
-      }
-      return empty.withMutations(function(list ) {
-        list.setSize(size);
-        iter.forEach(function(v, i)  {return list.set(i, v)});
-      });
-    }
-
-    List.of = function(/*...values*/) {
-      return this(arguments);
-    };
-
-    List.prototype.toString = function() {
-      return this.__toString('List [', ']');
-    };
-
-    // @pragma Access
-
-    List.prototype.get = function(index, notSetValue) {
-      index = wrapIndex(this, index);
-      if (index >= 0 && index < this.size) {
-        index += this._origin;
-        var node = listNodeFor(this, index);
-        return node && node.array[index & MASK];
-      }
-      return notSetValue;
-    };
-
-    // @pragma Modification
-
-    List.prototype.set = function(index, value) {
-      return updateList(this, index, value);
-    };
-
-    List.prototype.remove = function(index) {
-      return !this.has(index) ? this :
-        index === 0 ? this.shift() :
-        index === this.size - 1 ? this.pop() :
-        this.splice(index, 1);
-    };
-
-    List.prototype.insert = function(index, value) {
-      return this.splice(index, 0, value);
-    };
-
-    List.prototype.clear = function() {
-      if (this.size === 0) {
-        return this;
-      }
-      if (this.__ownerID) {
-        this.size = this._origin = this._capacity = 0;
-        this._level = SHIFT;
-        this._root = this._tail = null;
-        this.__hash = undefined;
-        this.__altered = true;
-        return this;
-      }
-      return emptyList();
-    };
-
-    List.prototype.push = function(/*...values*/) {
-      var values = arguments;
-      var oldSize = this.size;
-      return this.withMutations(function(list ) {
-        setListBounds(list, 0, oldSize + values.length);
-        for (var ii = 0; ii < values.length; ii++) {
-          list.set(oldSize + ii, values[ii]);
-        }
-      });
-    };
-
-    List.prototype.pop = function() {
-      return setListBounds(this, 0, -1);
-    };
-
-    List.prototype.unshift = function(/*...values*/) {
-      var values = arguments;
-      return this.withMutations(function(list ) {
-        setListBounds(list, -values.length);
-        for (var ii = 0; ii < values.length; ii++) {
-          list.set(ii, values[ii]);
-        }
-      });
-    };
-
-    List.prototype.shift = function() {
-      return setListBounds(this, 1);
-    };
-
-    // @pragma Composition
-
-    List.prototype.merge = function(/*...iters*/) {
-      return mergeIntoListWith(this, undefined, arguments);
-    };
-
-    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
-      return mergeIntoListWith(this, merger, iters);
-    };
-
-    List.prototype.mergeDeep = function(/*...iters*/) {
-      return mergeIntoListWith(this, deepMerger, arguments);
-    };
-
-    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
-      return mergeIntoListWith(this, deepMergerWith(merger), iters);
-    };
-
-    List.prototype.setSize = function(size) {
-      return setListBounds(this, 0, size);
-    };
-
-    // @pragma Iteration
-
-    List.prototype.slice = function(begin, end) {
-      var size = this.size;
-      if (wholeSlice(begin, end, size)) {
-        return this;
-      }
-      return setListBounds(
-        this,
-        resolveBegin(begin, size),
-        resolveEnd(end, size)
-      );
-    };
-
-    List.prototype.__iterator = function(type, reverse) {
-      var index = 0;
-      var values = iterateList(this, reverse);
-      return new Iterator(function()  {
-        var value = values();
-        return value === DONE ?
-          iteratorDone() :
-          iteratorValue(type, index++, value);
-      });
-    };
-
-    List.prototype.__iterate = function(fn, reverse) {
-      var index = 0;
-      var values = iterateList(this, reverse);
-      var value;
-      while ((value = values()) !== DONE) {
-        if (fn(value, index++, this) === false) {
-          break;
-        }
-      }
-      return index;
-    };
-
-    List.prototype.__ensureOwner = function(ownerID) {
-      if (ownerID === this.__ownerID) {
-        return this;
-      }
-      if (!ownerID) {
-        this.__ownerID = ownerID;
-        return this;
-      }
-      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
-    };
-
-
-  function isList(maybeList) {
-    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
-  }
-
-  List.isList = isList;
-
-  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';
-
-  var ListPrototype = List.prototype;
-  ListPrototype[IS_LIST_SENTINEL] = true;
-  ListPrototype[DELETE] = ListPrototype.remove;
-  ListPrototype.setIn = MapPrototype.setIn;
-  ListPrototype.deleteIn =
-  ListPrototype.removeIn = MapPrototype.removeIn;
-  ListPrototype.update = MapPrototype.update;
-  ListPrototype.updateIn = MapPrototype.updateIn;
-  ListPrototype.mergeIn = MapPrototype.mergeIn;
-  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
-  ListPrototype.withMutations = MapPrototype.withMutations;
-  ListPrototype.asMutable = MapPrototype.asMutable;
-  ListPrototype.asImmutable = MapPrototype.asImmutable;
-  ListPrototype.wasAltered = MapPrototype.wasAltered;
-
-
-
-    function VNode(array, ownerID) {
-      this.array = array;
-      this.ownerID = ownerID;
-    }
-
-    // TODO: seems like these methods are very similar
-
-    VNode.prototype.removeBefore = function(ownerID, level, index) {
-      if (index === level ? 1 << level : 0 || this.array.length === 0) {
-        return this;
-      }
-      var originIndex = (index >>> level) & MASK;
-      if (originIndex >= this.array.length) {
-        return new VNode([], ownerID);
-      }
-      var removingFirst = originIndex === 0;
-      var newChild;
-      if (level > 0) {
-        var oldChild = this.array[originIndex];
-        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
-        if (newChild === oldChild && removingFirst) {
-          return this;
-        }
-      }
-      if (removingFirst && !newChild) {
-        return this;
-      }
-      var editable = editableVNode(this, ownerID);
-      if (!removingFirst) {
-        for (var ii = 0; ii < originIndex; ii++) {
-          editable.array[ii] = undefined;
-        }
-      }
-      if (newChild) {
-        editable.array[originIndex] = newChild;
-      }
-      return editable;
-    };
-
-    VNode.prototype.removeAfter = function(ownerID, level, index) {
-      if (index === (level ? 1 << level : 0) || this.array.length === 0) {
-        return this;
-      }
-      var sizeIndex = ((index - 1) >>> level) & MASK;
-      if (sizeIndex >= this.array.length) {
-        return this;
-      }
-
-      var newChild;
-      if (level > 0) {
-        var oldChild = this.array[sizeIndex];
-        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
-        if (newChild === oldChild && sizeIndex === this.array.length - 1) {
-          return this;
-        }
-      }
-
-      var editable = editableVNode(this, ownerID);
-      editable.array.splice(sizeIndex + 1);
-      if (newChild) {
-        editable.array[sizeIndex] = newChild;
-      }
-      return editable;
-    };
-
-
-
-  var DONE = {};
-
-  function iterateList(list, reverse) {
-    var left = list._origin;
-    var right = list._capacity;
-    var tailPos = getTailOffset(right);
-    var tail = list._tail;
-
-    return iterateNodeOrLeaf(list._root, list._level, 0);
-
-    function iterateNodeOrLeaf(node, level, offset) {
-      return level === 0 ?
-        iterateLeaf(node, offset) :
-        iterateNode(node, level, offset);
-    }
-
-    function iterateLeaf(node, offset) {
-      var array = offset === tailPos ? tail && tail.array : node && node.array;
-      var from = offset > left ? 0 : left - offset;
-      var to = right - offset;
-      if (to > SIZE) {
-        to = SIZE;
-      }
-      return function()  {
-        if (from === to) {
-          return DONE;
-        }
-        var idx = reverse ? --to : from++;
-        return array && array[idx];
-      };
-    }
-
-    function iterateNode(node, level, offset) {
-      var values;
-      var array = node && node.array;
-      var from = offset > left ? 0 : (left - offset) >> level;
-      var to = ((right - offset) >> level) + 1;
-      if (to > SIZE) {
-        to = SIZE;
-      }
-      return function()  {
-        do {
-          if (values) {
-            var value = values();
-            if (value !== DONE) {
-              return value;
-            }
-            values = null;
-          }
-          if (from === to) {
-            return DONE;
-          }
-          var idx = reverse ? --to : from++;
-          values = iterateNodeOrLeaf(
-            array && array[idx], level - SHIFT, offset + (idx << level)
-          );
-        } while (true);
-      };
-    }
-  }
-
-  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
-    var list = Object.create(ListPrototype);
-    list.size = capacity - origin;
-    list._origin = origin;
-    list._capacity = capacity;
-    list._level = level;
-    list._root = root;
-    list._tail = tail;
-    list.__ownerID = ownerID;
-    list.__hash = hash;
-    list.__altered = false;
-    return list;
-  }
-
-  var EMPTY_LIST;
-  function emptyList() {
-    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
-  }
-
-  function updateList(list, index, value) {
-    index = wrapIndex(list, index);
-
-    if (index !== index) {
-      return list;
-    }
-
-    if (index >= list.size || index < 0) {
-      return list.withMutations(function(list ) {
-        index < 0 ?
-          setListBounds(list, index).set(0, value) :
-          setListBounds(list, 0, index + 1).set(index, value)
-      });
-    }
-
-    index += list._origin;
-
-    var newTail = list._tail;
-    var newRoot = list._root;
-    var didAlter = MakeRef(DID_ALTER);
-    if (index >= getTailOffset(list._capacity)) {
-      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
-    } else {
-      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
-    }
-
-    if (!didAlter.value) {
-      return list;
-    }
-
-    if (list.__ownerID) {
-      list._root = newRoot;
-      list._tail = newTail;
-      list.__hash = undefined;
-      list.__altered = true;
-      return list;
-    }
-    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
-  }
-
-  function updateVNode(node, ownerID, level, index, value, didAlter) {
-    var idx = (index >>> level) & MASK;
-    var nodeHas = node && idx < node.array.length;
-    if (!nodeHas && value === undefined) {
-      return node;
-    }
-
-    var newNode;
-
-    if (level > 0) {
-      var lowerNode = node && node.array[idx];
-      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
-      if (newLowerNode === lowerNode) {
-        return node;
-      }
-      newNode = editableVNode(node, ownerID);
-      newNode.array[idx] = newLowerNode;
-      return newNode;
-    }
-
-    if (nodeHas && node.array[idx] === value) {
-      return node;
-    }
-
-    SetRef(didAlter);
-
-    newNode = editableVNode(node, ownerID);
-    if (value === undefined && idx === newNode.array.length - 1) {
-      newNode.array.pop();
-    } else {
-      newNode.array[idx] = value;
-    }
-    return newNode;
-  }
-
-  function editableVNode(node, ownerID) {
-    if (ownerID && node && ownerID === node.ownerID) {
-      return node;
-    }
-    return new VNode(node ? node.array.slice() : [], ownerID);
-  }
-
-  function listNodeFor(list, rawIndex) {
-    if (rawIndex >= getTailOffset(list._capacity)) {
-      return list._tail;
-    }
-    if (rawIndex < 1 << (list._level + SHIFT)) {
-      var node = list._root;
-      var level = list._level;
-      while (node && level > 0) {
-        node = node.array[(rawIndex >>> level) & MASK];
-        level -= SHIFT;
-      }
-      return node;
-    }
-  }
-
-  function setListBounds(list, begin, end) {
-    // Sanitize begin & end using this shorthand for ToInt32(argument)
-    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
-    if (begin !== undefined) {
-      begin = begin | 0;
-    }
-    if (end !== undefined) {
-      end = end | 0;
-    }
-    var owner = list.__ownerID || new OwnerID();
-    var oldOrigin = list._origin;
-    var oldCapacity = list._capacity;
-    var newOrigin = oldOrigin + begin;
-    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
-    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
-      return list;
-    }
-
-    // If it's going to end after it starts, it's empty.
-    if (newOrigin >= newCapacity) {
-      return list.clear();
-    }
-
-    var newLevel = list._level;
-    var newRoot = list._root;
-
-    // New origin might need creating a higher root.
-    var offsetShift = 0;
-    while (newOrigin + offsetShift < 0) {
-      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
-      newLevel += SHIFT;
-      offsetShift += 1 << newLevel;
-    }
-    if (offsetShift) {
-      newOrigin += offsetShift;
-      oldOrigin += offsetShift;
-      newCapacity += offsetShift;
-      oldCapacity += offsetShift;
-    }
-
-    var oldTailOffset = getTailOffset(oldCapacity);
-    var newTailOffset = getTailOffset(newCapacity);
-
-    // New size might need creating a higher root.
-    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
-      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
-      newLevel += SHIFT;
-    }
-
-    // Locate or create the new tail.
-    var oldTail = list._tail;
-    var newTail = newTailOffset < oldTailOffset ?
-      listNodeFor(list, newCapacity - 1) :
-      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;
-
-    // Merge Tail into tree.
-    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
-      newRoot = editableVNode(newRoot, owner);
-      var node = newRoot;
-      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
-        var idx = (oldTailOffset >>> level) & MASK;
-        node = node.array[idx] = editableVNode(node.array[idx], owner);
-      }
-      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
-    }
-
-    // If the size has been reduced, there's a chance the tail needs to be trimmed.
-    if (newCapacity < oldCapacity) {
-      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
-    }
-
-    // If the new origin is within the tail, then we do not need a root.
-    if (newOrigin >= newTailOffset) {
-      newOrigin -= newTailOffset;
-      newCapacity -= newTailOffset;
-      newLevel = SHIFT;
-      newRoot = null;
-      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);
-
-    // Otherwise, if the root has been trimmed, garbage collect.
-    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
-      offsetShift = 0;
-
-      // Identify the new top root node of the subtree of the old root.
-      while (newRoot) {
-        var beginIndex = (newOrigin >>> newLevel) & MASK;
-        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
-          break;
-        }
-        if (beginIndex) {
-          offsetShift += (1 << newLevel) * beginIndex;
-        }
-        newLevel -= SHIFT;
-        newRoot = newRoot.array[beginIndex];
-      }
-
-      // Trim the new sides of the new root.
-      if (newRoot && newOrigin > oldOrigin) {
-        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
-      }
-      if (newRoot && newTailOffset < oldTailOffset) {
-        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
-      }
-      if (offsetShift) {
-        newOrigin -= offsetShift;
-        newCapacity -= offsetShift;
-      }
-    }
-
-    if (list.__ownerID) {
-      list.size = newCapacity - newOrigin;
-      list._origin = newOrigin;
-      list._capacity = newCapacity;
-      list._level = newLevel;
-      list._root = newRoot;
-      list._tail = newTail;
-      list.__hash = undefined;
-      list.__altered = true;
-      return list;
-    }
-    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
-  }
-
-  function mergeIntoListWith(list, merger, iterables) {
-    var iters = [];
-    var maxSize = 0;
-    for (var ii = 0; ii < iterables.length; ii++) {
-      var value = iterables[ii];
-      var iter = IndexedIterable(value);
-      if (iter.size > maxSize) {
-        maxSize = iter.size;
-      }
-      if (!isIterable(value)) {
-        iter = iter.map(function(v ) {return fromJS(v)});
-      }
-      iters.push(iter);
-    }
-    if (maxSize > list.size) {
-      list = list.setSize(maxSize);
-    }
-    return mergeIntoCollectionWith(list, merger, iters);
-  }
-
-  function getTailOffset(size) {
-    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
-  }
-
-  createClass(OrderedMap, Map);
-
-    // @pragma Construction
-
-    function OrderedMap(value) {
-      return value === null || value === undefined ? emptyOrderedMap() :
-        isOrderedMap(value) ? value :
-        emptyOrderedMap().withMutations(function(map ) {
-          var iter = KeyedIterable(value);
-          assertNotInfinite(iter.size);
-          iter.forEach(function(v, k)  {return map.set(k, v)});
-        });
-    }
-
-    OrderedMap.of = function(/*...values*/) {
-      return this(arguments);
-    };
-
-    OrderedMap.prototype.toString = function() {
-      return this.__toString('OrderedMap {', '}');
-    };
-
-    // @pragma Access
-
-    OrderedMap.prototype.get = function(k, notSetValue) {
-      var index = this._map.get(k);
-      return index !== undefined ? this._list.get(index)[1] : notSetValue;
-    };
-
-    // @pragma Modification
-
-    OrderedMap.prototype.clear = function() {
-      if (this.size === 0) {
-        return this;
-      }
-      if (this.__ownerID) {
-        this.size = 0;
-        this._map.clear();
-        this._list.clear();
-        return this;
-      }
-      return emptyOrderedMap();
-    };
-
-    OrderedMap.prototype.set = function(k, v) {
-      return updateOrderedMap(this, k, v);
-    };
-
-    OrderedMap.prototype.remove = function(k) {
-      return updateOrderedMap(this, k, NOT_SET);
-    };
-
-    OrderedMap.prototype.wasAltered = function() {
-      return this._map.wasAltered() || this._list.wasAltered();
-    };
-
-    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
-      return this._list.__iterate(
-        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
-        reverse
-      );
-    };
-
-    OrderedMap.prototype.__iterator = function(type, reverse) {
-      return this._list.fromEntrySeq().__iterator(type, reverse);
-    };
-
-    OrderedMap.prototype.__ensureOwner = function(ownerID) {
-      if (ownerID === this.__ownerID) {
-        return this;
-      }
-      var newMap = this._map.__ensureOwner(ownerID);
-      var newList = this._list.__ensureOwner(ownerID);
-      if (!ownerID) {
-        this.__ownerID = ownerID;
-        this._map = newMap;
-        this._list = newList;
-        return this;
-      }
-      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
-    };
-
-
-  function isOrderedMap(maybeOrderedMap) {
-    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
-  }
-
-  OrderedMap.isOrderedMap = isOrderedMap;
-
-  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
-  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;
-
-
-
-  function makeOrderedMap(map, list, ownerID, hash) {
-    var omap = Object.create(OrderedMap.prototype);
-    omap.size = map ? map.size : 0;
-    omap._map = map;
-    omap._list = list;
-    omap.__ownerID = ownerID;
-    omap.__hash = hash;
-    return omap;
-  }
-
-  var EMPTY_ORDERED_MAP;
-  function emptyOrderedMap() {
-    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
-  }
-
-  function updateOrderedMap(omap, k, v) {
-    var map = omap._map;
-    var list = omap._list;
-    var i = map.get(k);
-    var has = i !== undefined;
-    var newMap;
-    var newList;
-    if (v === NOT_SET) { // removed
-      if (!has) {
-        return omap;
-      }
-      if (list.size >= SIZE && list.size >= map.size * 2) {
-        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
-        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
-        if (omap.__ownerID) {
-          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
-        }
-      } else {
-        newMap = map.remove(k);
-        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
-      }
-    } else {
-      if (has) {
-        if (v === list.get(i)[1]) {
-          return omap;
-        }
-        newMap = map;
-        newList = list.set(i, [k, v]);
-      } else {
-        newMap = map.set(k, list.size);
-        newList = list.set(list.size, [k, v]);
-      }
-    }
-    if (omap.__ownerID) {
-      omap.size = newMap.size;
-      omap._map = newMap;
-      omap._list = newList;
-      omap.__hash = undefined;
-      return omap;
-    }
-    return makeOrderedMap(newMap, newList);
-  }
-
-  createClass(ToKeyedSequence, KeyedSeq);
-    function ToKeyedSequence(indexed, useKeys) {
-      this._iter = indexed;
-      this._useKeys = useKeys;
-      this.size = indexed.size;
-    }
-
-    ToKeyedSequence.prototype.get = function(key, notSetValue) {
-      return this._iter.get(key, notSetValue);
-    };
-
-    ToKeyedSequence.prototype.has = function(key) {
-      return this._iter.has(key);
-    };
-
-    ToKeyedSequence.prototype.valueSeq = function() {
-      return this._iter.valueSeq();
-    };
-
-    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
-      var reversedSequence = reverseFactory(this, true);
-      if (!this._useKeys) {
-        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
-      }
-      return reversedSequence;
-    };
-
-    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
-      var mappedSequence = mapFactory(this, mapper, context);
-      if (!this._useKeys) {
-        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
-      }
-      return mappedSequence;
-    };
-
-    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
-      var ii;
-      return this._iter.__iterate(
-        this._useKeys ?
-          function(v, k)  {return fn(v, k, this$0)} :
-          ((ii = reverse ? resolveSize(this) : 0),
-            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
-        reverse
-      );
-    };
-
-    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
-      if (this._useKeys) {
-        return this._iter.__iterator(type, reverse);
-      }
-      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
-      var ii = reverse ? resolveSize(this) : 0;
-      return new Iterator(function()  {
-        var step = iterator.next();
-        return step.done ? step :
-          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
-      });
-    };
-
-  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;
-
-
-  createClass(ToIndexedSequence, IndexedSeq);
-    function ToIndexedSequence(iter) {
-      this._iter = iter;
-      this.size = iter.size;
-    }
-
-    ToIndexedSequence.prototype.includes = function(value) {
-      return this._iter.includes(value);
-    };
-
-    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
-      var iterations = 0;
-      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
-    };
-
-    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
-      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
-      var iterations = 0;
-      return new Iterator(function()  {
-        var step = iterator.next();
-        return step.done ? step :
-          iteratorValue(type, iterations++, step.value, step)
-      });
-    };
-
-
-
-  createClass(ToSetSequence, SetSeq);
-    function ToSetSequence(iter) {
-      this._iter = iter;
-      this.size = iter.size;
-    }
-
-    ToSetSequence.prototype.has = function(key) {
-      return this._iter.includes(key);
-    };
-
-    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
-      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
-    };
-
-    ToSetSequence.prototype.__iterator = function(type, reverse) {
-      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
-      return new Iterator(function()  {
-        var step = iterator.next();
-        return step.done ? step :
-          iteratorValue(type, step.value, step.value, step);
-      });
-    };
-
-
-
-  createClass(FromEntriesSequence, KeyedSeq);
-    function FromEntriesSequence(entries) {
-      this._iter = entries;
-      this.size = entries.size;
-    }
-
-    FromEntriesSequence.prototype.entrySeq = function() {
-      return this._iter.toSeq();
-    };
-
-    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
-      return this._iter.__iterate(function(entry ) {
-        // Check if entry exists first so array access doesn't throw for holes
-        // in the parent iteration.
-        if (entry) {
-          validateEntry(entry);
-          var indexedIterable = isIterable(entry);
-          return fn(
-            indexedIterable ? entry.get(1) : entry[1],
-            indexedIterable ? entry.get(0) : entry[0],
-            this$0
-          );
-        }
-      }, reverse);
-    };
-
-    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
-      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
-      return new Iterator(function()  {
-        while (true) {
-          var step = iterator.next();
-          if (step.done) {
-            return step;
-          }
-          var entry = step.value;
-          // Check if entry exists first so array access doesn't throw for holes
-          // in the parent iteration.
-          if (entry) {
-            validateEntry(entry);
-            var indexedIterable = isIterable(entry);
-            return iteratorValue(
-              type,
-              indexedIterable ? entry.get(0) : entry[0],
-              indexedIterable ? entry.get(1) : entry[1],
-              step
-            );
-          }
-        }
-      });
-    };
-
-
-  ToIndexedSequence.prototype.cacheResult =
-  ToKeyedSequence.prototype.cacheResult =
-  ToSetSequence.prototype.cacheResult =
-  FromEntriesSequence.prototype.cacheResult =
-    cacheResultThrough;
-
-
-  function flipFactory(iterable) {
-    var flipSequence = makeSequence(iterable);
-    flipSequence._iter = iterable;
-    flipSequence.size = iterable.size;
-    flipSequence.flip = function()  {return iterable};
-    flipSequence.reverse = function () {
-      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
-      reversedSequence.flip = function()  {return iterable.reverse()};
-      return reversedSequence;
-    };
-    flipSequence.has = function(key ) {return iterable.includes(key)};
-    flipSequence.includes = function(key ) {return iterable.has(key)};
-    flipSequence.cacheResult = cacheResultThrough;
-    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
-      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
-    }
-    flipSequence.__iteratorUncached = function(type, reverse) {
-      if (type === ITERATE_ENTRIES) {
-        var iterator = iterable.__iterator(type, reverse);
-        return new Iterator(function()  {
-          var step = iterator.next();
-          if (!step.done) {
-            var k = step.value[0];
-            step.value[0] = step.value[1];
-            step.value[1] = k;
-          }
-          return step;
-        });
-      }
-      return iterable.__iterator(
-        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
-        reverse
-      );
-    }
-    return flipSequence;
-  }
-
-
-  function mapFactory(iterable, mapper, context) {
-    var mappedSequence = makeSequence(iterable);
-    mappedSequence.size = iterable.size;
-    mappedSequence.has = function(key ) {return iterable.has(key)};
-    mappedSequence.get = function(key, notSetValue)  {
-      var v = iterable.get(key, NOT_SET);
-      return v === NOT_SET ?
-        notSetValue :
-        mapper.call(context, v, key, iterable);
-    };
-    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
-      return iterable.__iterate(
-        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
-        reverse
-      );
-    }
-    mappedSequence.__iteratorUncached = function (type, reverse) {
-      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
-      return new Iterator(function()  {
-        var step = iterator.next();
-        if (step.done) {
-          return step;
-        }
-        var entry = step.value;
-        var key = entry[0];
-        return iteratorValue(
-          type,
-          key,
-          mapper.call(context, entry[1], key, iterable),
-          step
-        );
-      });
-    }
-    return mappedSequence;
-  }
-
-
-  function reverseFactory(iterable, useKeys) {
-    var reversedSequence = makeSequence(iterable);
-    reversedSequence._iter = iterable;
-    reversedSequence.size = iterable.size;
-    reversedSequence.reverse = function()  {return iterable};
-    if (iterable.flip) {
-      reversedSequence.flip = function () {
-        var flipSequence = flipFactory(iterable);
-        flipSequence.reverse = function()  {return iterable.flip()};
-        return flipSequence;
-      };
-    }
-    reversedSequence.get = function(key, notSetValue) 
-      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
-    reversedSequence.has = function(key )
-      {return iterable.has(useKeys ? key : -1 - key)};
-    reversedSequence.includes = function(value ) {return iterable.includes(value)};
-    reversedSequence.cacheResult = cacheResultThrough;
-    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
-      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
-    };
-    reversedSequence.__iterator =
-      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
-    return reversedSequence;
-  }
-
-
-  function filterFactory(iterable, predicate, context, useKeys) {
-    var filterSequence = makeSequence(iterable);
-    if (useKeys) {
-      filterSequence.has = function(key ) {
-        var v = iterable.get(key, NOT_SET);
-        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
-      };
-      filterSequence.get = function(key, notSetValue)  {
-        var v = iterable.get(key, NOT_SET);
-        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
-          v : notSetValue;
-      };
-    }
-    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
-      var iterations = 0;
-      iterable.__iterate(function(v, k, c)  {
-        if (predicate.call(context, v, k, c)) {
-          iterations++;
-          return fn(v, useKeys ? k : iterations - 1, this$0);
-        }
-      }, reverse);
-      return iterations;
-    };
-    filterSequence.__iteratorUncached = function (type, reverse) {
-      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
-      var iterations = 0;
-      return new Iterator(function()  {
-        while (true) {
-          var step = iterator.next();
-          if (step.done) {
-            return step;
-          }
-          var entry = step.value;
-          var key = entry[0];
-          var value = entry[1];
-          if (predicate.call(context, value, key, iterable)) {
-            return iteratorValue(type, useKeys ? key : iterations++, value, step);
-          }
-        }
-      });
-    }
-    return filterSequence;
-  }
-
-
-  function countByFactory(iterable, grouper, context) {
-    var groups = Map().asMutable();
-    iterable.__iterate(function(v, k)  {
-      groups.update(
-        grouper.call(context, v, k, iterable),
-        0,
-        function(a ) {return a + 1}
-      );
-    });
-    return groups.asImmutable();
-  }
-
-
-  function groupByFactory(iterable, grouper, context) {
-    var isKeyedIter = isKeyed(iterable);
-    var groups = (isOrdered(iterable) ? OrderedMap() : Map()).asMutable();
-    iterable.__iterate(function(v, k)  {
-      groups.update(
-        grouper.call(context, v, k, iterable),
-        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
-      );
-    });
-    var coerce = iterableClass(iterable);
-    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
-  }
-
-
-  function sliceFactory(iterable, begin, end, useKeys) {
-    var originalSize = iterable.size;
-
-    // Sanitize begin & end using this shorthand for ToInt32(argument)
-    // http://www.ecma-international.org/ecma-262/6.0/#sec-toint32
-    if (begin !== undefined) {
-      begin = begin | 0;
-    }
-    if (end !== undefined) {
-      end = end | 0;
-    }
-
-    if (wholeSlice(begin, end, originalSize)) {
-      return iterable;
-    }
-
-    var resolvedBegin = resolveBegin(begin, originalSize);
-    var resolvedEnd = resolveEnd(end, originalSize);
-
-    // begin or end will be NaN if they were provided as negative numbers and
-    // this iterable's size is unknown. In that case, cache first so there is
-    // a known size and these do not resolve to NaN.
-    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
-      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
-    }
-
-    // Note: resolvedEnd is undefined when the original sequence's length is
-    // unknown and this slice did not supply an end and should contain all
-    // elements after resolvedBegin.
-    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
-    var resolvedSize = resolvedEnd - resolvedBegin;
-    var sliceSize;
-    if (resolvedSize === resolvedSize) {
-      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
-    }
-
-    var sliceSeq = makeSequence(iterable);
-
-    // If iterable.size is undefined, the size of the realized sliceSeq is
-    // unknown at this point unless the number of items to slice is 0
-    sliceSeq.size = sliceSize === 0 ? sliceSize : iterable.size && sliceSize || undefined;
-
-    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
-      sliceSeq.get = function (index, notSetValue) {
-        index = wrapIndex(this, index);
-        return index >= 0 && index < sliceSize ?
-          iterable.get(index + resolvedBegin, notSetValue) :
-          notSetValue;
-      }
-    }
-
-    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
-      if (sliceSize === 0) {
-        return 0;
-      }
-      if (reverse) {
-        return this.cacheResult().__iterate(fn, reverse);
-      }
-      var skipped = 0;
-      var isSkipping = true;
-      var iterations = 0;
-      iterable.__iterate(function(v, k)  {
-        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
-          iterations++;
-          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
-                 iterations !== sliceSize;
-        }
-      });
-      return iterations;
-    };
-
-    sliceSeq.__iteratorUncached = function(type, reverse) {
-      if (sliceSize !== 0 && reverse) {
-        return this.cacheResult().__iterator(type, reverse);
-      }
-      // Don't bother instantiating parent iterator if taking 0.
-      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
-      var skipped = 0;
-      var iterations = 0;
-      return new Iterator(function()  {
-        while (skipped++ < resolvedBegin) {
-          iterator.next();
-        }
-        if (++iterations > sliceSize) {
-          return iteratorDone();
-        }
-        var step = iterator.next();
-        if (useKeys || type === ITERATE_VALUES) {
-          return step;
-        } else if (type === ITERATE_KEYS) {
-          return iteratorValue(type, iterations - 1, undefined, step);
-        } else {
-          return iteratorValue(type, iterations - 1, step.value[1], step);
-        }
-      });
-    }
-
-    return sliceSeq;
-  }
-
-
-  function takeWhileFactory(iterable, predicate, context) {
-    var takeSequence = makeSequence(iterable);
-    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
-      if (reverse) {
-        return this.cacheResult().__iterate(fn, reverse);
-      }
-      var iterations = 0;
-      iterable.__iterate(function(v, k, c) 
-        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
-      );
-      return iterations;
-    };
-    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
-      if (reverse) {
-        return this.cacheResult().__iterator(type, reverse);
-      }
-      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
-      var iterating = true;
-      return new Iterator(function()  {
-        if (!iterating) {
-          return iteratorDone();
-        }
-        var step = iterator.next();
-        if (step.done) {
-          return step;
-        }
-        var entry = step.value;
-        var k = entry[0];
-        var v = entry[1];
-        if (!predicate.call(context, v, k, this$0)) {
-          iterating = false;
-          return iteratorDone();
-        }
-        return type === ITERATE_ENTRIES ? step :
-          iteratorValue(type, k, v, step);
-      });
-    };
-    return takeSequence;
-  }
-
-
-  function skipWhileFactory(iterable, predicate, context, useKeys) {
-    var skipSequence = makeSequence(iterable);
-    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
-      if (reverse) {
-        return this.cacheResult().__iterate(fn, reverse);
-      }
-      var isSkipping = true;
-      var iterations = 0;
-      iterable.__iterate(function(v, k, c)  {
-        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
-          iterations++;
-          return fn(v, useKeys ? k : iterations - 1, this$0);
-        }
-      });
-      return iterations;
-    };
-    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
-      if (reverse) {
-        return this.cacheResult().__iterator(type, reverse);
-      }
-      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
-      var skipping = true;
-      var iterations = 0;
-      return new Iterator(function()  {
-        var step, k, v;
-        do {
-          step = iterator.next();
-          if (step.done) {
-            if (useKeys || type === ITERATE_VALUES) {
-              return step;
-            } else if (type === ITERATE_KEYS) {
-              return iteratorValue(type, iterations++, undefined, step);
-            } else {
-              return iteratorValue(type, iterations++, step.value[1], step);
-            }
-          }
-          var entry = step.value;
-          k = entry[0];
-          v = entry[1];
-          skipping && (skipping = predicate.call(context, v, k, this$0));
-        } while (skipping);
-        return type === ITERATE_ENTRIES ? step :
-          iteratorValue(type, k, v, step);
-      });
-    };
-    return skipSequence;
-  }
-
-
-  function concatFactory(iterable, values) {
-    var isKeyedIterable = isKeyed(iterable);
-    var iters = [iterable].concat(values).map(function(v ) {
-      if (!isIterable(v)) {
-        v = isKeyedIterable ?
-          keyedSeqFromValue(v) :
-          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
-      } else if (isKeyedIterable) {
-        v = KeyedIterable(v);
-      }
-      return v;
-    }).filter(function(v ) {return v.size !== 0});
-
-    if (iters.length === 0) {
-      return iterable;
-    }
-
-    if (iters.length === 1) {
-      var singleton = iters[0];
-      if (singleton === iterable ||
-          isKeyedIterable && isKeyed(singleton) ||
-          isIndexed(iterable) && isIndexed(singleton)) {
-        return singleton;
-      }
-    }
-
-    var concatSeq = new ArraySeq(iters);
-    if (isKeyedIterable) {
-      concatSeq = concatSeq.toKeyedSeq();
-    } else if (!isIndexed(iterable)) {
-      concatSeq = concatSeq.toSetSeq();
-    }
-    concatSeq = concatSeq.flatten(true);
-    concatSeq.size = iters.reduce(
-      function(sum, seq)  {
-        if (sum !== undefined) {
-          var size = seq.size;
-          if (size !== undefined) {
-            return sum + size;
-          }
-        }
-      },
-      0
-    );
-    return concatSeq;
-  }
-
-
-  function flattenFactory(iterable, depth, useKeys) {
-    var flatSequence = makeSequence(iterable);
-    flatSequence.__iterateUncached = function(fn, reverse) {
-      var iterations = 0;
-      var stopped = false;
-      function flatDeep(iter, currentDepth) {var this$0 = this;
-        iter.__iterate(function(v, k)  {
-          if ((!depth || currentDepth < depth) && isIterable(v)) {
-            flatDeep(v, currentDepth + 1);
-          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
-            stopped = true;
-          }
-          return !stopped;
-        }, reverse);
-      }
-      flatDeep(iterable, 0);
-      return iterations;
-    }
-    flatSequence.__iteratorUncached = function(type, reverse) {
-      var iterator = iterable.__iterator(type, reverse);
-      var stack = [];
-      var iterations = 0;
-      return new Iterator(function()  {
-        while (iterator) {
-          var step = iterator.next();
-          if (step.done !== false) {
-            iterator = stack.pop();
-            continue;
-          }
-          var v = step.value;
-          if (type === ITERATE_ENTRIES) {
-            v = v[1];
-          }
-          if ((!depth || stack.length < depth) && isIterable(v)) {
-            stack.push(iterator);
-            iterator = v.__iterator(type, reverse);
-          } else {
-            return useKeys ? step : iteratorValue(type, iterations++, v, step);
-          }
-        }
-        return iteratorDone();
-      });
-    }
-    return flatSequence;
-  }
-
-
-  function flatMapFactory(iterable, mapper, context) {
-    var coerce = iterableClass(iterable);
-    return iterable.toSeq().map(
-      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
-    ).flatten(true);
-  }
-
-
-  function interposeFactory(iterable, separator) {
-    var interposedSequence = makeSequence(iterable);
-    interposedSequence.size = iterable.size && iterable.size * 2 -1;
-    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
-      var iterations = 0;
-      iterable.__iterate(function(v, k) 
-        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
-        fn(v, iterations++, this$0) !== false},
-        reverse
-      );
-      return iterations;
-    };
-    interposedSequence.__iteratorUncached = function(type, reverse) {
-      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
-      var iterations = 0;
-      var step;
-      return new Iterator(function()  {
-        if (!step || iterations % 2) {
-          step = iterator.next();
-          if (step.done) {
-            return step;
-          }
-        }
-        return iterations % 2 ?
-          iteratorValue(type, iterations++, separator) :
-          iteratorValue(type, iterations++, step.value, step);
-      });
-    };
-    return interposedSequence;
-  }
-
-
-  function sortFactory(iterable, comparator, mapper) {
-    if (!comparator) {
-      comparator = defaultComparator;
-    }
-    var isKeyedIterable = isKeyed(iterable);
-    var index = 0;
-    var entries = iterable.toSeq().map(
-      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
-    ).toArray();
-    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
-      isKeyedIterable ?
-      function(v, i)  { entries[i].length = 2; } :
-      function(v, i)  { entries[i] = v[1]; }
-    );
-    return isKeyedIterable ? KeyedSeq(entries) :
-      isIndexed(iterable) ? IndexedSeq(entries) :
-      SetSeq(entries);
-  }
-
-
-  function maxFactory(iterable, comparator, mapper) {
-    if (!comparator) {
-      comparator = defaultComparator;
-    }
-    if (mapper) {
-      var entry = iterable.toSeq()
-        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
-        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
-      return entry && entry[0];
-    } else {
-      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
-    }
-  }
-
-  function maxCompare(comparator, a, b) {
-    var comp = comparator(b, a);
-    // b is considered the new max if the comparator declares them equal, but
-    // they are not equal and b is in fact a nullish value.
-    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
-  }
-
-
-  function zipWithFactory(keyIter, zipper, iters) {
-    var zipSequence = makeSequence(keyIter);
-    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
-    // Note: this a generic base implementation of __iterate in terms of
-    // __iterator which may be more generically useful in the future.
-    zipSequence.__iterate = function(fn, reverse) {
-      /* generic:
-      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
-      var step;
-      var iterations = 0;
-      while (!(step = iterator.next()).done) {
-        iterations++;
-        if (fn(step.value[1], step.value[0], this) === false) {
-          break;
-        }
-      }
-      return iterations;
-      */
-      // indexed:
-      var iterator = this.__iterator(ITERATE_VALUES, reverse);
-      var step;
-      var iterations = 0;
-      while (!(step = iterator.next()).done) {
-        if (fn(step.value, iterations++, this) === false) {
-          break;
-        }
-      }
-      return iterations;
-    };
-    zipSequence.__iteratorUncached = function(type, reverse) {
-      var iterators = iters.map(function(i )
-        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
-      );
-      var iterations = 0;
-      var isDone = false;
-      return new Iterator(function()  {
-        var steps;
-        if (!isDone) {
-          steps = iterators.map(function(i ) {return i.next()});
-          isDone = steps.some(function(s ) {return s.done});
-        }
-        if (isDone) {
-          return iteratorDone();
-        }
-        return iteratorValue(
-          type,
-          iterations++,
-          zipper.apply(null, steps.map(function(s ) {return s.value}))
-        );
-      });
-    };
-    return zipSequence
-  }
-
-
-  // #pragma Helper Functions
-
-  function reify(iter, seq) {
-    return isSeq(iter) ? seq : iter.constructor(seq);
-  }
-
-  function validateEntry(entry) {
-    if (entry !== Object(entry)) {
-      throw new TypeError('Expected [K, V] tuple: ' + entry);
-    }
-  }
-
-  function resolveSize(iter) {
-    assertNotInfinite(iter.size);
-    return ensureSize(iter);
-  }
-
-  function iterableClass(iterable) {
-    return isKeyed(iterable) ? KeyedIterable :
-      isIndexed(iterable) ? IndexedIterable :
-      SetIterable;
-  }
-
-  function makeSequence(iterable) {
-    return Object.create(
-      (
-        isKeyed(iterable) ? KeyedSeq :
-        isIndexed(iterable) ? IndexedSeq :
-        SetSeq
-      ).prototype
-    );
-  }
-
-  function cacheResultThrough() {
-    if (this._iter.cacheResult) {
-      this._iter.cacheResult();
-      this.size = this._iter.size;
-      return this;
-    } else {
-      return Seq.prototype.cacheResult.call(this);
-    }
-  }
-
-  function defaultComparator(a, b) {
-    return a > b ? 1 : a < b ? -1 : 0;
-  }
-
-  function forceIterator(keyPath) {
-    var iter = getIterator(keyPath);
-    if (!iter) {
-      // Array might not be iterable in this environment, so we need a fallback
-      // to our wrapped type.
-      if (!isArrayLike(keyPath)) {
-        throw new TypeError('Expected iterable or array-like: ' + keyPath);
-      }
-      iter = getIterator(Iterable(keyPath));
-    }
-    return iter;
-  }
-
-  createClass(Record, KeyedCollection);
-
-    function Record(defaultValues, name) {
-      var hasInitialized;
-
-      var RecordType = function Record(values) {
-        if (values instanceof RecordType) {
-          return values;
-        }
-        if (!(this instanceof RecordType)) {
-          return new RecordType(values);
-        }
-        if (!hasInitialized) {
-          hasInitialized = true;
-          var keys = Object.keys(defaultValues);
-          setProps(RecordTypePrototype, keys);
-          RecordTypePrototype.size = keys.length;
-          RecordTypePrototype._name = name;
-          RecordTypePrototype._keys = keys;
-          RecordTypePrototype._defaultValues = defaultValues;
-        }
-        this._map = Map(values);
-      };
-
-      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
-      RecordTypePrototype.constructor = RecordType;
-
-      return RecordType;
-    }
-
-    Record.prototype.toString = function() {
-      return this.__toString(recordName(this) + ' {', '}');
-    };
-
-    // @pragma Access
-
-    Record.prototype.has = function(k) {
-      return this._defaultValues.hasOwnProperty(k);
-    };
-
-    Record.prototype.get = function(k, notSetValue) {
-      if (!this.has(k)) {
-        return notSetValue;
-      }
-      var defaultVal = this._defaultValues[k];
-      return this._map ? this._map.get(k, defaultVal) : defaultVal;
-    };
-
-    // @pragma Modification
-
-    Record.prototype.clear = function() {
-      if (this.__ownerID) {
-        this._map && this._map.clear();
-        return this;
-      }
-      var RecordType = this.constructor;
-      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
-    };
-
-    Record.prototype.set = function(k, v) {
-      if (!this.has(k)) {
-        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
-      }
-      var newMap = this._map && this._map.set(k, v);
-      if (this.__ownerID || newMap === this._map) {
-        return this;
-      }
-      return makeRecord(this, newMap);
-    };
-
-    Record.prototype.remove = function(k) {
-      if (!this.has(k)) {
-        return this;
-      }
-      var newMap = this._map && this._map.remove(k);
-      if (this.__ownerID || newMap === this._map) {
-        return this;
-      }
-      return makeRecord(this, newMap);
-    };
-
-    Record.prototype.wasAltered = function() {
-      return this._map.wasAltered();
-    };
-
-    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
-      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
-    };
-
-    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
-      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
-    };
-
-    Record.prototype.__ensureOwner = function(ownerID) {
-      if (ownerID === this.__ownerID) {
-        return this;
-      }
-      var newMap = this._map && this._map.__ensureOwner(ownerID);
-      if (!ownerID) {
-        this.__ownerID = ownerID;
-        this._map = newMap;
-        return this;
-      }
-      return makeRecord(this, newMap, ownerID);
-    };
-
-
-  var RecordPrototype = Record.prototype;
-  RecordPrototype[DELETE] = RecordPrototype.remove;
-  RecordPrototype.deleteIn =
-  RecordPrototype.removeIn = MapPrototype.removeIn;
-  RecordPrototype.merge = MapPrototype.merge;
-  RecordPrototype.mergeWith = MapPrototype.mergeWith;
-  RecordPrototype.mergeIn = MapPrototype.mergeIn;
-  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
-  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
-  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
-  RecordPrototype.setIn = MapPrototype.setIn;
-  RecordPrototype.update = MapPrototype.update;
-  RecordPrototype.updateIn = MapPrototype.updateIn;
-  RecordPrototype.withMutations = MapPrototype.withMutations;
-  RecordPrototype.asMutable = MapPrototype.asMutable;
-  RecordPrototype.asImmutable = MapPrototype.asImmutable;
-
-
-  function makeRecord(likeRecord, map, ownerID) {
-    var record = Object.create(Object.getPrototypeOf(likeRecord));
-    record._map = map;
-    record.__ownerID = ownerID;
-    return record;
-  }
-
-  function recordName(record) {
-    return record._name || record.constructor.name || 'Record';
-  }
-
-  function setProps(prototype, names) {
-    try {
-      names.forEach(setProp.bind(undefined, prototype));
-    } catch (error) {
-      // Object.defineProperty failed. Probably IE8.
-    }
-  }
-
-  function setProp(prototype, name) {
-    Object.defineProperty(prototype, name, {
-      get: function() {
-        return this.get(name);
-      },
-      set: function(value) {
-        invariant(this.__ownerID, 'Cannot set on an immutable record.');
-        this.set(name, value);
-      }
-    });
-  }
-
-  createClass(Set, SetCollection);
-
-    // @pragma Construction
-
-    function Set(value) {
-      return value === null || value === undefined ? emptySet() :
-        isSet(value) && !isOrdered(value) ? value :
-        emptySet().withMutations(function(set ) {
-          var iter = SetIterable(value);
-          assertNotInfinite(iter.size);
-          iter.forEach(function(v ) {return set.add(v)});
-        });
-    }
-
-    Set.of = function(/*...values*/) {
-      return this(arguments);
-    };
-
-    Set.fromKeys = function(value) {
-      return this(KeyedIterable(value).keySeq());
-    };
-
-    Set.prototype.toString = function() {
-      return this.__toString('Set {', '}');
-    };
-
-    // @pragma Access
-
-    Set.prototype.has = function(value) {
-      return this._map.has(value);
-    };
-
-    // @pragma Modification
-
-    Set.prototype.add = function(value) {
-      return updateSet(this, this._map.set(value, true));
-    };
-
-    Set.prototype.remove = function(value) {
-      return updateSet(this, this._map.remove(value));
-    };
-
-    Set.prototype.clear = function() {
-      return updateSet(this, this._map.clear());
-    };
-
-    // @pragma Composition
-
-    Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
-      iters = iters.filter(function(x ) {return x.size !== 0});
-      if (iters.length === 0) {
-        return this;
-      }
-      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
-        return this.constructor(iters[0]);
-      }
-      return this.withMutations(function(set ) {
-        for (var ii = 0; ii < iters.length; ii++) {
-          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
-        }
-      });
-    };
-
-    Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
-      if (iters.length === 0) {
-        return this;
-      }
-      iters = iters.map(function(iter ) {return SetIterable(iter)});
-      var originalSet = this;
-      return this.withMutations(function(set ) {
-        originalSet.forEach(function(value ) {
-          if (!iters.every(function(iter ) {return iter.includes(value)})) {
-            set.remove(value);
-          }
-        });
-      });
-    };
-
-    Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
-      if (iters.length === 0) {
-        return this;
-      }
-      iters = iters.map(function(iter ) {return SetIterable(iter)});
-      var originalSet = this;
-      return this.withMutations(function(set ) {
-        originalSet.forEach(function(value ) {
-          if (iters.some(function(iter ) {return iter.includes(value)})) {
-            set.remove(value);
-          }
-        });
-      });
-    };
-
-    Set.prototype.merge = function() {
-      return this.union.apply(this, arguments);
-    };
-
-    Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
-      return this.union.apply(this, iters);
-    };
-
-    Set.prototype.sort = function(comparator) {
-      // Late binding
-      return OrderedSet(sortFactory(this, comparator));
-    };
-
-    Set.prototype.sortBy = function(mapper, comparator) {
-      // Late binding
-      return OrderedSet(sortFactory(this, comparator, mapper));
-    };
-
-    Set.prototype.wasAltered = function() {
-      return this._map.wasAltered();
-    };
-
-    Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
-      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
-    };
-
-    Set.prototype.__iterator = function(type, reverse) {
-      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
-    };
-
-    Set.prototype.__ensureOwner = function(ownerID) {
-      if (ownerID === this.__ownerID) {
-        return this;
-      }
-      var newMap = this._map.__ensureOwner(ownerID);
-      if (!ownerID) {
-        this.__ownerID = ownerID;
-        this._map = newMap;
-        return this;
-      }
-      return this.__make(newMap, ownerID);
-    };
-
-
-  function isSet(maybeSet) {
-    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
-  }
-
-  Set.isSet = isSet;
-
-  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';
-
-  var SetPrototype = Set.prototype;
-  SetPrototype[IS_SET_SENTINEL] = true;
-  SetPrototype[DELETE] = SetPrototype.remove;
-  SetPrototype.mergeDeep = SetPrototype.merge;
-  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
-  SetPrototype.withMutations = MapPrototype.withMutations;
-  SetPrototype.asMutable = MapPrototype.asMutable;
-  SetPrototype.asImmutable = MapPrototype.asImmutable;
-
-  SetPrototype.__empty = emptySet;
-  SetPrototype.__make = makeSet;
-
-  function updateSet(set, newMap) {
-    if (set.__ownerID) {
-      set.size = newMap.size;
-      set._map = newMap;
-      return set;
-    }
-    return newMap === set._map ? set :
-      newMap.size === 0 ? set.__empty() :
-      set.__make(newMap);
-  }
-
-  function makeSet(map, ownerID) {
-    var set = Object.create(SetPrototype);
-    set.size = map ? map.size : 0;
-    set._map = map;
-    set.__ownerID = ownerID;
-    return set;
-  }
-
-  var EMPTY_SET;
-  function emptySet() {
-    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
-  }
-
-  createClass(OrderedSet, Set);
-
-    // @pragma Construction
-
-    function OrderedSet(value) {
-      return value === null || value === undefined ? emptyOrderedSet() :
-        isOrderedSet(value) ? value :
-        emptyOrderedSet().withMutations(function(set ) {
-          var iter = SetIterable(value);
-          assertNotInfinite(iter.size);
-          iter.forEach(function(v ) {return set.add(v)});
-        });
-    }
-
-    OrderedSet.of = function(/*...values*/) {
-      return this(arguments);
-    };
-
-    OrderedSet.fromKeys = function(value) {
-      return this(KeyedIterable(value).keySeq());
-    };
-
-    OrderedSet.prototype.toString = function() {
-      return this.__toString('OrderedSet {', '}');
-    };
-
-
-  function isOrderedSet(maybeOrderedSet) {
-    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
-  }
-
-  OrderedSet.isOrderedSet = isOrderedSet;
-
-  var OrderedSetPrototype = OrderedSet.prototype;
-  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;
-
-  OrderedSetPrototype.__empty = emptyOrderedSet;
-  OrderedSetPrototype.__make = makeOrderedSet;
-
-  function makeOrderedSet(map, ownerID) {
-    var set = Object.create(OrderedSetPrototype);
-    set.size = map ? map.size : 0;
-    set._map = map;
-    set.__ownerID = ownerID;
-    return set;
-  }
-
-  var EMPTY_ORDERED_SET;
-  function emptyOrderedSet() {
-    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
-  }
-
-  createClass(Stack, IndexedCollection);
-
-    // @pragma Construction
-
-    function Stack(value) {
-      return value === null || value === undefined ? emptyStack() :
-        isStack(value) ? value :
-        emptyStack().unshiftAll(value);
-    }
-
-    Stack.of = function(/*...values*/) {
-      return this(arguments);
-    };
-
-    Stack.prototype.toString = function() {
-      return this.__toString('Stack [', ']');
-    };
-
-    // @pragma Access
-
-    Stack.prototype.get = function(index, notSetValue) {
-      var head = this._head;
-      index = wrapIndex(this, index);
-      while (head && index--) {
-        head = head.next;
-      }
-      return head ? head.value : notSetValue;
-    };
-
-    Stack.prototype.peek = function() {
-      return this._head && this._head.value;
-    };
-
-    // @pragma Modification
-
-    Stack.prototype.push = function(/*...values*/) {
-      if (arguments.length === 0) {
-        return this;
-      }
-      var newSize = this.size + arguments.length;
-      var head = this._head;
-      for (var ii = arguments.length - 1; ii >= 0; ii--) {
-        head = {
-          value: arguments[ii],
-          next: head
-        };
-      }
-      if (this.__ownerID) {
-        this.size = newSize;
-        this._head = head;
-        this.__hash = undefined;
-        this.__altered = true;
-        return this;
-      }
-      return makeStack(newSize, head);
-    };
-
-    Stack.prototype.pushAll = function(iter) {
-      iter = IndexedIterable(iter);
-      if (iter.size === 0) {
-        return this;
-      }
-      assertNotInfinite(iter.size);
-      var newSize = this.size;
-      var head = this._head;
-      iter.reverse().forEach(function(value ) {
-        newSize++;
-        head = {
-          value: value,
-          next: head
-        };
-      });
-      if (this.__ownerID) {
-        this.size = newSize;
-        this._head = head;
-        this.__hash = undefined;
-        this.__altered = true;
-        return this;
-      }
-      return makeStack(newSize, head);
-    };
-
-    Stack.prototype.pop = function() {
-      return this.slice(1);
-    };
-
-    Stack.prototype.unshift = function(/*...values*/) {
-      return this.push.apply(this, arguments);
-    };
-
-    Stack.prototype.unshiftAll = function(iter) {
-      return this.pushAll(iter);
-    };
-
-    Stack.prototype.shift = function() {
-      return this.pop.apply(this, arguments);
-    };
-
-    Stack.prototype.clear = function() {
-      if (this.size === 0) {
-        return this;
-      }
-      if (this.__ownerID) {
-        this.size = 0;
-        this._head = undefined;
-        this.__hash = undefined;
-        this.__altered = true;
-        return this;
-      }
-      return emptyStack();
-    };
-
-    Stack.prototype.slice = function(begin, end) {
-      if (wholeSlice(begin, end, this.size)) {
-        return this;
-      }
-      var resolvedBegin = resolveBegin(begin, this.size);
-      var resolvedEnd = resolveEnd(end, this.size);
-      if (resolvedEnd !== this.size) {
-        // super.slice(begin, end);
-        return IndexedCollection.prototype.slice.call(this, begin, end);
-      }
-      var newSize = this.size - resolvedBegin;
-      var head = this._head;
-      while (resolvedBegin--) {
-        head = head.next;
-      }
-      if (this.__ownerID) {
-        this.size = newSize;
-        this._head = head;
-        this.__hash = undefined;
-        this.__altered = true;
-        return this;
-      }
-      return makeStack(newSize, head);
-    };
-
-    // @pragma Mutability
-
-    Stack.prototype.__ensureOwner = function(ownerID) {
-      if (ownerID === this.__ownerID) {
-        return this;
-      }
-      if (!ownerID) {
-        this.__ownerID = ownerID;
-        this.__altered = false;
-        return this;
-      }
-      return makeStack(this.size, this._head, ownerID, this.__hash);
-    };
-
-    // @pragma Iteration
-
-    Stack.prototype.__iterate = function(fn, reverse) {
-      if (reverse) {
-        return this.reverse().__iterate(fn);
-      }
-      var iterations = 0;
-      var node = this._head;
-      while (node) {
-        if (fn(node.value, iterations++, this) === false) {
-          break;
-        }
-        node = node.next;
-      }
-      return iterations;
-    };
-
-    Stack.prototype.__iterator = function(type, reverse) {
-      if (reverse) {
-        return this.reverse().__iterator(type);
-      }
-      var iterations = 0;
-      var node = this._head;
-      return new Iterator(function()  {
-        if (node) {
-          var value = node.value;
-          node = node.next;
-          return iteratorValue(type, iterations++, value);
-        }
-        return iteratorDone();
-      });
-    };
-
-
-  function isStack(maybeStack) {
-    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
-  }
-
-  Stack.isStack = isStack;
-
-  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';
-
-  var StackPrototype = Stack.prototype;
-  StackPrototype[IS_STACK_SENTINEL] = true;
-  StackPrototype.withMutations = MapPrototype.withMutations;
-  StackPrototype.asMutable = MapPrototype.asMutable;
-  StackPrototype.asImmutable = MapPrototype.asImmutable;
-  StackPrototype.wasAltered = MapPrototype.wasAltered;
-
-
-  function makeStack(size, head, ownerID, hash) {
-    var map = Object.create(StackPrototype);
-    map.size = size;
-    map._head = head;
-    map.__ownerID = ownerID;
-    map.__hash = hash;
-    map.__altered = false;
-    return map;
-  }
-
-  var EMPTY_STACK;
-  function emptyStack() {
-    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
-  }
-
-  /**
-   * Contributes additional methods to a constructor
-   */
-  function mixin(ctor, methods) {
-    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
-    Object.keys(methods).forEach(keyCopier);
-    Object.getOwnPropertySymbols &&
-      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
-    return ctor;
-  }
-
-  Iterable.Iterator = Iterator;
-
-  mixin(Iterable, {
-
-    // ### Conversion to other types
-
-    toArray: function() {
-      assertNotInfinite(this.size);
-      var array = new Array(this.size || 0);
-      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
-      return array;
-    },
-
-    toIndexedSeq: function() {
-      return new ToIndexedSequence(this);
-    },
-
-    toJS: function() {
-      return this.toSeq().map(
-        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
-      ).__toJS();
-    },
-
-    toJSON: function() {
-      return this.toSeq().map(
-        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
-      ).__toJS();
-    },
-
-    toKeyedSeq: function() {
-      return new ToKeyedSequence(this, true);
-    },
-
-    toMap: function() {
-      // Use Late Binding here to solve the circular dependency.
-      return Map(this.toKeyedSeq());
-    },
-
-    toObject: function() {
-      assertNotInfinite(this.size);
-      var object = {};
-      this.__iterate(function(v, k)  { object[k] = v; });
-      return object;
-    },
-
-    toOrderedMap: function() {
-      // Use Late Binding here to solve the circular dependency.
-      return OrderedMap(this.toKeyedSeq());
-    },
-
-    toOrderedSet: function() {
-      // Use Late Binding here to solve the circular dependency.
-      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
-    },
-
-    toSet: function() {
-      // Use Late Binding here to solve the circular dependency.
-      return Set(isKeyed(this) ? this.valueSeq() : this);
-    },
-
-    toSetSeq: function() {
-      return new ToSetSequence(this);
-    },
-
-    toSeq: function() {
-      return isIndexed(this) ? this.toIndexedSeq() :
-        isKeyed(this) ? this.toKeyedSeq() :
-        this.toSetSeq();
-    },
-
-    toStack: function() {
-      // Use Late Binding here to solve the circular dependency.
-      return Stack(isKeyed(this) ? this.valueSeq() : this);
-    },
-
-    toList: function() {
-      // Use Late Binding here to solve the circular dependency.
-      return List(isKeyed(this) ? this.valueSeq() : this);
-    },
-
-
-    // ### Common JavaScript methods and properties
-
-    toString: function() {
-      return '[Iterable]';
-    },
-
-    __toString: function(head, tail) {
-      if (this.size === 0) {
-        return head + tail;
-      }
-      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
-    },
-
-
-    // ### ES6 Collection methods (ES6 Array and Map)
-
-    concat: function() {var values = SLICE$0.call(arguments, 0);
-      return reify(this, concatFactory(this, values));
-    },
-
-    includes: function(searchValue) {
-      return this.some(function(value ) {return is(value, searchValue)});
-    },
-
-    entries: function() {
-      return this.__iterator(ITERATE_ENTRIES);
-    },
-
-    every: function(predicate, context) {
-      assertNotInfinite(this.size);
-      var returnValue = true;
-      this.__iterate(function(v, k, c)  {
-        if (!predicate.call(context, v, k, c)) {
-          returnValue = false;
-          return false;
-        }
-      });
-      return returnValue;
-    },
-
-    filter: function(predicate, context) {
-      return reify(this, filterFactory(this, predicate, context, true));
-    },
-
-    find: function(predicate, context, notSetValue) {
-      var entry = this.findEntry(predicate, context);
-      return entry ? entry[1] : notSetValue;
-    },
-
-    findEntry: function(predicate, context) {
-      var found;
-      this.__iterate(function(v, k, c)  {
-        if (predicate.call(context, v, k, c)) {
-          found = [k, v];
-          return false;
-        }
-      });
-      return found;
-    },
-
-    findLastEntry: function(predicate, context) {
-      return this.toSeq().reverse().findEntry(predicate, context);
-    },
-
-    forEach: function(sideEffect, context) {
-      assertNotInfinite(this.size);
-      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
-    },
-
-    join: function(separator) {
-      assertNotInfinite(this.size);
-      separator = separator !== undefined ? '' + separator : ',';
-      var joined = '';
-      var isFirst = true;
-      this.__iterate(function(v ) {
-        isFirst ? (isFirst = false) : (joined += separator);
-        joined += v !== null && v !== undefined ? v.toString() : '';
-      });
-      return joined;
-    },
-
-    keys: function() {
-      return this.__iterator(ITERATE_KEYS);
-    },
-
-    map: function(mapper, context) {
-      return reify(this, mapFactory(this, mapper, context));
-    },
-
-    reduce: function(reducer, initialReduction, context) {
-      assertNotInfinite(this.size);
-      var reduction;
-      var useFirst;
-      if (arguments.length < 2) {
-        useFirst = true;
-      } else {
-        reduction = initialReduction;
-      }
-      this.__iterate(function(v, k, c)  {
-        if (useFirst) {
-          useFirst = false;
-          reduction = v;
-        } else {
-          reduction = reducer.call(context, reduction, v, k, c);
-        }
-      });
-      return reduction;
-    },
-
-    reduceRight: function(reducer, initialReduction, context) {
-      var reversed = this.toKeyedSeq().reverse();
-      return reversed.reduce.apply(reversed, arguments);
-    },
-
-    reverse: function() {
-      return reify(this, reverseFactory(this, true));
-    },
-
-    slice: function(begin, end) {
-      return reify(this, sliceFactory(this, begin, end, true));
-    },
-
-    some: function(predicate, context) {
-      return !this.every(not(predicate), context);
-    },
-
-    sort: function(comparator) {
-      return reify(this, sortFactory(this, comparator));
-    },
-
-    values: function() {
-      return this.__iterator(ITERATE_VALUES);
-    },
-
-
-    // ### More sequential methods
-
-    butLast: function() {
-      return this.slice(0, -1);
-    },
-
-    isEmpty: function() {
-      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
-    },
-
-    count: function(predicate, context) {
-      return ensureSize(
-        predicate ? this.toSeq().filter(predicate, context) : this
-      );
-    },
-
-    countBy: function(grouper, context) {
-      return countByFactory(this, grouper, context);
-    },
-
-    equals: function(other) {
-      return deepEqual(this, other);
-    },
-
-    entrySeq: function() {
-      var iterable = this;
-      if (iterable._cache) {
-        // We cache as an entries array, so we can just return the cache!
-        return new ArraySeq(iterable._cache);
-      }
-      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
-      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
-      return entriesSequence;
-    },
-
-    filterNot: function(predicate, context) {
-      return this.filter(not(predicate), context);
-    },
-
-    findLast: function(predicate, context, notSetValue) {
-      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
-    },
-
-    first: function() {
-      return this.find(returnTrue);
-    },
-
-    flatMap: function(mapper, context) {
-      return reify(this, flatMapFactory(this, mapper, context));
-    },
-
-    flatten: function(depth) {
-      return reify(this, flattenFactory(this, depth, true));
-    },
-
-    fromEntrySeq: function() {
-      return new FromEntriesSequence(this);
-    },
-
-    get: function(searchKey, notSetValue) {
-      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
-    },
-
-    getIn: function(searchKeyPath, notSetValue) {
-      var nested = this;
-      // Note: in an ES6 environment, we would prefer:
-      // for (var key of searchKeyPath) {
-      var iter = forceIterator(searchKeyPath);
-      var step;
-      while (!(step = iter.next()).done) {
-        var key = step.value;
-        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
-        if (nested === NOT_SET) {
-          return notSetValue;
-        }
-      }
-      return nested;
-    },
-
-    groupBy: function(grouper, context) {
-      return groupByFactory(this, grouper, context);
-    },
-
-    has: function(searchKey) {
-      return this.get(searchKey, NOT_SET) !== NOT_SET;
-    },
-
-    hasIn: function(searchKeyPath) {
-      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
-    },
-
-    isSubset: function(iter) {
-      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
-      return this.every(function(value ) {return iter.includes(value)});
-    },
-
-    isSuperset: function(iter) {
-      iter = typeof iter.isSubset === 'function' ? iter : Iterable(iter);
-      return iter.isSubset(this);
-    },
-
-    keySeq: function() {
-      return this.toSeq().map(keyMapper).toIndexedSeq();
-    },
-
-    last: function() {
-      return this.toSeq().reverse().first();
-    },
-
-    max: function(comparator) {
-      return maxFactory(this, comparator);
-    },
-
-    maxBy: function(mapper, comparator) {
-      return maxFactory(this, comparator, mapper);
-    },
-
-    min: function(comparator) {
-      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
-    },
-
-    minBy: function(mapper, comparator) {
-      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
-    },
-
-    rest: function() {
-      return this.slice(1);
-    },
-
-    skip: function(amount) {
-      return this.slice(Math.max(0, amount));
-    },
-
-    skipLast: function(amount) {
-      return reify(this, this.toSeq().reverse().skip(amount).reverse());
-    },
-
-    skipWhile: function(predicate, context) {
-      return reify(this, skipWhileFactory(this, predicate, context, true));
-    },
-
-    skipUntil: function(predicate, context) {
-      return this.skipWhile(not(predicate), context);
-    },
-
-    sortBy: function(mapper, comparator) {
-      return reify(this, sortFactory(this, comparator, mapper));
-    },
-
-    take: function(amount) {
-      return this.slice(0, Math.max(0, amount));
-    },
-
-    takeLast: function(amount) {
-      return reify(this, this.toSeq().reverse().take(amount).reverse());
-    },
-
-    takeWhile: function(predicate, context) {
-      return reify(this, takeWhileFactory(this, predicate, context));
-    },
-
-    takeUntil: function(predicate, context) {
-      return this.takeWhile(not(predicate), context);
-    },
-
-    valueSeq: function() {
-      return this.toIndexedSeq();
-    },
-
-
-    // ### Hashable Object
-
-    hashCode: function() {
-      return this.__hash || (this.__hash = hashIterable(this));
-    }
-
-
-    // ### Internal
-
-    // abstract __iterate(fn, reverse)
-
-    // abstract __iterator(type, reverse)
-  });
-
-  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
-  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
-  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
-  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';
-
-  var IterablePrototype = Iterable.prototype;
-  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
-  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
-  IterablePrototype.__toJS = IterablePrototype.toArray;
-  IterablePrototype.__toStringMapper = quoteString;
-  IterablePrototype.inspect =
-  IterablePrototype.toSource = function() { return this.toString(); };
-  IterablePrototype.chain = IterablePrototype.flatMap;
-  IterablePrototype.contains = IterablePrototype.includes;
-
-  // Temporary warning about using length
-  (function () {
-    try {
-      Object.defineProperty(IterablePrototype, 'length', {
-        get: function () {
-          if (!Iterable.noLengthWarning) {
-            var stack;
-            try {
-              throw new Error();
-            } catch (error) {
-              stack = error.stack;
-            }
-            if (stack.indexOf('_wrapObject') === -1) {
-              console && console.warn && console.warn(
-                'iterable.length has been deprecated, '+
-                'use iterable.size or iterable.count(). '+
-                'This warning will become a silent error in a future version. ' +
-                stack
-              );
-              return this.size;
-            }
-          }
-        }
-      });
-    } catch (e) {}
-  })();
-
-
-
-  mixin(KeyedIterable, {
-
-    // ### More sequential methods
-
-    flip: function() {
-      return reify(this, flipFactory(this));
-    },
-
-    findKey: function(predicate, context) {
-      var entry = this.findEntry(predicate, context);
-      return entry && entry[0];
-    },
-
-    findLastKey: function(predicate, context) {
-      return this.toSeq().reverse().findKey(predicate, context);
-    },
-
-    keyOf: function(searchValue) {
-      return this.findKey(function(value ) {return is(value, searchValue)});
-    },
-
-    lastKeyOf: function(searchValue) {
-      return this.findLastKey(function(value ) {return is(value, searchValue)});
-    },
-
-    mapEntries: function(mapper, context) {var this$0 = this;
-      var iterations = 0;
-      return reify(this,
-        this.toSeq().map(
-          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
-        ).fromEntrySeq()
-      );
-    },
-
-    mapKeys: function(mapper, context) {var this$0 = this;
-      return reify(this,
-        this.toSeq().flip().map(
-          function(k, v)  {return mapper.call(context, k, v, this$0)}
-        ).flip()
-      );
-    }
-
-  });
-
-  var KeyedIterablePrototype = KeyedIterable.prototype;
-  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
-  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
-  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
-  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};
-
-
-
-  mixin(IndexedIterable, {
-
-    // ### Conversion to other types
-
-    toKeyedSeq: function() {
-      return new ToKeyedSequence(this, false);
-    },
-
-
-    // ### ES6 Collection methods (ES6 Array and Map)
-
-    filter: function(predicate, context) {
-      return reify(this, filterFactory(this, predicate, context, false));
-    },
-
-    findIndex: function(predicate, context) {
-      var entry = this.findEntry(predicate, context);
-      return entry ? entry[0] : -1;
-    },
-
-    indexOf: function(searchValue) {
-      var key = this.toKeyedSeq().keyOf(searchValue);
-      return key === undefined ? -1 : key;
-    },
-
-    lastIndexOf: function(searchValue) {
-      var key = this.toKeyedSeq().reverse().keyOf(searchValue);
-      return key === undefined ? -1 : key;
-
-      // var index =
-      // return this.toSeq().reverse().indexOf(searchValue);
-    },
-
-    reverse: function() {
-      return reify(this, reverseFactory(this, false));
-    },
-
-    slice: function(begin, end) {
-      return reify(this, sliceFactory(this, begin, end, false));
-    },
-
-    splice: function(index, removeNum /*, ...values*/) {
-      var numArgs = arguments.length;
-      removeNum = Math.max(removeNum | 0, 0);
-      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
-        return this;
-      }
-      // If index is negative, it should resolve relative to the size of the
-      // collection. However size may be expensive to compute if not cached, so
-      // only call count() if the number is in fact negative.
-      index = resolveBegin(index, index < 0 ? this.count() : this.size);
-      var spliced = this.slice(0, index);
-      return reify(
-        this,
-        numArgs === 1 ?
-          spliced :
-          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
-      );
-    },
-
-
-    // ### More collection methods
-
-    findLastIndex: function(predicate, context) {
-      var key = this.toKeyedSeq().findLastKey(predicate, context);
-      return key === undefined ? -1 : key;
-    },
-
-    first: function() {
-      return this.get(0);
-    },
-
-    flatten: function(depth) {
-      return reify(this, flattenFactory(this, depth, false));
-    },
-
-    get: function(index, notSetValue) {
-      index = wrapIndex(this, index);
-      return (index < 0 || (this.size === Infinity ||
-          (this.size !== undefined && index > this.size))) ?
-        notSetValue :
-        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
-    },
-
-    has: function(index) {
-      index = wrapIndex(this, index);
-      return index >= 0 && (this.size !== undefined ?
-        this.size === Infinity || index < this.size :
-        this.indexOf(index) !== -1
-      );
-    },
-
-    interpose: function(separator) {
-      return reify(this, interposeFactory(this, separator));
-    },
-
-    interleave: function(/*...iterables*/) {
-      var iterables = [this].concat(arrCopy(arguments));
-      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
-      var interleaved = zipped.flatten(true);
-      if (zipped.size) {
-        interleaved.size = zipped.size * iterables.length;
-      }
-      return reify(this, interleaved);
-    },
-
-    last: function() {
-      return this.get(-1);
-    },
-
-    skipWhile: function(predicate, context) {
-      return reify(this, skipWhileFactory(this, predicate, context, false));
-    },
-
-    zip: function(/*, ...iterables */) {
-      var iterables = [this].concat(arrCopy(arguments));
-      return reify(this, zipWithFactory(this, defaultZipper, iterables));
-    },
-
-    zipWith: function(zipper/*, ...iterables */) {
-      var iterables = arrCopy(arguments);
-      iterables[0] = this;
-      return reify(this, zipWithFactory(this, zipper, iterables));
-    }
-
-  });
-
-  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
-  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;
-
-
-
-  mixin(SetIterable, {
-
-    // ### ES6 Collection methods (ES6 Array and Map)
-
-    get: function(value, notSetValue) {
-      return this.has(value) ? value : notSetValue;
-    },
-
-    includes: function(value) {
-      return this.has(value);
-    },
-
-
-    // ### More sequential methods
-
-    keySeq: function() {
-      return this.valueSeq();
-    }
-
-  });
-
-  SetIterable.prototype.has = IterablePrototype.includes;
-
-
-  // Mixin subclasses
-
-  mixin(KeyedSeq, KeyedIterable.prototype);
-  mixin(IndexedSeq, IndexedIterable.prototype);
-  mixin(SetSeq, SetIterable.prototype);
-
-  mixin(KeyedCollection, KeyedIterable.prototype);
-  mixin(IndexedCollection, IndexedIterable.prototype);
-  mixin(SetCollection, SetIterable.prototype);
-
-
-  // #pragma Helper functions
-
-  function keyMapper(v, k) {
-    return k;
-  }
-
-  function entryMapper(v, k) {
-    return [k, v];
-  }
-
-  function not(predicate) {
-    return function() {
-      return !predicate.apply(this, arguments);
-    }
-  }
-
-  function neg(predicate) {
-    return function() {
-      return -predicate.apply(this, arguments);
-    }
-  }
-
-  function quoteString(value) {
-    return typeof value === 'string' ? JSON.stringify(value) : value;
-  }
-
-  function defaultZipper() {
-    return arrCopy(arguments);
-  }
-
-  function defaultNegComparator(a, b) {
-    return a < b ? 1 : a > b ? -1 : 0;
-  }
-
-  function hashIterable(iterable) {
-    if (iterable.size === Infinity) {
-      return 0;
-    }
-    var ordered = isOrdered(iterable);
-    var keyed = isKeyed(iterable);
-    var h = ordered ? 1 : 0;
-    var size = iterable.__iterate(
-      keyed ?
-        ordered ?
-          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
-          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
-        ordered ?
-          function(v ) { h = 31 * h + hash(v) | 0; } :
-          function(v ) { h = h + hash(v) | 0; }
-    );
-    return murmurHashOfSize(size, h);
-  }
-
-  function murmurHashOfSize(size, h) {
-    h = imul(h, 0xCC9E2D51);
-    h = imul(h << 15 | h >>> -15, 0x1B873593);
-    h = imul(h << 13 | h >>> -13, 5);
-    h = (h + 0xE6546B64 | 0) ^ size;
-    h = imul(h ^ h >>> 16, 0x85EBCA6B);
-    h = imul(h ^ h >>> 13, 0xC2B2AE35);
-    h = smi(h ^ h >>> 16);
-    return h;
-  }
-
-  function hashMerge(a, b) {
-    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
-  }
-
-  var Immutable = {
-
-    Iterable: Iterable,
-
-    Seq: Seq,
-    Collection: Collection,
-    Map: Map,
-    OrderedMap: OrderedMap,
-    List: List,
-    Stack: Stack,
-    Set: Set,
-    OrderedSet: OrderedSet,
-
-    Record: Record,
-    Range: Range,
-    Repeat: Repeat,
-
-    is: is,
-    fromJS: fromJS
-
-  };
-
-  return Immutable;
-
-}));
\ No newline at end of file
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.min.js b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.min.js
deleted file mode 100644
index d85df2c..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/dist/immutable.min.js
+++ /dev/null
@@ -1,36 +0,0 @@
-/**
- *  Copyright (c) 2014-2015, Facebook, Inc.
- *  All rights reserved.
- *
- *  This source code is licensed under the BSD-style license found in the
- *  LICENSE file in the root directory of this source tree. An additional grant
- *  of patent rights can be found in the PATENTS file in the same directory.
- */
-!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):t.Immutable=e()}(this,function(){"use strict";function t(t,e){e&&(t.prototype=Object.create(e.prototype)),t.prototype.constructor=t}function e(t){return o(t)?t:O(t)}function r(t){return u(t)?t:x(t)}function n(t){return s(t)?t:k(t)}function i(t){return o(t)&&!a(t)?t:A(t)}function o(t){return!(!t||!t[ar])}function u(t){return!(!t||!t[hr])}function s(t){return!(!t||!t[fr])}function a(t){return u(t)||s(t)}function h(t){return!(!t||!t[cr])}function f(t){return t.value=!1,t}function c(t){t&&(t.value=!0)}function _(){}function p(t,e){e=e||0;for(var r=Math.max(0,t.length-e),n=Array(r),i=0;r>i;i++)n[i]=t[i+e];return n}function v(t){return void 0===t.size&&(t.size=t.__iterate(y)),t.size}function l(t,e){if("number"!=typeof e){var r=e>>>0;if(""+r!==e||4294967295===r)return NaN;e=r}return 0>e?v(t)+e:e}function y(){return!0}function d(t,e,r){return(0===t||void 0!==r&&-r>=t)&&(void 0===e||void 0!==r&&e>=r)}function m(t,e){return w(t,e,0)}function g(t,e){return w(t,e,e)}function w(t,e,r){return void 0===t?r:0>t?Math.max(0,e+t):void 0===e?t:Math.min(e,t)}function S(t){this.next=t}function z(t,e,r,n){var i=0===t?e:1===t?r:[e,r];return n?n.value=i:n={value:i,done:!1},n}function I(){return{value:void 0,done:!0}}function b(t){return!!M(t)}function q(t){return t&&"function"==typeof t.next}function D(t){var e=M(t);return e&&e.call(t)}function M(t){var e=t&&(zr&&t[zr]||t[Ir]);return"function"==typeof e?e:void 0}function E(t){return t&&"number"==typeof t.length}function O(t){return null===t||void 0===t?T():o(t)?t.toSeq():C(t)}function x(t){return null===t||void 0===t?T().toKeyedSeq():o(t)?u(t)?t.toSeq():t.fromEntrySeq():W(t)}function k(t){return null===t||void 0===t?T():o(t)?u(t)?t.entrySeq():t.toIndexedSeq():B(t)}function A(t){return(null===t||void 0===t?T():o(t)?u(t)?t.entrySeq():t:B(t)).toSetSeq()}function j(t){this._array=t,this.size=t.length}function K(t){var e=Object.keys(t);this._object=t,this._keys=e,
-this.size=e.length}function R(t){this._iterable=t,this.size=t.length||t.size}function U(t){this._iterator=t,this._iteratorCache=[]}function L(t){return!(!t||!t[qr])}function T(){return Dr||(Dr=new j([]))}function W(t){var e=Array.isArray(t)?new j(t).fromEntrySeq():q(t)?new U(t).fromEntrySeq():b(t)?new R(t).fromEntrySeq():"object"==typeof t?new K(t):void 0;if(!e)throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: "+t);return e}function B(t){var e=J(t);if(!e)throw new TypeError("Expected Array or iterable object of values: "+t);return e}function C(t){var e=J(t)||"object"==typeof t&&new K(t);if(!e)throw new TypeError("Expected Array or iterable object of values, or keyed object: "+t);return e}function J(t){return E(t)?new j(t):q(t)?new U(t):b(t)?new R(t):void 0}function N(t,e,r,n){var i=t._cache;if(i){for(var o=i.length-1,u=0;o>=u;u++){var s=i[r?o-u:u];if(e(s[1],n?s[0]:u,t)===!1)return u+1}return u}return t.__iterateUncached(e,r)}function P(t,e,r,n){var i=t._cache;if(i){var o=i.length-1,u=0;return new S(function(){var t=i[r?o-u:u];return u++>o?I():z(e,n?t[0]:u-1,t[1])})}return t.__iteratorUncached(e,r)}function H(t,e){return e?V(e,t,"",{"":t}):Y(t)}function V(t,e,r,n){return Array.isArray(e)?t.call(n,r,k(e).map(function(r,n){return V(t,r,n,e)})):Q(e)?t.call(n,r,x(e).map(function(r,n){return V(t,r,n,e)})):e}function Y(t){return Array.isArray(t)?k(t).map(Y).toList():Q(t)?x(t).map(Y).toMap():t}function Q(t){return t&&(t.constructor===Object||void 0===t.constructor)}function X(t,e){if(t===e||t!==t&&e!==e)return!0;if(!t||!e)return!1;if("function"==typeof t.valueOf&&"function"==typeof e.valueOf){if(t=t.valueOf(),e=e.valueOf(),t===e||t!==t&&e!==e)return!0;if(!t||!e)return!1}return"function"==typeof t.equals&&"function"==typeof e.equals&&t.equals(e)?!0:!1}function F(t,e){if(t===e)return!0;if(!o(e)||void 0!==t.size&&void 0!==e.size&&t.size!==e.size||void 0!==t.__hash&&void 0!==e.__hash&&t.__hash!==e.__hash||u(t)!==u(e)||s(t)!==s(e)||h(t)!==h(e))return!1;if(0===t.size&&0===e.size)return!0;
-var r=!a(t);if(h(t)){var n=t.entries();return e.every(function(t,e){var i=n.next().value;return i&&X(i[1],t)&&(r||X(i[0],e))})&&n.next().done}var i=!1;if(void 0===t.size)if(void 0===e.size)"function"==typeof t.cacheResult&&t.cacheResult();else{i=!0;var f=t;t=e,e=f}var c=!0,_=e.__iterate(function(e,n){return(r?t.has(e):i?X(e,t.get(n,yr)):X(t.get(n,yr),e))?void 0:(c=!1,!1)});return c&&t.size===_}function G(t,e){if(!(this instanceof G))return new G(t,e);if(this._value=t,this.size=void 0===e?1/0:Math.max(0,e),0===this.size){if(Mr)return Mr;Mr=this}}function Z(t,e){if(!t)throw Error(e)}function $(t,e,r){if(!(this instanceof $))return new $(t,e,r);if(Z(0!==r,"Cannot step a Range by 0"),t=t||0,void 0===e&&(e=1/0),r=void 0===r?1:Math.abs(r),t>e&&(r=-r),this._start=t,this._end=e,this._step=r,this.size=Math.max(0,Math.ceil((e-t)/r-1)+1),0===this.size){if(Er)return Er;Er=this}}function tt(){throw TypeError("Abstract")}function et(){}function rt(){}function nt(){}function it(t){return t>>>1&1073741824|3221225471&t}function ot(t){if(t===!1||null===t||void 0===t)return 0;if("function"==typeof t.valueOf&&(t=t.valueOf(),t===!1||null===t||void 0===t))return 0;if(t===!0)return 1;var e=typeof t;if("number"===e){var r=0|t;for(r!==t&&(r^=4294967295*t);t>4294967295;)t/=4294967295,r^=t;return it(r)}if("string"===e)return t.length>Ur?ut(t):st(t);if("function"==typeof t.hashCode)return t.hashCode();if("object"===e)return at(t);if("function"==typeof t.toString)return st(""+t);throw Error("Value type "+e+" cannot be hashed.")}function ut(t){var e=Wr[t];return void 0===e&&(e=st(t),Tr===Lr&&(Tr=0,Wr={}),Tr++,Wr[t]=e),e}function st(t){for(var e=0,r=0;t.length>r;r++)e=31*e+t.charCodeAt(r)|0;return it(e)}function at(t){var e;if(jr&&(e=Or.get(t),void 0!==e))return e;if(e=t[Rr],void 0!==e)return e;if(!Ar){if(e=t.propertyIsEnumerable&&t.propertyIsEnumerable[Rr],void 0!==e)return e;if(e=ht(t),void 0!==e)return e}if(e=++Kr,1073741824&Kr&&(Kr=0),jr)Or.set(t,e);else{if(void 0!==kr&&kr(t)===!1)throw Error("Non-extensible objects are not allowed as keys.");
-if(Ar)Object.defineProperty(t,Rr,{enumerable:!1,configurable:!1,writable:!1,value:e});else if(void 0!==t.propertyIsEnumerable&&t.propertyIsEnumerable===t.constructor.prototype.propertyIsEnumerable)t.propertyIsEnumerable=function(){return this.constructor.prototype.propertyIsEnumerable.apply(this,arguments)},t.propertyIsEnumerable[Rr]=e;else{if(void 0===t.nodeType)throw Error("Unable to set a non-enumerable property on object.");t[Rr]=e}}return e}function ht(t){if(t&&t.nodeType>0)switch(t.nodeType){case 1:return t.uniqueID;case 9:return t.documentElement&&t.documentElement.uniqueID}}function ft(t){Z(t!==1/0,"Cannot perform this action with an infinite size.")}function ct(t){return null===t||void 0===t?zt():_t(t)&&!h(t)?t:zt().withMutations(function(e){var n=r(t);ft(n.size),n.forEach(function(t,r){return e.set(r,t)})})}function _t(t){return!(!t||!t[Br])}function pt(t,e){this.ownerID=t,this.entries=e}function vt(t,e,r){this.ownerID=t,this.bitmap=e,this.nodes=r}function lt(t,e,r){this.ownerID=t,this.count=e,this.nodes=r}function yt(t,e,r){this.ownerID=t,this.keyHash=e,this.entries=r}function dt(t,e,r){this.ownerID=t,this.keyHash=e,this.entry=r}function mt(t,e,r){this._type=e,this._reverse=r,this._stack=t._root&&wt(t._root)}function gt(t,e){return z(t,e[0],e[1])}function wt(t,e){return{node:t,index:0,__prev:e}}function St(t,e,r,n){var i=Object.create(Cr);return i.size=t,i._root=e,i.__ownerID=r,i.__hash=n,i.__altered=!1,i}function zt(){return Jr||(Jr=St(0))}function It(t,e,r){var n,i;if(t._root){var o=f(dr),u=f(mr);if(n=bt(t._root,t.__ownerID,0,void 0,e,r,o,u),!u.value)return t;i=t.size+(o.value?r===yr?-1:1:0)}else{if(r===yr)return t;i=1,n=new pt(t.__ownerID,[[e,r]])}return t.__ownerID?(t.size=i,t._root=n,t.__hash=void 0,t.__altered=!0,t):n?St(i,n):zt()}function bt(t,e,r,n,i,o,u,s){return t?t.update(e,r,n,i,o,u,s):o===yr?t:(c(s),c(u),new dt(e,n,[i,o]))}function qt(t){return t.constructor===dt||t.constructor===yt}function Dt(t,e,r,n,i){if(t.keyHash===n)return new yt(e,n,[t.entry,i]);var o,u=(0===r?t.keyHash:t.keyHash>>>r)&lr,s=(0===r?n:n>>>r)&lr,a=u===s?[Dt(t,e,r+pr,n,i)]:(o=new dt(e,n,i),
-s>u?[t,o]:[o,t]);return new vt(e,1<<u|1<<s,a)}function Mt(t,e,r,n){t||(t=new _);for(var i=new dt(t,ot(r),[r,n]),o=0;e.length>o;o++){var u=e[o];i=i.update(t,0,void 0,u[0],u[1])}return i}function Et(t,e,r,n){for(var i=0,o=0,u=Array(r),s=0,a=1,h=e.length;h>s;s++,a<<=1){var f=e[s];void 0!==f&&s!==n&&(i|=a,u[o++]=f)}return new vt(t,i,u)}function Ot(t,e,r,n,i){for(var o=0,u=Array(vr),s=0;0!==r;s++,r>>>=1)u[s]=1&r?e[o++]:void 0;return u[n]=i,new lt(t,o+1,u)}function xt(t,e,n){for(var i=[],u=0;n.length>u;u++){var s=n[u],a=r(s);o(s)||(a=a.map(function(t){return H(t)})),i.push(a)}return jt(t,e,i)}function kt(t,e,r){return t&&t.mergeDeep&&o(e)?t.mergeDeep(e):X(t,e)?t:e}function At(t){return function(e,r,n){if(e&&e.mergeDeepWith&&o(r))return e.mergeDeepWith(t,r);var i=t(e,r,n);return X(e,i)?e:i}}function jt(t,e,r){return r=r.filter(function(t){return 0!==t.size}),0===r.length?t:0!==t.size||t.__ownerID||1!==r.length?t.withMutations(function(t){for(var n=e?function(r,n){t.update(n,yr,function(t){return t===yr?r:e(t,r,n)})}:function(e,r){t.set(r,e)},i=0;r.length>i;i++)r[i].forEach(n)}):t.constructor(r[0])}function Kt(t,e,r,n){var i=t===yr,o=e.next();if(o.done){var u=i?r:t,s=n(u);return s===u?t:s}Z(i||t&&t.set,"invalid keyPath");var a=o.value,h=i?yr:t.get(a,yr),f=Kt(h,e,r,n);return f===h?t:f===yr?t.remove(a):(i?zt():t).set(a,f)}function Rt(t){return t-=t>>1&1431655765,t=(858993459&t)+(t>>2&858993459),t=t+(t>>4)&252645135,t+=t>>8,t+=t>>16,127&t}function Ut(t,e,r,n){var i=n?t:p(t);return i[e]=r,i}function Lt(t,e,r,n){var i=t.length+1;if(n&&e+1===i)return t[e]=r,t;for(var o=Array(i),u=0,s=0;i>s;s++)s===e?(o[s]=r,u=-1):o[s]=t[s+u];return o}function Tt(t,e,r){var n=t.length-1;if(r&&e===n)return t.pop(),t;for(var i=Array(n),o=0,u=0;n>u;u++)u===e&&(o=1),i[u]=t[u+o];return i}function Wt(t){var e=Pt();if(null===t||void 0===t)return e;if(Bt(t))return t;var r=n(t),i=r.size;return 0===i?e:(ft(i),i>0&&vr>i?Nt(0,i,pr,null,new Ct(r.toArray())):e.withMutations(function(t){t.setSize(i),r.forEach(function(e,r){return t.set(r,e)})}))}function Bt(t){
-return!(!t||!t[Vr])}function Ct(t,e){this.array=t,this.ownerID=e}function Jt(t,e){function r(t,e,r){return 0===e?n(t,r):i(t,e,r)}function n(t,r){var n=r===s?a&&a.array:t&&t.array,i=r>o?0:o-r,h=u-r;return h>vr&&(h=vr),function(){if(i===h)return Xr;var t=e?--h:i++;return n&&n[t]}}function i(t,n,i){var s,a=t&&t.array,h=i>o?0:o-i>>n,f=(u-i>>n)+1;return f>vr&&(f=vr),function(){for(;;){if(s){var t=s();if(t!==Xr)return t;s=null}if(h===f)return Xr;var o=e?--f:h++;s=r(a&&a[o],n-pr,i+(o<<n))}}}var o=t._origin,u=t._capacity,s=Gt(u),a=t._tail;return r(t._root,t._level,0)}function Nt(t,e,r,n,i,o,u){var s=Object.create(Yr);return s.size=e-t,s._origin=t,s._capacity=e,s._level=r,s._root=n,s._tail=i,s.__ownerID=o,s.__hash=u,s.__altered=!1,s}function Pt(){return Qr||(Qr=Nt(0,0,pr))}function Ht(t,e,r){if(e=l(t,e),e!==e)return t;if(e>=t.size||0>e)return t.withMutations(function(t){0>e?Xt(t,e).set(0,r):Xt(t,0,e+1).set(e,r)});e+=t._origin;var n=t._tail,i=t._root,o=f(mr);return e>=Gt(t._capacity)?n=Vt(n,t.__ownerID,0,e,r,o):i=Vt(i,t.__ownerID,t._level,e,r,o),o.value?t.__ownerID?(t._root=i,t._tail=n,t.__hash=void 0,t.__altered=!0,t):Nt(t._origin,t._capacity,t._level,i,n):t}function Vt(t,e,r,n,i,o){var u=n>>>r&lr,s=t&&t.array.length>u;if(!s&&void 0===i)return t;var a;if(r>0){var h=t&&t.array[u],f=Vt(h,e,r-pr,n,i,o);return f===h?t:(a=Yt(t,e),a.array[u]=f,a)}return s&&t.array[u]===i?t:(c(o),a=Yt(t,e),void 0===i&&u===a.array.length-1?a.array.pop():a.array[u]=i,a)}function Yt(t,e){return e&&t&&e===t.ownerID?t:new Ct(t?t.array.slice():[],e)}function Qt(t,e){if(e>=Gt(t._capacity))return t._tail;if(1<<t._level+pr>e){for(var r=t._root,n=t._level;r&&n>0;)r=r.array[e>>>n&lr],n-=pr;return r}}function Xt(t,e,r){void 0!==e&&(e=0|e),void 0!==r&&(r=0|r);var n=t.__ownerID||new _,i=t._origin,o=t._capacity,u=i+e,s=void 0===r?o:0>r?o+r:i+r;if(u===i&&s===o)return t;if(u>=s)return t.clear();for(var a=t._level,h=t._root,f=0;0>u+f;)h=new Ct(h&&h.array.length?[void 0,h]:[],n),a+=pr,f+=1<<a;f&&(u+=f,i+=f,s+=f,o+=f);for(var c=Gt(o),p=Gt(s);p>=1<<a+pr;)h=new Ct(h&&h.array.length?[h]:[],n),
-a+=pr;var v=t._tail,l=c>p?Qt(t,s-1):p>c?new Ct([],n):v;if(v&&p>c&&o>u&&v.array.length){h=Yt(h,n);for(var y=h,d=a;d>pr;d-=pr){var m=c>>>d&lr;y=y.array[m]=Yt(y.array[m],n)}y.array[c>>>pr&lr]=v}if(o>s&&(l=l&&l.removeAfter(n,0,s)),u>=p)u-=p,s-=p,a=pr,h=null,l=l&&l.removeBefore(n,0,u);else if(u>i||c>p){for(f=0;h;){var g=u>>>a&lr;if(g!==p>>>a&lr)break;g&&(f+=(1<<a)*g),a-=pr,h=h.array[g]}h&&u>i&&(h=h.removeBefore(n,a,u-f)),h&&c>p&&(h=h.removeAfter(n,a,p-f)),f&&(u-=f,s-=f)}return t.__ownerID?(t.size=s-u,t._origin=u,t._capacity=s,t._level=a,t._root=h,t._tail=l,t.__hash=void 0,t.__altered=!0,t):Nt(u,s,a,h,l)}function Ft(t,e,r){for(var i=[],u=0,s=0;r.length>s;s++){var a=r[s],h=n(a);h.size>u&&(u=h.size),o(a)||(h=h.map(function(t){return H(t)})),i.push(h)}return u>t.size&&(t=t.setSize(u)),jt(t,e,i)}function Gt(t){return vr>t?0:t-1>>>pr<<pr}function Zt(t){return null===t||void 0===t?ee():$t(t)?t:ee().withMutations(function(e){var n=r(t);ft(n.size),n.forEach(function(t,r){return e.set(r,t)})})}function $t(t){return _t(t)&&h(t)}function te(t,e,r,n){var i=Object.create(Zt.prototype);return i.size=t?t.size:0,i._map=t,i._list=e,i.__ownerID=r,i.__hash=n,i}function ee(){return Fr||(Fr=te(zt(),Pt()))}function re(t,e,r){var n,i,o=t._map,u=t._list,s=o.get(e),a=void 0!==s;if(r===yr){if(!a)return t;u.size>=vr&&u.size>=2*o.size?(i=u.filter(function(t,e){return void 0!==t&&s!==e}),n=i.toKeyedSeq().map(function(t){return t[0]}).flip().toMap(),t.__ownerID&&(n.__ownerID=i.__ownerID=t.__ownerID)):(n=o.remove(e),i=s===u.size-1?u.pop():u.set(s,void 0))}else if(a){if(r===u.get(s)[1])return t;n=o,i=u.set(s,[e,r])}else n=o.set(e,u.size),i=u.set(u.size,[e,r]);return t.__ownerID?(t.size=n.size,t._map=n,t._list=i,t.__hash=void 0,t):te(n,i)}function ne(t,e){this._iter=t,this._useKeys=e,this.size=t.size}function ie(t){this._iter=t,this.size=t.size}function oe(t){this._iter=t,this.size=t.size}function ue(t){this._iter=t,this.size=t.size}function se(t){var e=Ee(t);return e._iter=t,e.size=t.size,e.flip=function(){return t},e.reverse=function(){var e=t.reverse.apply(this);
-return e.flip=function(){return t.reverse()},e},e.has=function(e){return t.includes(e)},e.includes=function(e){return t.has(e)},e.cacheResult=Oe,e.__iterateUncached=function(e,r){var n=this;return t.__iterate(function(t,r){return e(r,t,n)!==!1},r)},e.__iteratorUncached=function(e,r){if(e===Sr){var n=t.__iterator(e,r);return new S(function(){var t=n.next();if(!t.done){var e=t.value[0];t.value[0]=t.value[1],t.value[1]=e}return t})}return t.__iterator(e===wr?gr:wr,r)},e}function ae(t,e,r){var n=Ee(t);return n.size=t.size,n.has=function(e){return t.has(e)},n.get=function(n,i){var o=t.get(n,yr);return o===yr?i:e.call(r,o,n,t)},n.__iterateUncached=function(n,i){var o=this;return t.__iterate(function(t,i,u){return n(e.call(r,t,i,u),i,o)!==!1},i)},n.__iteratorUncached=function(n,i){var o=t.__iterator(Sr,i);return new S(function(){var i=o.next();if(i.done)return i;var u=i.value,s=u[0];return z(n,s,e.call(r,u[1],s,t),i)})},n}function he(t,e){var r=Ee(t);return r._iter=t,r.size=t.size,r.reverse=function(){return t},t.flip&&(r.flip=function(){var e=se(t);return e.reverse=function(){return t.flip()},e}),r.get=function(r,n){return t.get(e?r:-1-r,n)},r.has=function(r){return t.has(e?r:-1-r)},r.includes=function(e){return t.includes(e)},r.cacheResult=Oe,r.__iterate=function(e,r){var n=this;return t.__iterate(function(t,r){return e(t,r,n)},!r)},r.__iterator=function(e,r){return t.__iterator(e,!r)},r}function fe(t,e,r,n){var i=Ee(t);return n&&(i.has=function(n){var i=t.get(n,yr);return i!==yr&&!!e.call(r,i,n,t)},i.get=function(n,i){var o=t.get(n,yr);return o!==yr&&e.call(r,o,n,t)?o:i}),i.__iterateUncached=function(i,o){var u=this,s=0;return t.__iterate(function(t,o,a){return e.call(r,t,o,a)?(s++,i(t,n?o:s-1,u)):void 0},o),s},i.__iteratorUncached=function(i,o){var u=t.__iterator(Sr,o),s=0;return new S(function(){for(;;){var o=u.next();if(o.done)return o;var a=o.value,h=a[0],f=a[1];if(e.call(r,f,h,t))return z(i,n?h:s++,f,o)}})},i}function ce(t,e,r){var n=ct().asMutable();return t.__iterate(function(i,o){n.update(e.call(r,i,o,t),0,function(t){
-return t+1})}),n.asImmutable()}function _e(t,e,r){var n=u(t),i=(h(t)?Zt():ct()).asMutable();t.__iterate(function(o,u){i.update(e.call(r,o,u,t),function(t){return t=t||[],t.push(n?[u,o]:o),t})});var o=Me(t);return i.map(function(e){return be(t,o(e))})}function pe(t,e,r,n){var i=t.size;if(void 0!==e&&(e=0|e),void 0!==r&&(r=0|r),d(e,r,i))return t;var o=m(e,i),u=g(r,i);if(o!==o||u!==u)return pe(t.toSeq().cacheResult(),e,r,n);var s,a=u-o;a===a&&(s=0>a?0:a);var h=Ee(t);return h.size=0===s?s:t.size&&s||void 0,!n&&L(t)&&s>=0&&(h.get=function(e,r){return e=l(this,e),e>=0&&s>e?t.get(e+o,r):r}),h.__iterateUncached=function(e,r){var i=this;if(0===s)return 0;if(r)return this.cacheResult().__iterate(e,r);var u=0,a=!0,h=0;return t.__iterate(function(t,r){return a&&(a=u++<o)?void 0:(h++,e(t,n?r:h-1,i)!==!1&&h!==s)}),h},h.__iteratorUncached=function(e,r){if(0!==s&&r)return this.cacheResult().__iterator(e,r);var i=0!==s&&t.__iterator(e,r),u=0,a=0;return new S(function(){for(;u++<o;)i.next();if(++a>s)return I();var t=i.next();return n||e===wr?t:e===gr?z(e,a-1,void 0,t):z(e,a-1,t.value[1],t)})},h}function ve(t,e,r){var n=Ee(t);return n.__iterateUncached=function(n,i){var o=this;if(i)return this.cacheResult().__iterate(n,i);var u=0;return t.__iterate(function(t,i,s){return e.call(r,t,i,s)&&++u&&n(t,i,o)}),u},n.__iteratorUncached=function(n,i){var o=this;if(i)return this.cacheResult().__iterator(n,i);var u=t.__iterator(Sr,i),s=!0;return new S(function(){if(!s)return I();var t=u.next();if(t.done)return t;var i=t.value,a=i[0],h=i[1];return e.call(r,h,a,o)?n===Sr?t:z(n,a,h,t):(s=!1,I())})},n}function le(t,e,r,n){var i=Ee(t);return i.__iterateUncached=function(i,o){var u=this;if(o)return this.cacheResult().__iterate(i,o);var s=!0,a=0;return t.__iterate(function(t,o,h){return s&&(s=e.call(r,t,o,h))?void 0:(a++,i(t,n?o:a-1,u))}),a},i.__iteratorUncached=function(i,o){var u=this;if(o)return this.cacheResult().__iterator(i,o);var s=t.__iterator(Sr,o),a=!0,h=0;return new S(function(){var t,o,f;do{if(t=s.next(),t.done)return n||i===wr?t:i===gr?z(i,h++,void 0,t):z(i,h++,t.value[1],t);
-var c=t.value;o=c[0],f=c[1],a&&(a=e.call(r,f,o,u))}while(a);return i===Sr?t:z(i,o,f,t)})},i}function ye(t,e){var n=u(t),i=[t].concat(e).map(function(t){return o(t)?n&&(t=r(t)):t=n?W(t):B(Array.isArray(t)?t:[t]),t}).filter(function(t){return 0!==t.size});if(0===i.length)return t;if(1===i.length){var a=i[0];if(a===t||n&&u(a)||s(t)&&s(a))return a}var h=new j(i);return n?h=h.toKeyedSeq():s(t)||(h=h.toSetSeq()),h=h.flatten(!0),h.size=i.reduce(function(t,e){if(void 0!==t){var r=e.size;if(void 0!==r)return t+r}},0),h}function de(t,e,r){var n=Ee(t);return n.__iterateUncached=function(n,i){function u(t,h){var f=this;t.__iterate(function(t,i){return(!e||e>h)&&o(t)?u(t,h+1):n(t,r?i:s++,f)===!1&&(a=!0),!a},i)}var s=0,a=!1;return u(t,0),s},n.__iteratorUncached=function(n,i){var u=t.__iterator(n,i),s=[],a=0;return new S(function(){for(;u;){var t=u.next();if(t.done===!1){var h=t.value;if(n===Sr&&(h=h[1]),e&&!(e>s.length)||!o(h))return r?t:z(n,a++,h,t);s.push(u),u=h.__iterator(n,i)}else u=s.pop()}return I()})},n}function me(t,e,r){var n=Me(t);return t.toSeq().map(function(i,o){return n(e.call(r,i,o,t))}).flatten(!0)}function ge(t,e){var r=Ee(t);return r.size=t.size&&2*t.size-1,r.__iterateUncached=function(r,n){var i=this,o=0;return t.__iterate(function(t,n){return(!o||r(e,o++,i)!==!1)&&r(t,o++,i)!==!1},n),o},r.__iteratorUncached=function(r,n){var i,o=t.__iterator(wr,n),u=0;return new S(function(){return(!i||u%2)&&(i=o.next(),i.done)?i:u%2?z(r,u++,e):z(r,u++,i.value,i)})},r}function we(t,e,r){e||(e=xe);var n=u(t),i=0,o=t.toSeq().map(function(e,n){return[n,e,i++,r?r(e,n,t):e]}).toArray();return o.sort(function(t,r){return e(t[3],r[3])||t[2]-r[2]}).forEach(n?function(t,e){o[e].length=2}:function(t,e){o[e]=t[1]}),n?x(o):s(t)?k(o):A(o)}function Se(t,e,r){if(e||(e=xe),r){var n=t.toSeq().map(function(e,n){return[e,r(e,n,t)]}).reduce(function(t,r){return ze(e,t[1],r[1])?r:t});return n&&n[0]}return t.reduce(function(t,r){return ze(e,t,r)?r:t})}function ze(t,e,r){var n=t(r,e);return 0===n&&r!==e&&(void 0===r||null===r||r!==r)||n>0}function Ie(t,r,n){
-var i=Ee(t);return i.size=new j(n).map(function(t){return t.size}).min(),i.__iterate=function(t,e){for(var r,n=this.__iterator(wr,e),i=0;!(r=n.next()).done&&t(r.value,i++,this)!==!1;);return i},i.__iteratorUncached=function(t,i){var o=n.map(function(t){return t=e(t),D(i?t.reverse():t)}),u=0,s=!1;return new S(function(){var e;return s||(e=o.map(function(t){return t.next()}),s=e.some(function(t){return t.done})),s?I():z(t,u++,r.apply(null,e.map(function(t){return t.value})))})},i}function be(t,e){return L(t)?e:t.constructor(e)}function qe(t){if(t!==Object(t))throw new TypeError("Expected [K, V] tuple: "+t)}function De(t){return ft(t.size),v(t)}function Me(t){return u(t)?r:s(t)?n:i}function Ee(t){return Object.create((u(t)?x:s(t)?k:A).prototype)}function Oe(){return this._iter.cacheResult?(this._iter.cacheResult(),this.size=this._iter.size,this):O.prototype.cacheResult.call(this)}function xe(t,e){return t>e?1:e>t?-1:0}function ke(t){var r=D(t);if(!r){if(!E(t))throw new TypeError("Expected iterable or array-like: "+t);r=D(e(t))}return r}function Ae(t,e){var r,n=function(o){if(o instanceof n)return o;if(!(this instanceof n))return new n(o);if(!r){r=!0;var u=Object.keys(t);Re(i,u),i.size=u.length,i._name=e,i._keys=u,i._defaultValues=t}this._map=ct(o)},i=n.prototype=Object.create(Gr);return i.constructor=n,n}function je(t,e,r){var n=Object.create(Object.getPrototypeOf(t));return n._map=e,n.__ownerID=r,n}function Ke(t){return t._name||t.constructor.name||"Record"}function Re(t,e){try{e.forEach(Ue.bind(void 0,t))}catch(r){}}function Ue(t,e){Object.defineProperty(t,e,{get:function(){return this.get(e)},set:function(t){Z(this.__ownerID,"Cannot set on an immutable record."),this.set(e,t)}})}function Le(t){return null===t||void 0===t?Ce():Te(t)&&!h(t)?t:Ce().withMutations(function(e){var r=i(t);ft(r.size),r.forEach(function(t){return e.add(t)})})}function Te(t){return!(!t||!t[Zr])}function We(t,e){return t.__ownerID?(t.size=e.size,t._map=e,t):e===t._map?t:0===e.size?t.__empty():t.__make(e)}function Be(t,e){var r=Object.create($r);
-return r.size=t?t.size:0,r._map=t,r.__ownerID=e,r}function Ce(){return tn||(tn=Be(zt()))}function Je(t){return null===t||void 0===t?He():Ne(t)?t:He().withMutations(function(e){var r=i(t);ft(r.size),r.forEach(function(t){return e.add(t)})})}function Ne(t){return Te(t)&&h(t)}function Pe(t,e){var r=Object.create(en);return r.size=t?t.size:0,r._map=t,r.__ownerID=e,r}function He(){return rn||(rn=Pe(ee()))}function Ve(t){return null===t||void 0===t?Xe():Ye(t)?t:Xe().unshiftAll(t)}function Ye(t){return!(!t||!t[nn])}function Qe(t,e,r,n){var i=Object.create(on);return i.size=t,i._head=e,i.__ownerID=r,i.__hash=n,i.__altered=!1,i}function Xe(){return un||(un=Qe(0))}function Fe(t,e){var r=function(r){t.prototype[r]=e[r]};return Object.keys(e).forEach(r),Object.getOwnPropertySymbols&&Object.getOwnPropertySymbols(e).forEach(r),t}function Ge(t,e){return e}function Ze(t,e){return[e,t]}function $e(t){return function(){return!t.apply(this,arguments)}}function tr(t){return function(){return-t.apply(this,arguments)}}function er(t){return"string"==typeof t?JSON.stringify(t):t}function rr(){return p(arguments)}function nr(t,e){return e>t?1:t>e?-1:0}function ir(t){if(t.size===1/0)return 0;var e=h(t),r=u(t),n=e?1:0,i=t.__iterate(r?e?function(t,e){n=31*n+ur(ot(t),ot(e))|0}:function(t,e){n=n+ur(ot(t),ot(e))|0}:e?function(t){n=31*n+ot(t)|0}:function(t){n=n+ot(t)|0});return or(i,n)}function or(t,e){return e=xr(e,3432918353),e=xr(e<<15|e>>>-15,461845907),e=xr(e<<13|e>>>-13,5),e=(e+3864292196|0)^t,e=xr(e^e>>>16,2246822507),e=xr(e^e>>>13,3266489909),e=it(e^e>>>16)}function ur(t,e){return t^e+2654435769+(t<<6)+(t>>2)|0}var sr=Array.prototype.slice;t(r,e),t(n,e),t(i,e),e.isIterable=o,e.isKeyed=u,e.isIndexed=s,e.isAssociative=a,e.isOrdered=h,e.Keyed=r,e.Indexed=n,e.Set=i;var ar="@@__IMMUTABLE_ITERABLE__@@",hr="@@__IMMUTABLE_KEYED__@@",fr="@@__IMMUTABLE_INDEXED__@@",cr="@@__IMMUTABLE_ORDERED__@@",_r="delete",pr=5,vr=1<<pr,lr=vr-1,yr={},dr={value:!1},mr={value:!1},gr=0,wr=1,Sr=2,zr="function"==typeof Symbol&&Symbol.iterator,Ir="@@iterator",br=zr||Ir;
-S.prototype.toString=function(){return"[Iterator]"},S.KEYS=gr,S.VALUES=wr,S.ENTRIES=Sr,S.prototype.inspect=S.prototype.toSource=function(){return""+this},S.prototype[br]=function(){return this},t(O,e),O.of=function(){return O(arguments)},O.prototype.toSeq=function(){return this},O.prototype.toString=function(){return this.__toString("Seq {","}")},O.prototype.cacheResult=function(){return!this._cache&&this.__iterateUncached&&(this._cache=this.entrySeq().toArray(),this.size=this._cache.length),this},O.prototype.__iterate=function(t,e){return N(this,t,e,!0)},O.prototype.__iterator=function(t,e){return P(this,t,e,!0)},t(x,O),x.prototype.toKeyedSeq=function(){return this},t(k,O),k.of=function(){return k(arguments)},k.prototype.toIndexedSeq=function(){return this},k.prototype.toString=function(){return this.__toString("Seq [","]")},k.prototype.__iterate=function(t,e){return N(this,t,e,!1)},k.prototype.__iterator=function(t,e){return P(this,t,e,!1)},t(A,O),A.of=function(){return A(arguments)},A.prototype.toSetSeq=function(){return this},O.isSeq=L,O.Keyed=x,O.Set=A,O.Indexed=k;var qr="@@__IMMUTABLE_SEQ__@@";O.prototype[qr]=!0,t(j,k),j.prototype.get=function(t,e){return this.has(t)?this._array[l(this,t)]:e},j.prototype.__iterate=function(t,e){for(var r=this._array,n=r.length-1,i=0;n>=i;i++)if(t(r[e?n-i:i],i,this)===!1)return i+1;return i},j.prototype.__iterator=function(t,e){var r=this._array,n=r.length-1,i=0;return new S(function(){return i>n?I():z(t,i,r[e?n-i++:i++])})},t(K,x),K.prototype.get=function(t,e){return void 0===e||this.has(t)?this._object[t]:e},K.prototype.has=function(t){return this._object.hasOwnProperty(t)},K.prototype.__iterate=function(t,e){for(var r=this._object,n=this._keys,i=n.length-1,o=0;i>=o;o++){var u=n[e?i-o:o];if(t(r[u],u,this)===!1)return o+1}return o},K.prototype.__iterator=function(t,e){var r=this._object,n=this._keys,i=n.length-1,o=0;return new S(function(){var u=n[e?i-o:o];return o++>i?I():z(t,u,r[u])})},K.prototype[cr]=!0,t(R,k),R.prototype.__iterateUncached=function(t,e){if(e)return this.cacheResult().__iterate(t,e);
-var r=this._iterable,n=D(r),i=0;if(q(n))for(var o;!(o=n.next()).done&&t(o.value,i++,this)!==!1;);return i},R.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var r=this._iterable,n=D(r);if(!q(n))return new S(I);var i=0;return new S(function(){var e=n.next();return e.done?e:z(t,i++,e.value)})},t(U,k),U.prototype.__iterateUncached=function(t,e){if(e)return this.cacheResult().__iterate(t,e);for(var r=this._iterator,n=this._iteratorCache,i=0;n.length>i;)if(t(n[i],i++,this)===!1)return i;for(var o;!(o=r.next()).done;){var u=o.value;if(n[i]=u,t(u,i++,this)===!1)break}return i},U.prototype.__iteratorUncached=function(t,e){if(e)return this.cacheResult().__iterator(t,e);var r=this._iterator,n=this._iteratorCache,i=0;return new S(function(){if(i>=n.length){var e=r.next();if(e.done)return e;n[i]=e.value}return z(t,i,n[i++])})};var Dr;t(G,k),G.prototype.toString=function(){return 0===this.size?"Repeat []":"Repeat [ "+this._value+" "+this.size+" times ]"},G.prototype.get=function(t,e){return this.has(t)?this._value:e},G.prototype.includes=function(t){return X(this._value,t)},G.prototype.slice=function(t,e){var r=this.size;return d(t,e,r)?this:new G(this._value,g(e,r)-m(t,r))},G.prototype.reverse=function(){return this},G.prototype.indexOf=function(t){return X(this._value,t)?0:-1},G.prototype.lastIndexOf=function(t){return X(this._value,t)?this.size:-1},G.prototype.__iterate=function(t,e){for(var r=0;this.size>r;r++)if(t(this._value,r,this)===!1)return r+1;return r},G.prototype.__iterator=function(t,e){var r=this,n=0;return new S(function(){return r.size>n?z(t,n++,r._value):I()})},G.prototype.equals=function(t){return t instanceof G?X(this._value,t._value):F(t)};var Mr;t($,k),$.prototype.toString=function(){return 0===this.size?"Range []":"Range [ "+this._start+"..."+this._end+(this._step>1?" by "+this._step:"")+" ]"},$.prototype.get=function(t,e){return this.has(t)?this._start+l(this,t)*this._step:e},$.prototype.includes=function(t){var e=(t-this._start)/this._step;return e>=0&&this.size>e&&e===Math.floor(e);
-},$.prototype.slice=function(t,e){return d(t,e,this.size)?this:(t=m(t,this.size),e=g(e,this.size),t>=e?new $(0,0):new $(this.get(t,this._end),this.get(e,this._end),this._step))},$.prototype.indexOf=function(t){var e=t-this._start;if(e%this._step===0){var r=e/this._step;if(r>=0&&this.size>r)return r}return-1},$.prototype.lastIndexOf=function(t){return this.indexOf(t)},$.prototype.__iterate=function(t,e){for(var r=this.size-1,n=this._step,i=e?this._start+r*n:this._start,o=0;r>=o;o++){if(t(i,o,this)===!1)return o+1;i+=e?-n:n}return o},$.prototype.__iterator=function(t,e){var r=this.size-1,n=this._step,i=e?this._start+r*n:this._start,o=0;return new S(function(){var u=i;return i+=e?-n:n,o>r?I():z(t,o++,u)})},$.prototype.equals=function(t){return t instanceof $?this._start===t._start&&this._end===t._end&&this._step===t._step:F(this,t)};var Er;t(tt,e),t(et,tt),t(rt,tt),t(nt,tt),tt.Keyed=et,tt.Indexed=rt,tt.Set=nt;var Or,xr="function"==typeof Math.imul&&-2===Math.imul(4294967295,2)?Math.imul:function(t,e){t=0|t,e=0|e;var r=65535&t,n=65535&e;return r*n+((t>>>16)*n+r*(e>>>16)<<16>>>0)|0},kr=Object.isExtensible,Ar=function(){try{return Object.defineProperty({},"@",{}),!0}catch(t){return!1}}(),jr="function"==typeof WeakMap;jr&&(Or=new WeakMap);var Kr=0,Rr="__immutablehash__";"function"==typeof Symbol&&(Rr=Symbol(Rr));var Ur=16,Lr=255,Tr=0,Wr={};t(ct,et),ct.prototype.toString=function(){return this.__toString("Map {","}")},ct.prototype.get=function(t,e){return this._root?this._root.get(0,void 0,t,e):e},ct.prototype.set=function(t,e){return It(this,t,e)},ct.prototype.setIn=function(t,e){return this.updateIn(t,yr,function(){return e})},ct.prototype.remove=function(t){return It(this,t,yr)},ct.prototype.deleteIn=function(t){return this.updateIn(t,function(){return yr})},ct.prototype.update=function(t,e,r){return 1===arguments.length?t(this):this.updateIn([t],e,r)},ct.prototype.updateIn=function(t,e,r){r||(r=e,e=void 0);var n=Kt(this,ke(t),e,r);return n===yr?void 0:n},ct.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,
-this._root=null,this.__hash=void 0,this.__altered=!0,this):zt()},ct.prototype.merge=function(){return xt(this,void 0,arguments)},ct.prototype.mergeWith=function(t){var e=sr.call(arguments,1);return xt(this,t,e)},ct.prototype.mergeIn=function(t){var e=sr.call(arguments,1);return this.updateIn(t,zt(),function(t){return"function"==typeof t.merge?t.merge.apply(t,e):e[e.length-1]})},ct.prototype.mergeDeep=function(){return xt(this,kt,arguments)},ct.prototype.mergeDeepWith=function(t){var e=sr.call(arguments,1);return xt(this,At(t),e)},ct.prototype.mergeDeepIn=function(t){var e=sr.call(arguments,1);return this.updateIn(t,zt(),function(t){return"function"==typeof t.mergeDeep?t.mergeDeep.apply(t,e):e[e.length-1]})},ct.prototype.sort=function(t){return Zt(we(this,t))},ct.prototype.sortBy=function(t,e){return Zt(we(this,e,t))},ct.prototype.withMutations=function(t){var e=this.asMutable();return t(e),e.wasAltered()?e.__ensureOwner(this.__ownerID):this},ct.prototype.asMutable=function(){return this.__ownerID?this:this.__ensureOwner(new _)},ct.prototype.asImmutable=function(){return this.__ensureOwner()},ct.prototype.wasAltered=function(){return this.__altered},ct.prototype.__iterator=function(t,e){return new mt(this,t,e)},ct.prototype.__iterate=function(t,e){var r=this,n=0;return this._root&&this._root.iterate(function(e){return n++,t(e[1],e[0],r)},e),n},ct.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?St(this.size,this._root,t,this.__hash):(this.__ownerID=t,this.__altered=!1,this)},ct.isMap=_t;var Br="@@__IMMUTABLE_MAP__@@",Cr=ct.prototype;Cr[Br]=!0,Cr[_r]=Cr.remove,Cr.removeIn=Cr.deleteIn,pt.prototype.get=function(t,e,r,n){for(var i=this.entries,o=0,u=i.length;u>o;o++)if(X(r,i[o][0]))return i[o][1];return n},pt.prototype.update=function(t,e,r,n,i,o,u){for(var s=i===yr,a=this.entries,h=0,f=a.length;f>h&&!X(n,a[h][0]);h++);var _=f>h;if(_?a[h][1]===i:s)return this;if(c(u),(s||!_)&&c(o),!s||1!==a.length){if(!_&&!s&&a.length>=Nr)return Mt(t,a,n,i);var v=t&&t===this.ownerID,l=v?a:p(a);return _?s?h===f-1?l.pop():l[h]=l.pop():l[h]=[n,i]:l.push([n,i]),
-v?(this.entries=l,this):new pt(t,l)}},vt.prototype.get=function(t,e,r,n){void 0===e&&(e=ot(r));var i=1<<((0===t?e:e>>>t)&lr),o=this.bitmap;return 0===(o&i)?n:this.nodes[Rt(o&i-1)].get(t+pr,e,r,n)},vt.prototype.update=function(t,e,r,n,i,o,u){void 0===r&&(r=ot(n));var s=(0===e?r:r>>>e)&lr,a=1<<s,h=this.bitmap,f=0!==(h&a);if(!f&&i===yr)return this;var c=Rt(h&a-1),_=this.nodes,p=f?_[c]:void 0,v=bt(p,t,e+pr,r,n,i,o,u);if(v===p)return this;if(!f&&v&&_.length>=Pr)return Ot(t,_,h,s,v);if(f&&!v&&2===_.length&&qt(_[1^c]))return _[1^c];if(f&&v&&1===_.length&&qt(v))return v;var l=t&&t===this.ownerID,y=f?v?h:h^a:h|a,d=f?v?Ut(_,c,v,l):Tt(_,c,l):Lt(_,c,v,l);return l?(this.bitmap=y,this.nodes=d,this):new vt(t,y,d)},lt.prototype.get=function(t,e,r,n){void 0===e&&(e=ot(r));var i=(0===t?e:e>>>t)&lr,o=this.nodes[i];return o?o.get(t+pr,e,r,n):n},lt.prototype.update=function(t,e,r,n,i,o,u){void 0===r&&(r=ot(n));var s=(0===e?r:r>>>e)&lr,a=i===yr,h=this.nodes,f=h[s];if(a&&!f)return this;var c=bt(f,t,e+pr,r,n,i,o,u);if(c===f)return this;var _=this.count;if(f){if(!c&&(_--,Hr>_))return Et(t,h,_,s)}else _++;var p=t&&t===this.ownerID,v=Ut(h,s,c,p);return p?(this.count=_,this.nodes=v,this):new lt(t,_,v)},yt.prototype.get=function(t,e,r,n){for(var i=this.entries,o=0,u=i.length;u>o;o++)if(X(r,i[o][0]))return i[o][1];return n},yt.prototype.update=function(t,e,r,n,i,o,u){void 0===r&&(r=ot(n));var s=i===yr;if(r!==this.keyHash)return s?this:(c(u),c(o),Dt(this,t,e,r,[n,i]));for(var a=this.entries,h=0,f=a.length;f>h&&!X(n,a[h][0]);h++);var _=f>h;if(_?a[h][1]===i:s)return this;if(c(u),(s||!_)&&c(o),s&&2===f)return new dt(t,this.keyHash,a[1^h]);var v=t&&t===this.ownerID,l=v?a:p(a);return _?s?h===f-1?l.pop():l[h]=l.pop():l[h]=[n,i]:l.push([n,i]),v?(this.entries=l,this):new yt(t,this.keyHash,l)},dt.prototype.get=function(t,e,r,n){return X(r,this.entry[0])?this.entry[1]:n},dt.prototype.update=function(t,e,r,n,i,o,u){var s=i===yr,a=X(n,this.entry[0]);return(a?i===this.entry[1]:s)?this:(c(u),s?void c(o):a?t&&t===this.ownerID?(this.entry[1]=i,this):new dt(t,this.keyHash,[n,i]):(c(o),
-Dt(this,t,e,ot(n),[n,i])))},pt.prototype.iterate=yt.prototype.iterate=function(t,e){for(var r=this.entries,n=0,i=r.length-1;i>=n;n++)if(t(r[e?i-n:n])===!1)return!1},vt.prototype.iterate=lt.prototype.iterate=function(t,e){for(var r=this.nodes,n=0,i=r.length-1;i>=n;n++){var o=r[e?i-n:n];if(o&&o.iterate(t,e)===!1)return!1}},dt.prototype.iterate=function(t,e){return t(this.entry)},t(mt,S),mt.prototype.next=function(){for(var t=this._type,e=this._stack;e;){var r,n=e.node,i=e.index++;if(n.entry){if(0===i)return gt(t,n.entry)}else if(n.entries){if(r=n.entries.length-1,r>=i)return gt(t,n.entries[this._reverse?r-i:i])}else if(r=n.nodes.length-1,r>=i){var o=n.nodes[this._reverse?r-i:i];if(o){if(o.entry)return gt(t,o.entry);e=this._stack=wt(o,e)}continue}e=this._stack=this._stack.__prev}return I()};var Jr,Nr=vr/4,Pr=vr/2,Hr=vr/4;t(Wt,rt),Wt.of=function(){return this(arguments)},Wt.prototype.toString=function(){return this.__toString("List [","]")},Wt.prototype.get=function(t,e){if(t=l(this,t),t>=0&&this.size>t){t+=this._origin;var r=Qt(this,t);return r&&r.array[t&lr]}return e},Wt.prototype.set=function(t,e){return Ht(this,t,e)},Wt.prototype.remove=function(t){return this.has(t)?0===t?this.shift():t===this.size-1?this.pop():this.splice(t,1):this},Wt.prototype.insert=function(t,e){return this.splice(t,0,e)},Wt.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=this._origin=this._capacity=0,this._level=pr,this._root=this._tail=null,this.__hash=void 0,this.__altered=!0,this):Pt()},Wt.prototype.push=function(){var t=arguments,e=this.size;return this.withMutations(function(r){Xt(r,0,e+t.length);for(var n=0;t.length>n;n++)r.set(e+n,t[n])})},Wt.prototype.pop=function(){return Xt(this,0,-1)},Wt.prototype.unshift=function(){var t=arguments;return this.withMutations(function(e){Xt(e,-t.length);for(var r=0;t.length>r;r++)e.set(r,t[r])})},Wt.prototype.shift=function(){return Xt(this,1)},Wt.prototype.merge=function(){return Ft(this,void 0,arguments)},Wt.prototype.mergeWith=function(t){var e=sr.call(arguments,1);
-return Ft(this,t,e)},Wt.prototype.mergeDeep=function(){return Ft(this,kt,arguments)},Wt.prototype.mergeDeepWith=function(t){var e=sr.call(arguments,1);return Ft(this,At(t),e)},Wt.prototype.setSize=function(t){return Xt(this,0,t)},Wt.prototype.slice=function(t,e){var r=this.size;return d(t,e,r)?this:Xt(this,m(t,r),g(e,r))},Wt.prototype.__iterator=function(t,e){var r=0,n=Jt(this,e);return new S(function(){var e=n();return e===Xr?I():z(t,r++,e)})},Wt.prototype.__iterate=function(t,e){for(var r,n=0,i=Jt(this,e);(r=i())!==Xr&&t(r,n++,this)!==!1;);return n},Wt.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Nt(this._origin,this._capacity,this._level,this._root,this._tail,t,this.__hash):(this.__ownerID=t,this)},Wt.isList=Bt;var Vr="@@__IMMUTABLE_LIST__@@",Yr=Wt.prototype;Yr[Vr]=!0,Yr[_r]=Yr.remove,Yr.setIn=Cr.setIn,Yr.deleteIn=Yr.removeIn=Cr.removeIn,Yr.update=Cr.update,Yr.updateIn=Cr.updateIn,Yr.mergeIn=Cr.mergeIn,Yr.mergeDeepIn=Cr.mergeDeepIn,Yr.withMutations=Cr.withMutations,Yr.asMutable=Cr.asMutable,Yr.asImmutable=Cr.asImmutable,Yr.wasAltered=Cr.wasAltered,Ct.prototype.removeBefore=function(t,e,r){if(r===e?1<<e:0===this.array.length)return this;var n=r>>>e&lr;if(n>=this.array.length)return new Ct([],t);var i,o=0===n;if(e>0){var u=this.array[n];if(i=u&&u.removeBefore(t,e-pr,r),i===u&&o)return this}if(o&&!i)return this;var s=Yt(this,t);if(!o)for(var a=0;n>a;a++)s.array[a]=void 0;return i&&(s.array[n]=i),s},Ct.prototype.removeAfter=function(t,e,r){if(r===(e?1<<e:0)||0===this.array.length)return this;var n=r-1>>>e&lr;if(n>=this.array.length)return this;var i;if(e>0){var o=this.array[n];if(i=o&&o.removeAfter(t,e-pr,r),i===o&&n===this.array.length-1)return this}var u=Yt(this,t);return u.array.splice(n+1),i&&(u.array[n]=i),u};var Qr,Xr={};t(Zt,ct),Zt.of=function(){return this(arguments)},Zt.prototype.toString=function(){return this.__toString("OrderedMap {","}")},Zt.prototype.get=function(t,e){var r=this._map.get(t);return void 0!==r?this._list.get(r)[1]:e},Zt.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,
-this._map.clear(),this._list.clear(),this):ee()},Zt.prototype.set=function(t,e){return re(this,t,e)},Zt.prototype.remove=function(t){return re(this,t,yr)},Zt.prototype.wasAltered=function(){return this._map.wasAltered()||this._list.wasAltered()},Zt.prototype.__iterate=function(t,e){var r=this;return this._list.__iterate(function(e){return e&&t(e[1],e[0],r)},e)},Zt.prototype.__iterator=function(t,e){return this._list.fromEntrySeq().__iterator(t,e)},Zt.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t),r=this._list.__ensureOwner(t);return t?te(e,r,t,this.__hash):(this.__ownerID=t,this._map=e,this._list=r,this)},Zt.isOrderedMap=$t,Zt.prototype[cr]=!0,Zt.prototype[_r]=Zt.prototype.remove;var Fr;t(ne,x),ne.prototype.get=function(t,e){return this._iter.get(t,e)},ne.prototype.has=function(t){return this._iter.has(t)},ne.prototype.valueSeq=function(){return this._iter.valueSeq()},ne.prototype.reverse=function(){var t=this,e=he(this,!0);return this._useKeys||(e.valueSeq=function(){return t._iter.toSeq().reverse()}),e},ne.prototype.map=function(t,e){var r=this,n=ae(this,t,e);return this._useKeys||(n.valueSeq=function(){return r._iter.toSeq().map(t,e)}),n},ne.prototype.__iterate=function(t,e){var r,n=this;return this._iter.__iterate(this._useKeys?function(e,r){return t(e,r,n)}:(r=e?De(this):0,function(i){return t(i,e?--r:r++,n)}),e)},ne.prototype.__iterator=function(t,e){if(this._useKeys)return this._iter.__iterator(t,e);var r=this._iter.__iterator(wr,e),n=e?De(this):0;return new S(function(){var i=r.next();return i.done?i:z(t,e?--n:n++,i.value,i)})},ne.prototype[cr]=!0,t(ie,k),ie.prototype.includes=function(t){return this._iter.includes(t)},ie.prototype.__iterate=function(t,e){var r=this,n=0;return this._iter.__iterate(function(e){return t(e,n++,r)},e)},ie.prototype.__iterator=function(t,e){var r=this._iter.__iterator(wr,e),n=0;return new S(function(){var e=r.next();return e.done?e:z(t,n++,e.value,e)})},t(oe,A),oe.prototype.has=function(t){return this._iter.includes(t)},oe.prototype.__iterate=function(t,e){
-var r=this;return this._iter.__iterate(function(e){return t(e,e,r)},e)},oe.prototype.__iterator=function(t,e){var r=this._iter.__iterator(wr,e);return new S(function(){var e=r.next();return e.done?e:z(t,e.value,e.value,e)})},t(ue,x),ue.prototype.entrySeq=function(){return this._iter.toSeq()},ue.prototype.__iterate=function(t,e){var r=this;return this._iter.__iterate(function(e){if(e){qe(e);var n=o(e);return t(n?e.get(1):e[1],n?e.get(0):e[0],r)}},e)},ue.prototype.__iterator=function(t,e){var r=this._iter.__iterator(wr,e);return new S(function(){for(;;){var e=r.next();if(e.done)return e;var n=e.value;if(n){qe(n);var i=o(n);return z(t,i?n.get(0):n[0],i?n.get(1):n[1],e)}}})},ie.prototype.cacheResult=ne.prototype.cacheResult=oe.prototype.cacheResult=ue.prototype.cacheResult=Oe,t(Ae,et),Ae.prototype.toString=function(){return this.__toString(Ke(this)+" {","}")},Ae.prototype.has=function(t){return this._defaultValues.hasOwnProperty(t)},Ae.prototype.get=function(t,e){if(!this.has(t))return e;var r=this._defaultValues[t];return this._map?this._map.get(t,r):r},Ae.prototype.clear=function(){if(this.__ownerID)return this._map&&this._map.clear(),this;var t=this.constructor;return t._empty||(t._empty=je(this,zt()))},Ae.prototype.set=function(t,e){if(!this.has(t))throw Error('Cannot set unknown key "'+t+'" on '+Ke(this));var r=this._map&&this._map.set(t,e);return this.__ownerID||r===this._map?this:je(this,r)},Ae.prototype.remove=function(t){if(!this.has(t))return this;var e=this._map&&this._map.remove(t);return this.__ownerID||e===this._map?this:je(this,e)},Ae.prototype.wasAltered=function(){return this._map.wasAltered()},Ae.prototype.__iterator=function(t,e){var n=this;return r(this._defaultValues).map(function(t,e){return n.get(e)}).__iterator(t,e)},Ae.prototype.__iterate=function(t,e){var n=this;return r(this._defaultValues).map(function(t,e){return n.get(e)}).__iterate(t,e)},Ae.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map&&this._map.__ensureOwner(t);return t?je(this,e,t):(this.__ownerID=t,
-this._map=e,this)};var Gr=Ae.prototype;Gr[_r]=Gr.remove,Gr.deleteIn=Gr.removeIn=Cr.removeIn,Gr.merge=Cr.merge,Gr.mergeWith=Cr.mergeWith,Gr.mergeIn=Cr.mergeIn,Gr.mergeDeep=Cr.mergeDeep,Gr.mergeDeepWith=Cr.mergeDeepWith,Gr.mergeDeepIn=Cr.mergeDeepIn,Gr.setIn=Cr.setIn,Gr.update=Cr.update,Gr.updateIn=Cr.updateIn,Gr.withMutations=Cr.withMutations,Gr.asMutable=Cr.asMutable,Gr.asImmutable=Cr.asImmutable,t(Le,nt),Le.of=function(){return this(arguments)},Le.fromKeys=function(t){return this(r(t).keySeq())},Le.prototype.toString=function(){return this.__toString("Set {","}")},Le.prototype.has=function(t){return this._map.has(t)},Le.prototype.add=function(t){return We(this,this._map.set(t,!0))},Le.prototype.remove=function(t){return We(this,this._map.remove(t))},Le.prototype.clear=function(){return We(this,this._map.clear())},Le.prototype.union=function(){var t=sr.call(arguments,0);return t=t.filter(function(t){return 0!==t.size}),0===t.length?this:0!==this.size||this.__ownerID||1!==t.length?this.withMutations(function(e){for(var r=0;t.length>r;r++)i(t[r]).forEach(function(t){return e.add(t)})}):this.constructor(t[0])},Le.prototype.intersect=function(){var t=sr.call(arguments,0);if(0===t.length)return this;t=t.map(function(t){return i(t)});var e=this;return this.withMutations(function(r){e.forEach(function(e){t.every(function(t){return t.includes(e)})||r.remove(e)})})},Le.prototype.subtract=function(){var t=sr.call(arguments,0);if(0===t.length)return this;t=t.map(function(t){return i(t)});var e=this;return this.withMutations(function(r){e.forEach(function(e){t.some(function(t){return t.includes(e)})&&r.remove(e)})})},Le.prototype.merge=function(){return this.union.apply(this,arguments)},Le.prototype.mergeWith=function(t){var e=sr.call(arguments,1);return this.union.apply(this,e)},Le.prototype.sort=function(t){return Je(we(this,t))},Le.prototype.sortBy=function(t,e){return Je(we(this,e,t))},Le.prototype.wasAltered=function(){return this._map.wasAltered()},Le.prototype.__iterate=function(t,e){var r=this;return this._map.__iterate(function(e,n){
-return t(n,n,r)},e)},Le.prototype.__iterator=function(t,e){return this._map.map(function(t,e){return e}).__iterator(t,e)},Le.prototype.__ensureOwner=function(t){if(t===this.__ownerID)return this;var e=this._map.__ensureOwner(t);return t?this.__make(e,t):(this.__ownerID=t,this._map=e,this)},Le.isSet=Te;var Zr="@@__IMMUTABLE_SET__@@",$r=Le.prototype;$r[Zr]=!0,$r[_r]=$r.remove,$r.mergeDeep=$r.merge,$r.mergeDeepWith=$r.mergeWith,$r.withMutations=Cr.withMutations,$r.asMutable=Cr.asMutable,$r.asImmutable=Cr.asImmutable,$r.__empty=Ce,$r.__make=Be;var tn;t(Je,Le),Je.of=function(){return this(arguments)},Je.fromKeys=function(t){return this(r(t).keySeq())},Je.prototype.toString=function(){return this.__toString("OrderedSet {","}")},Je.isOrderedSet=Ne;var en=Je.prototype;en[cr]=!0,en.__empty=He,en.__make=Pe;var rn;t(Ve,rt),Ve.of=function(){return this(arguments)},Ve.prototype.toString=function(){return this.__toString("Stack [","]")},Ve.prototype.get=function(t,e){var r=this._head;for(t=l(this,t);r&&t--;)r=r.next;return r?r.value:e},Ve.prototype.peek=function(){return this._head&&this._head.value},Ve.prototype.push=function(){if(0===arguments.length)return this;for(var t=this.size+arguments.length,e=this._head,r=arguments.length-1;r>=0;r--)e={value:arguments[r],next:e};return this.__ownerID?(this.size=t,this._head=e,this.__hash=void 0,this.__altered=!0,this):Qe(t,e)},Ve.prototype.pushAll=function(t){if(t=n(t),0===t.size)return this;ft(t.size);var e=this.size,r=this._head;return t.reverse().forEach(function(t){e++,r={value:t,next:r}}),this.__ownerID?(this.size=e,this._head=r,this.__hash=void 0,this.__altered=!0,this):Qe(e,r)},Ve.prototype.pop=function(){return this.slice(1)},Ve.prototype.unshift=function(){return this.push.apply(this,arguments)},Ve.prototype.unshiftAll=function(t){return this.pushAll(t)},Ve.prototype.shift=function(){return this.pop.apply(this,arguments)},Ve.prototype.clear=function(){return 0===this.size?this:this.__ownerID?(this.size=0,this._head=void 0,this.__hash=void 0,this.__altered=!0,this):Xe()},Ve.prototype.slice=function(t,e){
-if(d(t,e,this.size))return this;var r=m(t,this.size),n=g(e,this.size);if(n!==this.size)return rt.prototype.slice.call(this,t,e);for(var i=this.size-r,o=this._head;r--;)o=o.next;return this.__ownerID?(this.size=i,this._head=o,this.__hash=void 0,this.__altered=!0,this):Qe(i,o)},Ve.prototype.__ensureOwner=function(t){return t===this.__ownerID?this:t?Qe(this.size,this._head,t,this.__hash):(this.__ownerID=t,this.__altered=!1,this)},Ve.prototype.__iterate=function(t,e){if(e)return this.reverse().__iterate(t);for(var r=0,n=this._head;n&&t(n.value,r++,this)!==!1;)n=n.next;return r},Ve.prototype.__iterator=function(t,e){if(e)return this.reverse().__iterator(t);var r=0,n=this._head;return new S(function(){if(n){var e=n.value;return n=n.next,z(t,r++,e)}return I()})},Ve.isStack=Ye;var nn="@@__IMMUTABLE_STACK__@@",on=Ve.prototype;on[nn]=!0,on.withMutations=Cr.withMutations,on.asMutable=Cr.asMutable,on.asImmutable=Cr.asImmutable,on.wasAltered=Cr.wasAltered;var un;e.Iterator=S,Fe(e,{toArray:function(){ft(this.size);var t=Array(this.size||0);return this.valueSeq().__iterate(function(e,r){t[r]=e}),t},toIndexedSeq:function(){return new ie(this)},toJS:function(){return this.toSeq().map(function(t){return t&&"function"==typeof t.toJS?t.toJS():t}).__toJS()},toJSON:function(){return this.toSeq().map(function(t){return t&&"function"==typeof t.toJSON?t.toJSON():t}).__toJS()},toKeyedSeq:function(){return new ne(this,!0)},toMap:function(){return ct(this.toKeyedSeq())},toObject:function(){ft(this.size);var t={};return this.__iterate(function(e,r){t[r]=e}),t},toOrderedMap:function(){return Zt(this.toKeyedSeq())},toOrderedSet:function(){return Je(u(this)?this.valueSeq():this)},toSet:function(){return Le(u(this)?this.valueSeq():this)},toSetSeq:function(){return new oe(this)},toSeq:function(){return s(this)?this.toIndexedSeq():u(this)?this.toKeyedSeq():this.toSetSeq()},toStack:function(){return Ve(u(this)?this.valueSeq():this)},toList:function(){return Wt(u(this)?this.valueSeq():this)},toString:function(){return"[Iterable]"},__toString:function(t,e){
-return 0===this.size?t+e:t+" "+this.toSeq().map(this.__toStringMapper).join(", ")+" "+e},concat:function(){var t=sr.call(arguments,0);return be(this,ye(this,t))},includes:function(t){return this.some(function(e){return X(e,t)})},entries:function(){return this.__iterator(Sr)},every:function(t,e){ft(this.size);var r=!0;return this.__iterate(function(n,i,o){return t.call(e,n,i,o)?void 0:(r=!1,!1)}),r},filter:function(t,e){return be(this,fe(this,t,e,!0))},find:function(t,e,r){var n=this.findEntry(t,e);return n?n[1]:r},findEntry:function(t,e){var r;return this.__iterate(function(n,i,o){return t.call(e,n,i,o)?(r=[i,n],!1):void 0}),r},findLastEntry:function(t,e){return this.toSeq().reverse().findEntry(t,e)},forEach:function(t,e){return ft(this.size),this.__iterate(e?t.bind(e):t)},join:function(t){ft(this.size),t=void 0!==t?""+t:",";var e="",r=!0;return this.__iterate(function(n){r?r=!1:e+=t,e+=null!==n&&void 0!==n?""+n:""}),e},keys:function(){return this.__iterator(gr)},map:function(t,e){return be(this,ae(this,t,e))},reduce:function(t,e,r){ft(this.size);var n,i;return arguments.length<2?i=!0:n=e,this.__iterate(function(e,o,u){i?(i=!1,n=e):n=t.call(r,n,e,o,u)}),n},reduceRight:function(t,e,r){var n=this.toKeyedSeq().reverse();return n.reduce.apply(n,arguments)},reverse:function(){return be(this,he(this,!0))},slice:function(t,e){return be(this,pe(this,t,e,!0))},some:function(t,e){return!this.every($e(t),e)},sort:function(t){return be(this,we(this,t))},values:function(){return this.__iterator(wr)},butLast:function(){return this.slice(0,-1)},isEmpty:function(){return void 0!==this.size?0===this.size:!this.some(function(){return!0})},count:function(t,e){return v(t?this.toSeq().filter(t,e):this)},countBy:function(t,e){return ce(this,t,e)},equals:function(t){return F(this,t)},entrySeq:function(){var t=this;if(t._cache)return new j(t._cache);var e=t.toSeq().map(Ze).toIndexedSeq();return e.fromEntrySeq=function(){return t.toSeq()},e},filterNot:function(t,e){return this.filter($e(t),e)},findLast:function(t,e,r){return this.toKeyedSeq().reverse().find(t,e,r);
-},first:function(){return this.find(y)},flatMap:function(t,e){return be(this,me(this,t,e))},flatten:function(t){return be(this,de(this,t,!0))},fromEntrySeq:function(){return new ue(this)},get:function(t,e){return this.find(function(e,r){return X(r,t)},void 0,e)},getIn:function(t,e){for(var r,n=this,i=ke(t);!(r=i.next()).done;){var o=r.value;if(n=n&&n.get?n.get(o,yr):yr,n===yr)return e}return n},groupBy:function(t,e){return _e(this,t,e)},has:function(t){return this.get(t,yr)!==yr},hasIn:function(t){return this.getIn(t,yr)!==yr},isSubset:function(t){return t="function"==typeof t.includes?t:e(t),this.every(function(e){return t.includes(e)})},isSuperset:function(t){return t="function"==typeof t.isSubset?t:e(t),t.isSubset(this)},keySeq:function(){return this.toSeq().map(Ge).toIndexedSeq()},last:function(){return this.toSeq().reverse().first()},max:function(t){return Se(this,t)},maxBy:function(t,e){return Se(this,e,t)},min:function(t){return Se(this,t?tr(t):nr)},minBy:function(t,e){return Se(this,e?tr(e):nr,t)},rest:function(){return this.slice(1)},skip:function(t){return this.slice(Math.max(0,t))},skipLast:function(t){return be(this,this.toSeq().reverse().skip(t).reverse())},skipWhile:function(t,e){return be(this,le(this,t,e,!0))},skipUntil:function(t,e){return this.skipWhile($e(t),e)},sortBy:function(t,e){return be(this,we(this,e,t))},take:function(t){return this.slice(0,Math.max(0,t))},takeLast:function(t){return be(this,this.toSeq().reverse().take(t).reverse())},takeWhile:function(t,e){return be(this,ve(this,t,e))},takeUntil:function(t,e){return this.takeWhile($e(t),e)},valueSeq:function(){return this.toIndexedSeq()},hashCode:function(){return this.__hash||(this.__hash=ir(this))}});var sn=e.prototype;sn[ar]=!0,sn[br]=sn.values,sn.__toJS=sn.toArray,sn.__toStringMapper=er,sn.inspect=sn.toSource=function(){return""+this},sn.chain=sn.flatMap,sn.contains=sn.includes,function(){try{Object.defineProperty(sn,"length",{get:function(){if(!e.noLengthWarning){var t;try{throw Error()}catch(r){t=r.stack}if(-1===t.indexOf("_wrapObject"))return console&&console.warn&&console.warn("iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. "+t),
-this.size}}})}catch(t){}}(),Fe(r,{flip:function(){return be(this,se(this))},findKey:function(t,e){var r=this.findEntry(t,e);return r&&r[0]},findLastKey:function(t,e){return this.toSeq().reverse().findKey(t,e)},keyOf:function(t){return this.findKey(function(e){return X(e,t)})},lastKeyOf:function(t){return this.findLastKey(function(e){return X(e,t)})},mapEntries:function(t,e){var r=this,n=0;return be(this,this.toSeq().map(function(i,o){return t.call(e,[o,i],n++,r)}).fromEntrySeq())},mapKeys:function(t,e){var r=this;return be(this,this.toSeq().flip().map(function(n,i){return t.call(e,n,i,r)}).flip())}});var an=r.prototype;an[hr]=!0,an[br]=sn.entries,an.__toJS=sn.toObject,an.__toStringMapper=function(t,e){return JSON.stringify(e)+": "+er(t)},Fe(n,{toKeyedSeq:function(){return new ne(this,!1)},filter:function(t,e){return be(this,fe(this,t,e,!1))},findIndex:function(t,e){var r=this.findEntry(t,e);return r?r[0]:-1},indexOf:function(t){var e=this.toKeyedSeq().keyOf(t);return void 0===e?-1:e},lastIndexOf:function(t){var e=this.toKeyedSeq().reverse().keyOf(t);return void 0===e?-1:e},reverse:function(){return be(this,he(this,!1))},slice:function(t,e){return be(this,pe(this,t,e,!1))},splice:function(t,e){var r=arguments.length;if(e=Math.max(0|e,0),0===r||2===r&&!e)return this;t=m(t,0>t?this.count():this.size);var n=this.slice(0,t);return be(this,1===r?n:n.concat(p(arguments,2),this.slice(t+e)))},findLastIndex:function(t,e){var r=this.toKeyedSeq().findLastKey(t,e);return void 0===r?-1:r},first:function(){return this.get(0)},flatten:function(t){return be(this,de(this,t,!1))},get:function(t,e){return t=l(this,t),0>t||this.size===1/0||void 0!==this.size&&t>this.size?e:this.find(function(e,r){return r===t},void 0,e)},has:function(t){return t=l(this,t),t>=0&&(void 0!==this.size?this.size===1/0||this.size>t:-1!==this.indexOf(t))},interpose:function(t){return be(this,ge(this,t))},interleave:function(){var t=[this].concat(p(arguments)),e=Ie(this.toSeq(),k.of,t),r=e.flatten(!0);return e.size&&(r.size=e.size*t.length),be(this,r)},last:function(){
-return this.get(-1)},skipWhile:function(t,e){return be(this,le(this,t,e,!1))},zip:function(){var t=[this].concat(p(arguments));return be(this,Ie(this,rr,t))},zipWith:function(t){var e=p(arguments);return e[0]=this,be(this,Ie(this,t,e))}}),n.prototype[fr]=!0,n.prototype[cr]=!0,Fe(i,{get:function(t,e){return this.has(t)?t:e},includes:function(t){return this.has(t)},keySeq:function(){return this.valueSeq()}}),i.prototype.has=sn.includes,Fe(x,r.prototype),Fe(k,n.prototype),Fe(A,i.prototype),Fe(et,r.prototype),Fe(rt,n.prototype),Fe(nt,i.prototype);var hn={Iterable:e,Seq:O,Collection:tt,Map:ct,OrderedMap:Zt,List:Wt,Stack:Ve,Set:Le,OrderedSet:Je,Record:Ae,Range:$,Repeat:G,is:X,fromJS:H};return hn});
\ No newline at end of file
diff --git a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/package.json b/node_modules/react-native-deprecated-custom-components/node_modules/immutable/package.json
deleted file mode 100644
index 2720038..0000000
--- a/node_modules/react-native-deprecated-custom-components/node_modules/immutable/package.json
+++ /dev/null
@@ -1,77 +0,0 @@
-{
-  "name": "immutable",
-  "version": "3.7.6",
-  "description": "Immutable Data Collections",
-  "homepage": "https://github.com/facebook/immutable-js",
-  "author": {
-    "name": "Lee Byron",
-    "url": "https://github.com/leebyron"
-  },
-  "repository": {
-    "type": "git",
-    "url": "git://github.com/facebook/immutable-js.git"
-  },
-  "bugs": {
-    "url": "https://github.com/facebook/immutable-js/issues"
-  },
-  "main": "dist/immutable.js",
-  "typescript": {
-    "definition": "dist/immutable.d.ts"
-  },
-  "scripts": {
-    "test": "./resources/node_test.sh",
-    "perf": "node ./resources/bench.js"
-  },
-  "jest": {
-    "scriptPreprocessor": "resources/jestPreprocessor.js",
-    "testFileExtensions": [
-      "js",
-      "ts"
-    ],
-    "persistModuleRegistryBetweenSpecs": true
-  },
-  "devDependencies": {
-    "acorn": "^0.11.0",
-    "benchmark": "^1.0.0",
-    "bluebird": "^2.7.1",
-    "colors": "^1.0.3",
-    "es6-transpiler": "^0.7.18",
-    "estraverse": "^1.9.1",
-    "grunt": "^0.4.5",
-    "grunt-contrib-clean": "^0.5.0",
-    "grunt-contrib-copy": "^0.5.0",
-    "grunt-contrib-jshint": "^0.10.0",
-    "grunt-jest": "^0.1.0",
-    "grunt-release": "^0.7.0",
-    "jasmine-check": "^0.1.2",
-    "magic-string": "^0.2.6",
-    "microtime": "^1.2.0",
-    "react-tools": "^0.11.1",
-    "rollup": "^0.19.2",
-    "typescript": "~1.4.1",
-    "uglify-js": "^2.4.15"
-  },
-  "engines": {
-    "node": ">=0.8.0"
-  },
-  "files": [
-    "dist",
-    "contrib",
-    "README.md",
-    "LICENSE",
-    "PATENTS"
-  ],
-  "keywords": [
-    "immutable",
-    "persistent",
-    "lazy",
-    "data",
-    "datastructure",
-    "functional",
-    "collection",
-    "stateless",
-    "sequence",
-    "iteration"
-  ],
-  "license": "BSD-3-Clause"
-}
diff --git a/node_modules/react-native-deprecated-custom-components/src/Navigator.js b/node_modules/react-native-deprecated-custom-components/src/Navigator.js
index fc7d068..e500264 100644
--- a/node_modules/react-native-deprecated-custom-components/src/Navigator.js
+++ b/node_modules/react-native-deprecated-custom-components/src/Navigator.js
@@ -45,6 +45,7 @@ var NavigatorBreadcrumbNavigationBar = require('./NavigatorBreadcrumbNavigationB
 var NavigatorNavigationBar = require('./NavigatorNavigationBar');
 var NavigatorSceneConfigs = require('./NavigatorSceneConfigs');
 var React = require('react');
+var createClass = require('create-react-class');
 var Subscribable = require('./Subscribable');
 var TimerMixin = require('react-timer-mixin');
 
@@ -298,7 +299,7 @@ var GESTURE_ACTIONS = [
  * See `Navigator.SceneConfigs` for default animations and more info on
  * available [scene config options](docs/navigator.html#configurescene).
  */
-var Navigator = React.createClass({
+var Navigator = createClass({
 
   propTypes: {
     /**
diff --git a/node_modules/react-native-deprecated-custom-components/src/NavigatorBreadcrumbNavigationBar.js b/node_modules/react-native-deprecated-custom-components/src/NavigatorBreadcrumbNavigationBar.js
index 704216e..09efbbe 100644
--- a/node_modules/react-native-deprecated-custom-components/src/NavigatorBreadcrumbNavigationBar.js
+++ b/node_modules/react-native-deprecated-custom-components/src/NavigatorBreadcrumbNavigationBar.js
@@ -93,9 +93,9 @@ class NavigatorBreadcrumbNavigationBar extends React.Component {
       titleContentForRoute: PropTypes.func,
       iconForRoute: PropTypes.func,
     }),
-    navState: React.PropTypes.shape({
-      routeStack: React.PropTypes.arrayOf(React.PropTypes.object),
-      presentedIndex: React.PropTypes.number,
+    navState: PropTypes.shape({
+      routeStack: PropTypes.arrayOf(PropTypes.object),
+      presentedIndex: PropTypes.number,
     }),
     style: ViewPropTypes.style,
   };
